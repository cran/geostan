// Generated by rstantools.  Do not edit by hand.

/*
    geostan is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    geostan is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with geostan.  If not, see <http://www.gnu.org/licenses/>.
*/
#ifndef MODELS_HPP
#define MODELS_HPP
#define STAN__SERVICES__COMMAND_HPP
#ifndef USE_STANC3
#define USE_STANC3
#endif
#include <rstan/rstaninc.hpp>
// Code generated by stanc v2.26.1-4-gd72b68b7-dirty
#include <stan/model/model_header.hpp>
namespace model_foundation_namespace {
inline void validate_positive_index(const char* var_name, const char* expr,
                                    int val) {
  if (val < 1) {
    std::stringstream msg;
    msg << "Found dimension size less than one in simplex declaration"
        << "; variable=" << var_name << "; dimension size expression=" << expr
        << "; expression value=" << val;
    std::string msg_str(msg.str());
    throw std::invalid_argument(msg_str.c_str());
  }
}
inline void validate_unit_vector_index(const char* var_name, const char* expr,
                                       int val) {
  if (val <= 1) {
    std::stringstream msg;
    if (val == 1) {
      msg << "Found dimension size one in unit vector declaration."
          << " One-dimensional unit vector is discrete"
          << " but the target distribution must be continuous."
          << " variable=" << var_name << "; dimension size expression=" << expr;
    } else {
      msg << "Found dimension size less than one in unit vector declaration"
          << "; variable=" << var_name << "; dimension size expression=" << expr
          << "; expression value=" << val;
    }
    std::string msg_str(msg.str());
    throw std::invalid_argument(msg_str.c_str());
  }
}
using std::istream;
using std::string;
using std::stringstream;
using std::vector;
using std::pow;
using stan::io::dump;
using stan::math::lgamma;
using stan::model::model_base_crtp;
using stan::model::rvalue;
using stan::model::cons_list;
using stan::model::index_uni;
using stan::model::index_max;
using stan::model::index_min;
using stan::model::index_min_max;
using stan::model::index_multi;
using stan::model::index_omni;
using stan::model::nil_index_list;
using namespace stan::math;
using stan::math::pow; 
stan::math::profile_map profiles__;
static int current_statement__= 0;
static const std::vector<string> locations_array__ = {" (found before start of program)",
                                                      " (in 'foundation', line 424, column 2 to column 22)",
                                                      " (in 'foundation', line 425, column 2 to column 33)",
                                                      " (in 'foundation', line 426, column 2 to column 50)",
                                                      " (in 'foundation', line 427, column 2 to column 39)",
                                                      " (in 'foundation', line 428, column 2 to column 45)",
                                                      " (in 'foundation', line 429, column 2 to column 45)",
                                                      " (in 'foundation', line 431, column 2 to column 47)",
                                                      " (in 'foundation', line 432, column 2 to column 47)",
                                                      " (in 'foundation', line 433, column 2 to column 34)",
                                                      " (in 'foundation', line 434, column 2 to column 34)",
                                                      " (in 'foundation', line 435, column 2 to column 40)",
                                                      " (in 'foundation', line 436, column 2 to column 16)",
                                                      " (in 'foundation', line 438, column 2 to column 61)",
                                                      " (in 'foundation', line 439, column 2 to column 45)",
                                                      " (in 'foundation', line 440, column 2 to column 80)",
                                                      " (in 'foundation', line 441, column 2 to column 45)",
                                                      " (in 'foundation', line 442, column 2 to column 80)",
                                                      " (in 'foundation', line 445, column 2 to column 17)",
                                                      " (in 'foundation', line 446, column 2 to column 20)",
                                                      " (in 'foundation', line 447, column 2 to column 22)",
                                                      " (in 'foundation', line 448, column 2 to column 37)",
                                                      " (in 'foundation', line 449, column 2 to column 39)",
                                                      " (in 'foundation', line 451, column 2 to column 25)",
                                                      " (in 'foundation', line 452, column 2 to column 40)",
                                                      " (in 'foundation', line 454, column 2 to column 65)",
                                                      " (in 'foundation', line 456, column 4 to column 28)",
                                                      " (in 'foundation', line 457, column 2 to column 38)",
                                                      " (in 'foundation', line 458, column 2 to column 100)",
                                                      " (in 'foundation', line 459, column 2 to column 52)",
                                                      " (in 'foundation', line 463, column 2 to column 22)",
                                                      " (in 'foundation', line 464, column 2 to column 26)",
                                                      " (in 'foundation', line 465, column 2 to column 38)",
                                                      " (in 'foundation', line 467, column 2 to column 27)",
                                                      " (in 'foundation', line 468, column 2 to column 33)",
                                                      " (in 'foundation', line 470, column 2 to column 41)",
                                                      " (in 'foundation', line 472, column 2 to column 26)",
                                                      " (in 'foundation', line 473, column 2 to column 19)",
                                                      " (in 'foundation', line 474, column 14 to column 40)",
                                                      " (in 'foundation', line 474, column 2 to column 40)",
                                                      " (in 'foundation', line 475, column 32 to column 65)",
                                                      " (in 'foundation', line 475, column 13 to column 65)",
                                                      " (in 'foundation', line 475, column 2 to column 65)",
                                                      " (in 'foundation', line 476, column 36 to column 76)",
                                                      " (in 'foundation', line 476, column 16 to column 76)",
                                                      " (in 'foundation', line 476, column 2 to column 76)",
                                                      " (in 'foundation', line 477, column 12 to column 46)",
                                                      " (in 'foundation', line 477, column 2 to column 46)",
                                                      " (in 'foundation', line 479, column 4 to column 103)",
                                                      " (in 'foundation', line 480, column 11 to column 32)",
                                                      " (in 'foundation', line 480, column 4 to column 32)",
                                                      " (in 'foundation', line 481, column 4 to column 18)",
                                                      " (in 'foundation', line 478, column 17 to line 482, column 3)",
                                                      " (in 'foundation', line 478, column 2 to line 482, column 3)",
                                                      " (in 'foundation', line 484, column 4 to column 41)",
                                                      " (in 'foundation', line 485, column 4 to column 103)",
                                                      " (in 'foundation', line 486, column 11 to column 32)",
                                                      " (in 'foundation', line 486, column 4 to column 32)",
                                                      " (in 'foundation', line 487, column 4 to column 68)",
                                                      " (in 'foundation', line 483, column 17 to line 488, column 3)",
                                                      " (in 'foundation', line 483, column 2 to line 488, column 3)",
                                                      " (in 'foundation', line 490, column 4 to column 62)",
                                                      " (in 'foundation', line 491, column 4 to column 108)",
                                                      " (in 'foundation', line 492, column 11 to column 32)",
                                                      " (in 'foundation', line 492, column 4 to column 32)",
                                                      " (in 'foundation', line 493, column 4 to column 130)",
                                                      " (in 'foundation', line 489, column 17 to line 494, column 3)",
                                                      " (in 'foundation', line 489, column 2 to line 494, column 3)",
                                                      " (in 'foundation', line 499, column 6 to column 25)",
                                                      " (in 'foundation', line 498, column 11 to line 500, column 5)",
                                                      " (in 'foundation', line 497, column 6 to column 32)",
                                                      " (in 'foundation', line 496, column 19 to line 498, column 5)",
                                                      " (in 'foundation', line 496, column 4 to line 500, column 5)",
                                                      " (in 'foundation', line 501, column 4 to column 139)",
                                                      " (in 'foundation', line 502, column 4 to column 23)",
                                                      " (in 'foundation', line 503, column 4 to column 18)",
                                                      " (in 'foundation', line 495, column 11 to line 504, column 3)",
                                                      " (in 'foundation', line 495, column 2 to line 504, column 3)",
                                                      " (in 'foundation', line 507, column 4 to column 45)",
                                                      " (in 'foundation', line 510, column 1 to column 37)",
                                                      " (in 'foundation', line 509, column 21 to line 511, column 7)",
                                                      " (in 'foundation', line 509, column 6 to line 511, column 7)",
                                                      " (in 'foundation', line 508, column 16 to line 512, column 5)",
                                                      " (in 'foundation', line 508, column 4 to line 512, column 5)",
                                                      " (in 'foundation', line 514, column 18 to column 110)",
                                                      " (in 'foundation', line 514, column 1 to column 110)",
                                                      " (in 'foundation', line 513, column 13 to line 515, column 7)",
                                                      " (in 'foundation', line 513, column 4 to line 515, column 7)",
                                                      " (in 'foundation', line 516, column 16 to column 46)",
                                                      " (in 'foundation', line 516, column 4 to column 46)",
                                                      " (in 'foundation', line 520, column 6 to column 41)",
                                                      " (in 'foundation', line 519, column 11 to line 521, column 5)",
                                                      " (in 'foundation', line 518, column 6 to column 44)",
                                                      " (in 'foundation', line 517, column 26 to line 519, column 5)",
                                                      " (in 'foundation', line 517, column 4 to line 521, column 5)",
                                                      " (in 'foundation', line 506, column 16 to line 522, column 3)",
                                                      " (in 'foundation', line 506, column 2 to line 522, column 3)",
                                                      " (in 'foundation', line 526, column 1 to column 30)",
                                                      " (in 'foundation', line 525, column 21 to line 527, column 7)",
                                                      " (in 'foundation', line 525, column 6 to line 527, column 7)",
                                                      " (in 'foundation', line 524, column 16 to line 528, column 5)",
                                                      " (in 'foundation', line 524, column 4 to line 528, column 5)",
                                                      " (in 'foundation', line 530, column 23 to column 108)",
                                                      " (in 'foundation', line 530, column 6 to column 108)",
                                                      " (in 'foundation', line 529, column 13 to line 531, column 5)",
                                                      " (in 'foundation', line 529, column 4 to line 531, column 5)",
                                                      " (in 'foundation', line 532, column 16 to column 39)",
                                                      " (in 'foundation', line 532, column 4 to column 39)",
                                                      " (in 'foundation', line 523, column 20 to line 533, column 3)",
                                                      " (in 'foundation', line 523, column 2 to line 533, column 3)",
                                                      " (in 'foundation', line 534, column 19 to column 46)",
                                                      " (in 'foundation', line 534, column 2 to column 46)",
                                                      " (in 'foundation', line 535, column 18 to column 39)",
                                                      " (in 'foundation', line 535, column 2 to column 39)",
                                                      " (in 'foundation', line 660, column 2 to column 43)",
                                                      " (in 'foundation', line 662, column 4 to line 667, column 23)",
                                                      " (in 'foundation', line 661, column 31 to line 668, column 3)",
                                                      " (in 'foundation', line 661, column 2 to line 668, column 3)",
                                                      " (in 'foundation', line 670, column 4 to line 679, column 8)",
                                                      " (in 'foundation', line 669, column 31 to line 680, column 3)",
                                                      " (in 'foundation', line 669, column 2 to line 680, column 3)",
                                                      " (in 'foundation', line 683, column 6 to column 77)",
                                                      " (in 'foundation', line 682, column 19 to line 684, column 4)",
                                                      " (in 'foundation', line 682, column 3 to line 684, column 4)",
                                                      " (in 'foundation', line 686, column 6 to column 67)",
                                                      " (in 'foundation', line 685, column 20 to line 687, column 4)",
                                                      " (in 'foundation', line 685, column 3 to line 687, column 4)",
                                                      " (in 'foundation', line 689, column 7 to column 55)",
                                                      " (in 'foundation', line 688, column 19 to line 690, column 3)",
                                                      " (in 'foundation', line 688, column 3 to line 690, column 3)",
                                                      " (in 'foundation', line 692, column 5 to column 65)",
                                                      " (in 'foundation', line 691, column 19 to line 693, column 3)",
                                                      " (in 'foundation', line 691, column 2 to line 693, column 3)",
                                                      " (in 'foundation', line 681, column 17 to line 694, column 3)",
                                                      " (in 'foundation', line 681, column 2 to line 694, column 3)",
                                                      " (in 'foundation', line 539, column 8 to column 13)",
                                                      " (in 'foundation', line 539, column 22 to column 23)",
                                                      " (in 'foundation', line 539, column 2 to column 42)",
                                                      " (in 'foundation', line 540, column 2 to column 28)",
                                                      " (in 'foundation', line 541, column 2 to column 68)",
                                                      " (in 'foundation', line 542, column 14 to column 101)",
                                                      " (in 'foundation', line 542, column 2 to column 101)",
                                                      " (in 'foundation', line 543, column 17 to column 98)",
                                                      " (in 'foundation', line 543, column 2 to column 98)",
                                                      " (in 'foundation', line 544, column 18 to column 77)",
                                                      " (in 'foundation', line 544, column 2 to column 77)",
                                                      " (in 'foundation', line 563, column 1 to column 57)",
                                                      " (in 'foundation', line 564, column 23 to column 62)",
                                                      " (in 'foundation', line 564, column 1 to column 62)",
                                                      " (in 'foundation', line 565, column 1 to column 93)",
                                                      " (in 'foundation', line 566, column 1 to column 86)",
                                                      " (in 'foundation', line 562, column 25 to line 567, column 7)",
                                                      " (in 'foundation', line 562, column 6 to line 567, column 7)",
                                                      " (in 'foundation', line 561, column 11 to line 568, column 5)",
                                                      " (in 'foundation', line 549, column 15 to column 16)",
                                                      " (in 'foundation', line 549, column 8 to column 62)",
                                                      " (in 'foundation', line 550, column 8 to column 64)",
                                                      " (in 'foundation', line 551, column 23 to column 62)",
                                                      " (in 'foundation', line 551, column 1 to column 62)",
                                                      " (in 'foundation', line 552, column 1 to line 559, column 24)",
                                                      " (in 'foundation', line 548, column 25 to line 560, column 7)",
                                                      " (in 'foundation', line 548, column 6 to line 560, column 7)",
                                                      " (in 'foundation', line 547, column 20 to line 561, column 5)",
                                                      " (in 'foundation', line 547, column 4 to line 568, column 5)",
                                                      " (in 'foundation', line 569, column 6 to column 87)",
                                                      " (in 'foundation', line 570, column 6 to column 121)",
                                                      " (in 'foundation', line 546, column 13 to line 571, column 1)",
                                                      " (in 'foundation', line 546, column 2 to line 571, column 1)",
                                                      " (in 'foundation', line 574, column 4 to column 59)",
                                                      " (in 'foundation', line 575, column 4 to column 109)",
                                                      " (in 'foundation', line 573, column 14 to line 576, column 3)",
                                                      " (in 'foundation', line 573, column 2 to line 576, column 3)",
                                                      " (in 'foundation', line 579, column 20 to column 82)",
                                                      " (in 'foundation', line 579, column 4 to column 82)",
                                                      " (in 'foundation', line 580, column 21 to column 73)",
                                                      " (in 'foundation', line 580, column 4 to column 73)",
                                                      " (in 'foundation', line 582, column 6 to column 67)",
                                                      " (in 'foundation', line 583, column 28 to column 85)",
                                                      " (in 'foundation', line 583, column 6 to column 85)",
                                                      " (in 'foundation', line 581, column 20 to line 584, column 5)",
                                                      " (in 'foundation', line 581, column 4 to line 584, column 5)",
                                                      " (in 'foundation', line 585, column 21 to column 69)",
                                                      " (in 'foundation', line 585, column 4 to column 69)",
                                                      " (in 'foundation', line 578, column 19 to line 586, column 1)",
                                                      " (in 'foundation', line 578, column 2 to line 586, column 1)",
                                                      " (in 'foundation', line 590, column 6 to column 45)",
                                                      " (in 'foundation', line 591, column 21 to column 63)",
                                                      " (in 'foundation', line 591, column 6 to column 63)",
                                                      " (in 'foundation', line 589, column 19 to line 593, column 5)",
                                                      " (in 'foundation', line 589, column 4 to line 593, column 5)",
                                                      " (in 'foundation', line 594, column 4 to column 48)",
                                                      " (in 'foundation', line 595, column 4 to column 97)",
                                                      " (in 'foundation', line 596, column 11 to column 64)",
                                                      " (in 'foundation', line 596, column 4 to column 64)",
                                                      " (in 'foundation', line 588, column 12 to line 597, column 3)",
                                                      " (in 'foundation', line 588, column 2 to line 597, column 3)",
                                                      " (in 'foundation', line 600, column 4 to column 33)",
                                                      " (in 'foundation', line 601, column 4 to column 42)",
                                                      " (in 'foundation', line 602, column 4 to column 52)",
                                                      " (in 'foundation', line 603, column 4 to column 46)",
                                                      " (in 'foundation', line 604, column 4 to column 56)",
                                                      " (in 'foundation', line 605, column 4 to column 65)",
                                                      " (in 'foundation', line 599, column 11 to line 606, column 3)",
                                                      " (in 'foundation', line 599, column 2 to line 606, column 3)",
                                                      " (in 'foundation', line 609, column 4 to column 92)",
                                                      " (in 'foundation', line 611, column 6 to line 618, column 22)",
                                                      " (in 'foundation', line 610, column 41 to line 619, column 3)",
                                                      " (in 'foundation', line 610, column 4 to line 619, column 3)",
                                                      " (in 'foundation', line 621, column 6 to line 626, column 22)",
                                                      " (in 'foundation', line 620, column 27 to line 627, column 5)",
                                                      " (in 'foundation', line 620, column 4 to line 627, column 5)",
                                                      " (in 'foundation', line 608, column 11 to line 628, column 3)",
                                                      " (in 'foundation', line 608, column 2 to line 628, column 3)",
                                                      " (in 'foundation', line 631, column 2 to column 90)",
                                                      " (in 'foundation', line 633, column 4 to line 642, column 12)",
                                                      " (in 'foundation', line 632, column 39 to line 643, column 3)",
                                                      " (in 'foundation', line 632, column 2 to line 643, column 3)",
                                                      " (in 'foundation', line 645, column 4 to line 654, column 12)",
                                                      " (in 'foundation', line 644, column 25 to line 655, column 3)",
                                                      " (in 'foundation', line 644, column 2 to line 655, column 3)",
                                                      " (in 'foundation', line 630, column 9 to line 656, column 1)",
                                                      " (in 'foundation', line 630, column 0 to line 656, column 1)",
                                                      " (in 'foundation', line 293, column 2 to column 30)",
                                                      " (in 'foundation', line 295, column 2 to column 17)",
                                                      " (in 'foundation', line 296, column 2 to column 24)",
                                                      " (in 'foundation', line 298, column 2 to column 21)",
                                                      " (in 'foundation', line 299, column 2 to column 21)",
                                                      " (in 'foundation', line 300, column 8 to column 13)",
                                                      " (in 'foundation', line 300, column 2 to column 29)",
                                                      " (in 'foundation', line 301, column 8 to column 13)",
                                                      " (in 'foundation', line 301, column 2 to column 29)",
                                                      " (in 'foundation', line 302, column 2 to column 19)",
                                                      " (in 'foundation', line 304, column 9 to column 10)",
                                                      " (in 'foundation', line 304, column 2 to column 14)",
                                                      " (in 'foundation', line 305, column 8 to column 9)",
                                                      " (in 'foundation', line 305, column 2 to column 30)",
                                                      " (in 'foundation', line 306, column 8 to column 9)",
                                                      " (in 'foundation', line 306, column 2 to column 31)",
                                                      " (in 'foundation', line 307, column 2 to column 34)",
                                                      " (in 'foundation', line 309, column 9 to column 10)",
                                                      " (in 'foundation', line 309, column 2 to column 25)",
                                                      " (in 'foundation', line 311, column 2 to column 19)",
                                                      " (in 'foundation', line 312, column 8 to column 21)",
                                                      " (in 'foundation', line 312, column 2 to column 34)",
                                                      " (in 'foundation', line 313, column 2 to column 26)",
                                                      " (in 'foundation', line 314, column 9 to column 19)",
                                                      " (in 'foundation', line 314, column 2 to column 25)",
                                                      " (in 'foundation', line 315, column 8 to column 18)",
                                                      " (in 'foundation', line 315, column 2 to column 28)",
                                                      " (in 'foundation', line 316, column 8 to column 23)",
                                                      " (in 'foundation', line 316, column 2 to column 33)",
                                                      " (in 'foundation', line 319, column 2 to column 23)",
                                                      " (in 'foundation', line 321, column 2 to column 22)",
                                                      " (in 'foundation', line 322, column 2 to column 21)",
                                                      " (in 'foundation', line 323, column 8 to column 13)",
                                                      " (in 'foundation', line 323, column 2 to column 46)",
                                                      " (in 'foundation', line 325, column 8 to column 27)",
                                                      " (in 'foundation', line 325, column 2 to column 52)",
                                                      " (in 'foundation', line 326, column 8 to column 25)",
                                                      " (in 'foundation', line 326, column 2 to column 49)",
                                                      " (in 'foundation', line 328, column 9 to column 10)",
                                                      " (in 'foundation', line 328, column 12 to column 31)",
                                                      " (in 'foundation', line 328, column 2 to column 39)",
                                                      " (in 'foundation', line 330, column 8 to column 13)",
                                                      " (in 'foundation', line 330, column 22 to column 23)",
                                                      " (in 'foundation', line 330, column 2 to column 30)",
                                                      " (in 'foundation', line 331, column 8 to column 13)",
                                                      " (in 'foundation', line 331, column 31 to column 32)",
                                                      " (in 'foundation', line 331, column 2 to column 43)",
                                                      " (in 'foundation', line 333, column 9 to column 14)",
                                                      " (in 'foundation', line 333, column 2 to column 37)",
                                                      " (in 'foundation', line 334, column 9 to column 14)",
                                                      " (in 'foundation', line 334, column 2 to column 36)",
                                                      " (in 'foundation', line 335, column 9 to column 14)",
                                                      " (in 'foundation', line 335, column 2 to column 40)",
                                                      " (in 'foundation', line 336, column 9 to column 14)",
                                                      " (in 'foundation', line 336, column 2 to column 37)",
                                                      " (in 'foundation', line 337, column 9 to column 14)",
                                                      " (in 'foundation', line 337, column 2 to column 37)",
                                                      " (in 'foundation', line 338, column 9 to column 14)",
                                                      " (in 'foundation', line 338, column 2 to column 43)",
                                                      " (in 'foundation', line 339, column 9 to column 14)",
                                                      " (in 'foundation', line 339, column 2 to column 40)",
                                                      " (in 'foundation', line 340, column 2 to column 28)",
                                                      " (in 'foundation', line 342, column 2 to column 34)",
                                                      " (in 'foundation', line 343, column 2 to column 28)",
                                                      " (in 'foundation', line 344, column 2 to column 12)",
                                                      " (in 'foundation', line 345, column 2 to column 9)",
                                                      " (in 'foundation', line 346, column 9 to column 14)",
                                                      " (in 'foundation', line 346, column 2 to column 21)",
                                                      " (in 'foundation', line 347, column 8 to column 13)",
                                                      " (in 'foundation', line 347, column 2 to column 24)",
                                                      " (in 'foundation', line 348, column 8 to column 13)",
                                                      " (in 'foundation', line 348, column 2 to column 24)",
                                                      " (in 'foundation', line 349, column 8 to column 10)",
                                                      " (in 'foundation', line 349, column 2 to column 21)",
                                                      " (in 'foundation', line 350, column 9 to column 10)",
                                                      " (in 'foundation', line 350, column 2 to column 22)",
                                                      " (in 'foundation', line 351, column 2 to column 25)",
                                                      " (in 'foundation', line 352, column 9 to column 10)",
                                                      " (in 'foundation', line 352, column 2 to column 19)",
                                                      " (in 'foundation', line 354, column 2 to column 30)",
                                                      " (in 'foundation', line 355, column 2 to column 21)",
                                                      " (in 'foundation', line 356, column 8 to column 9)",
                                                      " (in 'foundation', line 356, column 2 to column 39)",
                                                      " (in 'foundation', line 358, column 2 to column 24)",
                                                      " (in 'foundation', line 359, column 2 to column 27)",
                                                      " (in 'foundation', line 360, column 9 to column 20)",
                                                      " (in 'foundation', line 360, column 2 to column 42)",
                                                      " (in 'foundation', line 361, column 18 to column 29)",
                                                      " (in 'foundation', line 361, column 2 to column 48)",
                                                      " (in 'foundation', line 363, column 2 to column 28)",
                                                      " (in 'foundation', line 364, column 2 to column 23)",
                                                      " (in 'foundation', line 365, column 2 to column 24)",
                                                      " (in 'foundation', line 367, column 2 to column 28)",
                                                      " (in 'foundation', line 368, column 2 to column 17)",
                                                      " (in 'foundation', line 369, column 8 to column 9)",
                                                      " (in 'foundation', line 369, column 2 to column 26)",
                                                      " (in 'foundation', line 370, column 8 to column 9)",
                                                      " (in 'foundation', line 370, column 2 to column 25)",
                                                      " (in 'foundation', line 371, column 2 to column 17)",
                                                      " (in 'foundation', line 372, column 9 to column 10)",
                                                      " (in 'foundation', line 372, column 12 to column 13)",
                                                      " (in 'foundation', line 372, column 2 to column 17)",
                                                      " (in 'foundation', line 373, column 2 to column 23)",
                                                      " (in 'foundation', line 374, column 8 to column 15)",
                                                      " (in 'foundation', line 374, column 2 to column 45)",
                                                      " (in 'foundation', line 375, column 8 to column 15)",
                                                      " (in 'foundation', line 375, column 2 to column 45)",
                                                      " (in 'foundation', line 376, column 9 to column 16)",
                                                      " (in 'foundation', line 376, column 2 to column 25)",
                                                      " (in 'foundation', line 377, column 8 to column 9)",
                                                      " (in 'foundation', line 377, column 2 to column 41)",
                                                      " (in 'foundation', line 378, column 9 to column 10)",
                                                      " (in 'foundation', line 378, column 2 to column 34)",
                                                      " (in 'foundation', line 380, column 2 to column 19)",
                                                      " (in 'foundation', line 381, column 9 to column 10)",
                                                      " (in 'foundation', line 381, column 12 to column 15)",
                                                      " (in 'foundation', line 381, column 2 to column 20)",
                                                      " (in 'foundation', line 382, column 2 to column 29)",
                                                      " (in 'foundation', line 383, column 2 to column 27)",
                                                      " (in 'foundation', line 384, column 2 to column 24)",
                                                      " (in 'foundation', line 386, column 2 to column 29)",
                                                      " (in 'foundation', line 387, column 2 to column 27)",
                                                      " (in 'foundation', line 389, column 2 to column 13)",
                                                      " (in 'foundation', line 390, column 2 to column 9)",
                                                      " (in 'foundation', line 391, column 9 to column 15)",
                                                      " (in 'foundation', line 391, column 2 to column 23)",
                                                      " (in 'foundation', line 392, column 8 to column 14)",
                                                      " (in 'foundation', line 392, column 2 to column 26)",
                                                      " (in 'foundation', line 393, column 8 to column 13)",
                                                      " (in 'foundation', line 393, column 2 to column 25)",
                                                      " (in 'foundation', line 394, column 8 to column 10)",
                                                      " (in 'foundation', line 394, column 2 to column 21)",
                                                      " (in 'foundation', line 395, column 9 to column 10)",
                                                      " (in 'foundation', line 395, column 2 to column 26)",
                                                      " (in 'foundation', line 396, column 2 to column 29)",
                                                      " (in 'foundation', line 397, column 2 to column 27)",
                                                      " (in 'foundation', line 401, column 2 to column 27)",
                                                      " (in 'foundation', line 403, column 2 to column 35)",
                                                      " (in 'foundation', line 404, column 2 to column 34)",
                                                      " (in 'foundation', line 405, column 2 to column 34)",
                                                      " (in 'foundation', line 406, column 2 to column 35)",
                                                      " (in 'foundation', line 407, column 2 to column 40)",
                                                      " (in 'foundation', line 408, column 2 to column 33)",
                                                      " (in 'foundation', line 409, column 2 to column 34)",
                                                      " (in 'foundation', line 410, column 2 to column 22)",
                                                      " (in 'foundation', line 411, column 2 to column 22)",
                                                      " (in 'foundation', line 412, column 2 to column 28)",
                                                      " (in 'foundation', line 413, column 2 to column 27)",
                                                      " (in 'foundation', line 414, column 2 to column 27)",
                                                      " (in 'foundation', line 415, column 2 to column 28)",
                                                      " (in 'foundation', line 416, column 2 to column 48)",
                                                      " (in 'foundation', line 417, column 2 to column 25)",
                                                      " (in 'foundation', line 418, column 2 to column 38)",
                                                      " (in 'foundation', line 419, column 2 to column 26)",
                                                      " (in 'foundation', line 420, column 2 to column 21)",
                                                      " (in 'foundation', line 424, column 9 to column 10)",
                                                      " (in 'foundation', line 425, column 9 to column 21)",
                                                      " (in 'foundation', line 426, column 8 to column 20)",
                                                      " (in 'foundation', line 427, column 9 to column 25)",
                                                      " (in 'foundation', line 428, column 8 to column 17)",
                                                      " (in 'foundation', line 429, column 8 to column 17)",
                                                      " (in 'foundation', line 431, column 8 to column 19)",
                                                      " (in 'foundation', line 432, column 8 to column 19)",
                                                      " (in 'foundation', line 433, column 18 to column 21)",
                                                      " (in 'foundation', line 434, column 18 to column 21)",
                                                      " (in 'foundation', line 435, column 8 to column 19)",
                                                      " (in 'foundation', line 436, column 9 to column 12)",
                                                      " (in 'foundation', line 438, column 9 to column 48)",
                                                      " (in 'foundation', line 439, column 8 to column 19)",
                                                      " (in 'foundation', line 440, column 8 to column 19)",
                                                      " (in 'foundation', line 441, column 8 to column 19)",
                                                      " (in 'foundation', line 442, column 8 to column 19)",
                                                      " (in 'foundation', line 446, column 9 to column 12)",
                                                      " (in 'foundation', line 447, column 9 to column 15)",
                                                      " (in 'foundation', line 448, column 8 to column 18)",
                                                      " (in 'foundation', line 449, column 8 to column 17)",
                                                      " (in 'foundation', line 451, column 9 to column 14)",
                                                      " (in 'foundation', line 452, column 8 to column 14)",
                                                      " (in 'foundation', line 454, column 8 to column 13)",
                                                      " (in 'foundation', line 454, column 55 to column 56)",
                                                      " (in 'foundation', line 456, column 11 to column 16)",
                                                      " (in 'foundation', line 457, column 18 to column 23)",
                                                      " (in 'foundation', line 458, column 61 to column 83)",
                                                      " (in 'foundation', line 459, column 18 to column 40)",
                                                      " (in 'foundation', line 463, column 9 to column 12)",
                                                      " (in 'foundation', line 464, column 9 to column 20)",
                                                      " (in 'foundation', line 465, column 8 to column 19)",
                                                      " (in 'foundation', line 467, column 9 to column 21)",
                                                      " (in 'foundation', line 468, column 9 to column 25)",
                                                      " (in 'foundation', line 470, column 9 to column 25)",
                                                      " (in 'foundation', line 472, column 9 to column 10)",
                                                      " (in 'foundation', line 472, column 12 to column 18)",
                                                      " (in 'foundation', line 473, column 9 to column 10)",
                                                      " (in 'foundation', line 660, column 9 to column 33)",
                                                      " (in 'foundation', line 17, column 2 to column 74)",
                                                      " (in 'foundation', line 18, column 2 to column 35)",
                                                      " (in 'foundation', line 19, column 9 to column 12)",
                                                      " (in 'foundation', line 19, column 2 to column 54)",
                                                      " (in 'foundation', line 20, column 9 to column 12)",
                                                      " (in 'foundation', line 20, column 2 to column 98)",
                                                      " (in 'foundation', line 21, column 2 to column 33)",
                                                      " (in 'foundation', line 16, column 23 to line 22, column 1)",
                                                      " (in 'foundation', line 49, column 9 to column 10)",
                                                      " (in 'foundation', line 49, column 2 to column 23)",
                                                      " (in 'foundation', line 50, column 2 to column 25)",
                                                      " (in 'foundation', line 51, column 9 to column 26)",
                                                      " (in 'foundation', line 51, column 2 to column 41)",
                                                      " (in 'foundation', line 52, column 9 to column 10)",
                                                      " (in 'foundation', line 52, column 2 to column 20)",
                                                      " (in 'foundation', line 53, column 2 to column 11)",
                                                      " (in 'foundation', line 54, column 2 to column 66)",
                                                      " (in 'foundation', line 55, column 2 to column 33)",
                                                      " (in 'foundation', line 56, column 2 to column 69)",
                                                      " (in 'foundation', line 57, column 2 to column 32)",
                                                      " (in 'foundation', line 58, column 2 to column 51)",
                                                      " (in 'foundation', line 48, column 15 to line 59, column 2)",
                                                      " (in 'foundation', line 83, column 9 to column 10)",
                                                      " (in 'foundation', line 83, column 2 to column 23)",
                                                      " (in 'foundation', line 84, column 9 to column 26)",
                                                      " (in 'foundation', line 84, column 2 to column 41)",
                                                      " (in 'foundation', line 85, column 9 to column 10)",
                                                      " (in 'foundation', line 85, column 2 to column 45)",
                                                      " (in 'foundation', line 86, column 9 to column 10)",
                                                      " (in 'foundation', line 86, column 2 to column 20)",
                                                      " (in 'foundation', line 87, column 9 to column 10)",
                                                      " (in 'foundation', line 87, column 2 to column 24)",
                                                      " (in 'foundation', line 88, column 2 to column 33)",
                                                      " (in 'foundation', line 89, column 2 to column 67)",
                                                      " (in 'foundation', line 90, column 17 to column 57)",
                                                      " (in 'foundation', line 90, column 2 to column 57)",
                                                      " (in 'foundation', line 91, column 2 to line 97, column 4)",
                                                      " (in 'foundation', line 82, column 14 to line 98, column 1)",
                                                      " (in 'foundation', line 122, column 9 to column 10)",
                                                      " (in 'foundation', line 122, column 2 to column 23)",
                                                      " (in 'foundation', line 123, column 2 to column 12)",
                                                      " (in 'foundation', line 124, column 2 to column 12)",
                                                      " (in 'foundation', line 125, column 9 to column 10)",
                                                      " (in 'foundation', line 125, column 2 to column 24)",
                                                      " (in 'foundation', line 126, column 2 to column 27)",
                                                      " (in 'foundation', line 127, column 2 to column 62)",
                                                      " (in 'foundation', line 128, column 17 to column 57)",
                                                      " (in 'foundation', line 128, column 2 to column 57)",
                                                      " (in 'foundation', line 129, column 2 to line 134, column 39)",
                                                      " (in 'foundation', line 121, column 15 to line 135, column 1)",
                                                      " (in 'foundation', line 149, column 4 to column 102)",
                                                      " (in 'foundation', line 148, column 9 to line 150, column 7)",
                                                      " (in 'foundation', line 147, column 4 to column 97)",
                                                      " (in 'foundation', line 146, column 12 to line 148, column 3)",
                                                      " (in 'foundation', line 146, column 2 to line 150, column 7)",
                                                      " (in 'foundation', line 145, column 25 to line 151, column 1)",
                                                      " (in 'foundation', line 171, column 2 to column 10)",
                                                      " (in 'foundation', line 172, column 2 to column 12)",
                                                      " (in 'foundation', line 173, column 2 to column 48)",
                                                      " (in 'foundation', line 188, column 4 to column 88)",
                                                      " (in 'foundation', line 186, column 13 to line 189, column 7)",
                                                      " (in 'foundation', line 185, column 4 to column 99)",
                                                      " (in 'foundation', line 183, column 29 to line 186, column 7)",
                                                      " (in 'foundation', line 183, column 6 to line 189, column 7)",
                                                      " (in 'foundation', line 190, column 6 to column 27)",
                                                      " (in 'foundation', line 182, column 19 to line 191, column 5)",
                                                      " (in 'foundation', line 182, column 4 to line 191, column 5)",
                                                      " (in 'foundation', line 180, column 9 to line 192, column 3)",
                                                      " (in 'foundation', line 177, column 6 to column 101)",
                                                      " (in 'foundation', line 178, column 6 to column 27)",
                                                      " (in 'foundation', line 175, column 19 to line 179, column 5)",
                                                      " (in 'foundation', line 175, column 4 to line 179, column 5)",
                                                      " (in 'foundation', line 174, column 17 to line 180, column 3)",
                                                      " (in 'foundation', line 174, column 2 to line 192, column 3)",
                                                      " (in 'foundation', line 193, column 2 to column 12)",
                                                      " (in 'foundation', line 170, column 29 to line 194, column 1)",
                                                      " (in 'foundation', line 216, column 9 to column 10)",
                                                      " (in 'foundation', line 216, column 2 to column 16)",
                                                      " (in 'foundation', line 217, column 2 to column 12)",
                                                      " (in 'foundation', line 219, column 4 to column 155)",
                                                      " (in 'foundation', line 220, column 4 to column 25)",
                                                      " (in 'foundation', line 218, column 17 to line 221, column 3)",
                                                      " (in 'foundation', line 218, column 2 to line 221, column 3)",
                                                      " (in 'foundation', line 222, column 2 to column 13)",
                                                      " (in 'foundation', line 215, column 16 to line 223, column 1)",
                                                      " (in 'foundation', line 240, column 9 to column 10)",
                                                      " (in 'foundation', line 240, column 2 to column 24)",
                                                      " (in 'foundation', line 241, column 2 to column 12)",
                                                      " (in 'foundation', line 246, column 4 to line 247, column 102)",
                                                      " (in 'foundation', line 245, column 11 to line 248, column 3)",
                                                      " (in 'foundation', line 244, column 8 to column 112)",
                                                      " (in 'foundation', line 243, column 29 to line 245, column 5)",
                                                      " (in 'foundation', line 243, column 5 to line 248, column 3)",
                                                      " (in 'foundation', line 249, column 6 to column 27)",
                                                      " (in 'foundation', line 242, column 17 to line 250, column 3)",
                                                      " (in 'foundation', line 242, column 2 to line 250, column 3)",
                                                      " (in 'foundation', line 251, column 2 to column 21)",
                                                      " (in 'foundation', line 239, column 16 to line 252, column 1)",
                                                      " (in 'foundation', line 275, column 9 to column 10)",
                                                      " (in 'foundation', line 275, column 2 to column 24)",
                                                      " (in 'foundation', line 276, column 2 to column 12)",
                                                      " (in 'foundation', line 281, column 4 to line 284, column 8)",
                                                      " (in 'foundation', line 280, column 11 to line 285, column 3)",
                                                      " (in 'foundation', line 279, column 8 to column 134)",
                                                      " (in 'foundation', line 278, column 28 to line 280, column 5)",
                                                      " (in 'foundation', line 278, column 4 to line 285, column 3)",
                                                      " (in 'foundation', line 286, column 2 to column 23)",
                                                      " (in 'foundation', line 277, column 17 to line 287, column 3)",
                                                      " (in 'foundation', line 277, column 2 to line 287, column 3)",
                                                      " (in 'foundation', line 288, column 2 to column 21)",
                                                      " (in 'foundation', line 274, column 10 to line 289, column 1)"};
template <typename T1__, typename T2__, typename T3__, typename T4__,
typename T5__, typename T6__, typename T7__, typename T8__, typename T9__>
Eigen::Matrix<stan::promote_args_t<stan::value_type_t<T1__>, T2__, T3__,
stan::value_type_t<T4__>,
stan::value_type_t<T5__>, stan::promote_args_t<T6__, T7__, T8__,
T9__>>, -1, 1>
rhs_prior(const int& dev, const T1__& z_arg__, const T2__& aux1_global,
          const T3__& aux2_global, const T4__& aux1_local_arg__,
          const T5__& aux2_local_arg__, const T6__& caux,
          const T7__& scale_global, const T8__& slab_scale,
          const T9__& error_scale, std::ostream* pstream__) {
  using local_scalar_t__ = stan::promote_args_t<stan::value_type_t<T1__>,
          T2__,
          T3__,
          stan::value_type_t<T4__>,
          stan::value_type_t<T5__>, stan::promote_args_t<T6__,
          T7__,
          T8__,
          T9__>>;
  const auto& z = to_ref(z_arg__);
  const auto& aux1_local = to_ref(aux1_local_arg__);
  const auto& aux2_local = to_ref(aux2_local_arg__);
  const static bool propto__ = true;
  (void) propto__;
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  (void) DUMMY_VAR__;  // suppress unused var warning
  
  try {
    local_scalar_t__ tau;
    tau = DUMMY_VAR__;
    
    current_statement__ = 416;
    tau = (((aux1_global * stan::math::sqrt(aux2_global)) * scale_global) *
            error_scale);
    local_scalar_t__ c;
    c = DUMMY_VAR__;
    
    current_statement__ = 417;
    c = (slab_scale * stan::math::sqrt(caux));
    current_statement__ = 418;
    validate_non_negative_index("lambda", "dev", dev);
    Eigen::Matrix<local_scalar_t__, -1, 1> lambda;
    lambda = Eigen::Matrix<local_scalar_t__, -1, 1>(dev);
    stan::math::fill(lambda, DUMMY_VAR__);
    
    current_statement__ = 419;
    assign(lambda, nil_index_list(),
      elt_multiply(aux1_local, stan::math::sqrt(aux2_local)),
      "assigning variable lambda");
    current_statement__ = 420;
    validate_non_negative_index("lambda_tilde", "dev", dev);
    Eigen::Matrix<local_scalar_t__, -1, 1> lambda_tilde;
    lambda_tilde = Eigen::Matrix<local_scalar_t__, -1, 1>(dev);
    stan::math::fill(lambda_tilde, DUMMY_VAR__);
    
    current_statement__ = 421;
    assign(lambda_tilde, nil_index_list(),
      stan::math::sqrt(
        elt_divide(multiply(pow(c, 2), square(lambda)),
          add(pow(c, 2), multiply(square(tau), square(lambda))))),
      "assigning variable lambda_tilde");
    current_statement__ = 422;
    return multiply(elt_multiply(z, lambda_tilde), tau);
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
  }
  
}
struct rhs_prior_functor__ {
template <typename T1__, typename T2__, typename T3__, typename T4__,
typename T5__, typename T6__, typename T7__, typename T8__, typename T9__>
Eigen::Matrix<stan::promote_args_t<stan::value_type_t<T1__>, T2__, T3__,
stan::value_type_t<T4__>,
stan::value_type_t<T5__>, stan::promote_args_t<T6__, T7__, T8__,
T9__>>, -1, 1>
operator()(const int& dev, const T1__& z, const T2__& aux1_global,
           const T3__& aux2_global, const T4__& aux1_local,
           const T5__& aux2_local, const T6__& caux,
           const T7__& scale_global, const T8__& slab_scale,
           const T9__& error_scale, std::ostream* pstream__)  const 
{
return rhs_prior(dev, z, aux1_global, aux2_global, aux1_local, aux2_local,
         caux, scale_global, slab_scale, error_scale, pstream__);
}
};
template <bool propto__, typename T0__, typename T1__, typename T2__,
typename T3__, typename T4__, typename T8__>
stan::promote_args_t<stan::value_type_t<T0__>, stan::value_type_t<T1__>,
T2__, T3__,
stan::value_type_t<T4__>, stan::promote_args_t<stan::value_type_t<T8__>>>
sar_normal_lpdf(const T0__& y_arg__, const T1__& mu_arg__, const T2__& sigma,
                const T3__& rho, const T4__& ImW_arg__,
                const std::vector<int>& ImW_v, const std::vector<int>& ImW_u,
                const std::vector<int>& Widx, const T8__& lambda_arg__,
                const int& n, std::ostream* pstream__) {
  using local_scalar_t__ = stan::promote_args_t<stan::value_type_t<T0__>,
          stan::value_type_t<T1__>,
          T2__,
          T3__,
          stan::value_type_t<T4__>, stan::promote_args_t<stan::value_type_t<T8__>>>;
  const auto& y = to_ref(y_arg__);
  const auto& mu = to_ref(mu_arg__);
  const auto& ImW = to_ref(ImW_arg__);
  const auto& lambda = to_ref(lambda_arg__);
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  (void) DUMMY_VAR__;  // suppress unused var warning
  
  try {
    current_statement__ = 424;
    validate_non_negative_index("z", "n", n);
    Eigen::Matrix<local_scalar_t__, -1, 1> z;
    z = Eigen::Matrix<local_scalar_t__, -1, 1>(n);
    stan::math::fill(z, DUMMY_VAR__);
    
    current_statement__ = 425;
    assign(z, nil_index_list(), subtract(y, mu), "assigning variable z");
    local_scalar_t__ tau;
    tau = DUMMY_VAR__;
    
    current_statement__ = 426;
    tau = (1 / pow(sigma, 2));
    current_statement__ = 427;
    validate_non_negative_index("ImrhoW", "num_elements(ImW)",
                                num_elements(ImW));
    Eigen::Matrix<local_scalar_t__, -1, 1> ImrhoW;
    ImrhoW = Eigen::Matrix<local_scalar_t__, -1, 1>(num_elements(ImW));
    stan::math::fill(ImrhoW, DUMMY_VAR__);
    
    current_statement__ = 428;
    assign(ImrhoW, nil_index_list(), ImW, "assigning variable ImrhoW");
    current_statement__ = 429;
    validate_non_negative_index("ImrhoWz", "n", n);
    Eigen::Matrix<local_scalar_t__, -1, 1> ImrhoWz;
    ImrhoWz = Eigen::Matrix<local_scalar_t__, -1, 1>(n);
    stan::math::fill(ImrhoWz, DUMMY_VAR__);
    
    local_scalar_t__ zVz;
    zVz = DUMMY_VAR__;
    
    local_scalar_t__ ldet_V;
    ldet_V = DUMMY_VAR__;
    
    current_statement__ = 432;
    ldet_V = ((2 * sum(log1m(multiply(rho, lambda)))) -
               ((2 * n) * stan::math::log(sigma)));
    current_statement__ = 433;
    assign(ImrhoW, cons_list(index_multi(Widx), nil_index_list()),
      multiply(rho,
        rvalue(ImW, cons_list(index_multi(Widx), nil_index_list()), "ImW")),
      "assigning variable ImrhoW");
    current_statement__ = 434;
    assign(ImrhoWz, nil_index_list(),
      csr_matrix_times_vector(n, n, ImrhoW, ImW_v, ImW_u, z),
      "assigning variable ImrhoWz");
    current_statement__ = 435;
    zVz = (tau * dot_self(ImrhoWz));
    current_statement__ = 436;
    return (0.5 *
             (((-n * stan::math::log((2 * stan::math::pi()))) + ldet_V) -
               zVz));
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
  }
  
}
struct sar_normal_lpdf_functor__ {
template <bool propto__, typename T0__, typename T1__, typename T2__,
typename T3__, typename T4__, typename T8__>
stan::promote_args_t<stan::value_type_t<T0__>, stan::value_type_t<T1__>,
T2__, T3__,
stan::value_type_t<T4__>, stan::promote_args_t<stan::value_type_t<T8__>>>
operator()(const T0__& y, const T1__& mu, const T2__& sigma, const T3__& rho,
           const T4__& ImW, const std::vector<int>& ImW_v,
           const std::vector<int>& ImW_u, const std::vector<int>& Widx,
           const T8__& lambda, const int& n, std::ostream* pstream__)  const 
{
return sar_normal_lpdf<propto__>(y, mu, sigma, rho, ImW, ImW_v, ImW_u, Widx,
         lambda, n, pstream__);
}
};
template <bool propto__, typename T0__, typename T1__, typename T2__,
typename T3__, typename T4__, typename T8__, typename T9__, typename T10__>
stan::promote_args_t<stan::value_type_t<T0__>, stan::value_type_t<T1__>,
T2__, T3__,
stan::value_type_t<T4__>, stan::promote_args_t<stan::value_type_t<T8__>,
T9__,
stan::value_type_t<T10__>>>
car_normal_lpdf(const T0__& y_arg__, const T1__& mu_arg__, const T2__& tau,
                const T3__& rho, const T4__& ImC_arg__,
                const std::vector<int>& ImC_v, const std::vector<int>& ImC_u,
                const std::vector<int>& Cidx, const T8__& D_inv_arg__,
                const T9__& log_det_D_inv, const T10__& lambda_arg__,
                const int& n, std::ostream* pstream__) {
  using local_scalar_t__ = stan::promote_args_t<stan::value_type_t<T0__>,
          stan::value_type_t<T1__>,
          T2__,
          T3__,
          stan::value_type_t<T4__>, stan::promote_args_t<stan::value_type_t<T8__>,
          T9__,
          stan::value_type_t<T10__>>>;
  const auto& y = to_ref(y_arg__);
  const auto& mu = to_ref(mu_arg__);
  const auto& ImC = to_ref(ImC_arg__);
  const auto& D_inv = to_ref(D_inv_arg__);
  const auto& lambda = to_ref(lambda_arg__);
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  (void) DUMMY_VAR__;  // suppress unused var warning
  
  try {
    current_statement__ = 438;
    validate_non_negative_index("z", "n", n);
    Eigen::Matrix<local_scalar_t__, -1, 1> z;
    z = Eigen::Matrix<local_scalar_t__, -1, 1>(n);
    stan::math::fill(z, DUMMY_VAR__);
    
    current_statement__ = 439;
    assign(z, nil_index_list(), subtract(y, mu), "assigning variable z");
    current_statement__ = 440;
    validate_non_negative_index("ImrhoC", "num_elements(ImC)",
                                num_elements(ImC));
    Eigen::Matrix<local_scalar_t__, -1, 1> ImrhoC;
    ImrhoC = Eigen::Matrix<local_scalar_t__, -1, 1>(num_elements(ImC));
    stan::math::fill(ImrhoC, DUMMY_VAR__);
    
    current_statement__ = 441;
    assign(ImrhoC, nil_index_list(), ImC, "assigning variable ImrhoC");
    current_statement__ = 442;
    validate_non_negative_index("zMinv", "n", n);
    Eigen::Matrix<local_scalar_t__, -1, 1> zMinv;
    zMinv = Eigen::Matrix<local_scalar_t__, -1, 1>(n);
    stan::math::fill(zMinv, DUMMY_VAR__);
    
    current_statement__ = 443;
    assign(zMinv, nil_index_list(),
      elt_multiply(multiply((1 / pow(tau, 2)), z), D_inv),
      "assigning variable zMinv");
    current_statement__ = 444;
    validate_non_negative_index("ImrhoCz", "n", n);
    Eigen::Matrix<local_scalar_t__, -1, 1> ImrhoCz;
    ImrhoCz = Eigen::Matrix<local_scalar_t__, -1, 1>(n);
    stan::math::fill(ImrhoCz, DUMMY_VAR__);
    
    current_statement__ = 446;
    validate_non_negative_index("ldet_ImrhoC", "n", n);
    Eigen::Matrix<local_scalar_t__, -1, 1> ldet_ImrhoC;
    ldet_ImrhoC = Eigen::Matrix<local_scalar_t__, -1, 1>(n);
    stan::math::fill(ldet_ImrhoC, DUMMY_VAR__);
    
    current_statement__ = 448;
    assign(ImrhoC, cons_list(index_multi(Cidx), nil_index_list()),
      multiply(rho,
        rvalue(ImC, cons_list(index_multi(Cidx), nil_index_list()), "ImC")),
      "assigning variable ImrhoC");
    current_statement__ = 449;
    assign(ImrhoCz, nil_index_list(),
      csr_matrix_times_vector(n, n, ImrhoC, ImC_v, ImC_u, z),
      "assigning variable ImrhoCz");
    current_statement__ = 451;
    for (int i = 1; i <= n; ++i) {
      current_statement__ = 450;
      assign(ldet_ImrhoC, cons_list(index_uni(i), nil_index_list()),
        log1m((rho * lambda[(i - 1)])), "assigning variable ldet_ImrhoC");}
    current_statement__ = 452;
    return (0.5 *
             (((((-n * stan::math::log((2 * stan::math::pi()))) -
                  ((2 * n) * stan::math::log(tau))) + log_det_D_inv) +
                sum(ldet_ImrhoC)) - dot_product(zMinv, ImrhoCz)));
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
  }
  
}
struct car_normal_lpdf_functor__ {
template <bool propto__, typename T0__, typename T1__, typename T2__,
typename T3__, typename T4__, typename T8__, typename T9__, typename T10__>
stan::promote_args_t<stan::value_type_t<T0__>, stan::value_type_t<T1__>,
T2__, T3__,
stan::value_type_t<T4__>, stan::promote_args_t<stan::value_type_t<T8__>,
T9__,
stan::value_type_t<T10__>>>
operator()(const T0__& y, const T1__& mu, const T2__& tau, const T3__& rho,
           const T4__& ImC, const std::vector<int>& ImC_v,
           const std::vector<int>& ImC_u, const std::vector<int>& Cidx,
           const T8__& D_inv, const T9__& log_det_D_inv, const T10__& lambda,
           const int& n, std::ostream* pstream__)  const 
{
return car_normal_lpdf<propto__>(y, mu, tau, rho, ImC, ImC_v, ImC_u, Cidx,
         D_inv, log_det_D_inv, lambda, n, pstream__);
}
};
template <bool propto__, typename T0__, typename T1__, typename T2__,
typename T3__, typename T4__, typename T7__, typename T8__, typename T9__>
stan::promote_args_t<stan::value_type_t<T0__>, stan::value_type_t<T1__>,
T2__, T3__,
stan::value_type_t<T4__>, stan::promote_args_t<stan::value_type_t<T7__>,
T8__,
stan::value_type_t<T9__>>>
wcar_normal_lpdf(const T0__& y_arg__, const T1__& mu_arg__, const T2__& tau,
                 const T3__& rho, const T4__& A_w_arg__,
                 const std::vector<int>& A_v, const std::vector<int>& A_u,
                 const T7__& D_inv_arg__, const T8__& log_det_D_inv,
                 const T9__& lambda_arg__, const int& n,
                 std::ostream* pstream__) {
  using local_scalar_t__ = stan::promote_args_t<stan::value_type_t<T0__>,
          stan::value_type_t<T1__>,
          T2__,
          T3__,
          stan::value_type_t<T4__>, stan::promote_args_t<stan::value_type_t<T7__>,
          T8__,
          stan::value_type_t<T9__>>>;
  const auto& y = to_ref(y_arg__);
  const auto& mu = to_ref(mu_arg__);
  const auto& A_w = to_ref(A_w_arg__);
  const auto& D_inv = to_ref(D_inv_arg__);
  const auto& lambda = to_ref(lambda_arg__);
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  (void) DUMMY_VAR__;  // suppress unused var warning
  
  try {
    current_statement__ = 454;
    validate_non_negative_index("z", "n", n);
    Eigen::Matrix<local_scalar_t__, -1, 1> z;
    z = Eigen::Matrix<local_scalar_t__, -1, 1>(n);
    stan::math::fill(z, DUMMY_VAR__);
    
    current_statement__ = 455;
    assign(z, nil_index_list(), subtract(y, mu), "assigning variable z");
    local_scalar_t__ ztDz;
    ztDz = DUMMY_VAR__;
    
    local_scalar_t__ ztAz;
    ztAz = DUMMY_VAR__;
    
    current_statement__ = 458;
    validate_non_negative_index("ldet_ImrhoC", "n", n);
    Eigen::Matrix<local_scalar_t__, -1, 1> ldet_ImrhoC;
    ldet_ImrhoC = Eigen::Matrix<local_scalar_t__, -1, 1>(n);
    stan::math::fill(ldet_ImrhoC, DUMMY_VAR__);
    
    current_statement__ = 460;
    ztDz = multiply(transpose(elt_multiply(z, D_inv)), z);
    current_statement__ = 461;
    ztAz = multiply(transpose(z),
             csr_matrix_times_vector(n, n, A_w, A_v, A_u, z));
    current_statement__ = 463;
    for (int i = 1; i <= n; ++i) {
      current_statement__ = 462;
      assign(ldet_ImrhoC, cons_list(index_uni(i), nil_index_list()),
        log1m((rho * lambda[(i - 1)])), "assigning variable ldet_ImrhoC");}
    current_statement__ = 464;
    return (0.5 *
             (((((-n * stan::math::log((2 * stan::math::pi()))) -
                  ((2 * n) * stan::math::log(tau))) + log_det_D_inv) +
                sum(ldet_ImrhoC)) -
               ((1 / pow(tau, 2)) * (ztDz - (rho * ztAz)))));
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
  }
  
}
struct wcar_normal_lpdf_functor__ {
template <bool propto__, typename T0__, typename T1__, typename T2__,
typename T3__, typename T4__, typename T7__, typename T8__, typename T9__>
stan::promote_args_t<stan::value_type_t<T0__>, stan::value_type_t<T1__>,
T2__, T3__,
stan::value_type_t<T4__>, stan::promote_args_t<stan::value_type_t<T7__>,
T8__,
stan::value_type_t<T9__>>>
operator()(const T0__& y, const T1__& mu, const T2__& tau, const T3__& rho,
           const T4__& A_w, const std::vector<int>& A_v,
           const std::vector<int>& A_u, const T7__& D_inv,
           const T8__& log_det_D_inv, const T9__& lambda, const int& n,
           std::ostream* pstream__)  const 
{
return wcar_normal_lpdf<propto__>(y, mu, tau, rho, A_w, A_v, A_u, D_inv,
         log_det_D_inv, lambda, n, pstream__);
}
};
template <bool propto__, typename T0__, typename T1__, typename T2__,
typename T3__, typename T4__, typename T8__, typename T9__, typename T10__>
stan::promote_args_t<stan::value_type_t<T0__>, stan::value_type_t<T1__>,
T2__, T3__,
stan::value_type_t<T4__>, stan::promote_args_t<stan::value_type_t<T8__>,
T9__,
stan::value_type_t<T10__>>>
auto_normal_lpdf(const T0__& y_arg__, const T1__& mu_arg__, const T2__& tau,
                 const T3__& rho, const T4__& Ax_w_arg__,
                 const std::vector<int>& Ax_v, const std::vector<int>& Ax_u,
                 const std::vector<int>& Cidx, const T8__& D_inv_arg__,
                 const T9__& log_det_D_inv, const T10__& lambda_arg__,
                 const int& n, const int& WCAR, std::ostream* pstream__) {
  using local_scalar_t__ = stan::promote_args_t<stan::value_type_t<T0__>,
          stan::value_type_t<T1__>,
          T2__,
          T3__,
          stan::value_type_t<T4__>, stan::promote_args_t<stan::value_type_t<T8__>,
          T9__,
          stan::value_type_t<T10__>>>;
  const auto& y = to_ref(y_arg__);
  const auto& mu = to_ref(mu_arg__);
  const auto& Ax_w = to_ref(Ax_w_arg__);
  const auto& D_inv = to_ref(D_inv_arg__);
  const auto& lambda = to_ref(lambda_arg__);
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  (void) DUMMY_VAR__;  // suppress unused var warning
  
  try {
    current_statement__ = 470;
    if (WCAR) {
      current_statement__ = 468;
      return wcar_normal_lpdf<false>(y, mu, tau, rho, Ax_w, Ax_v, Ax_u,
               D_inv, log_det_D_inv, lambda, n, pstream__);
    } else {
      current_statement__ = 466;
      return car_normal_lpdf<false>(y, mu, tau, rho, Ax_w, Ax_v, Ax_u, Cidx,
               D_inv, log_det_D_inv, lambda, n, pstream__);
    }
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
  }
  
}
struct auto_normal_lpdf_functor__ {
template <bool propto__, typename T0__, typename T1__, typename T2__,
typename T3__, typename T4__, typename T8__, typename T9__, typename T10__>
stan::promote_args_t<stan::value_type_t<T0__>, stan::value_type_t<T1__>,
T2__, T3__,
stan::value_type_t<T4__>, stan::promote_args_t<stan::value_type_t<T8__>,
T9__,
stan::value_type_t<T10__>>>
operator()(const T0__& y, const T1__& mu, const T2__& tau, const T3__& rho,
           const T4__& Ax_w, const std::vector<int>& Ax_v,
           const std::vector<int>& Ax_u, const std::vector<int>& Cidx,
           const T8__& D_inv, const T9__& log_det_D_inv, const T10__& lambda,
           const int& n, const int& WCAR, std::ostream* pstream__)  const 
{
return auto_normal_lpdf<propto__>(y, mu, tau, rho, Ax_w, Ax_v, Ax_u, Cidx,
         D_inv, log_det_D_inv, lambda, n, WCAR, pstream__);
}
};
template <bool propto__, typename T0__, typename T1__>
stan::promote_args_t<stan::value_type_t<T0__>,
T1__>
icar_normal_lpdf(const T0__& phi_arg__, const T1__& spatial_scale,
                 const std::vector<int>& node1,
                 const std::vector<int>& node2, const int& k,
                 const std::vector<int>& group_size,
                 const std::vector<int>& group_idx, const int& has_theta,
                 std::ostream* pstream__) {
  using local_scalar_t__ = stan::promote_args_t<stan::value_type_t<T0__>,
          T1__>;
  const auto& phi = to_ref(phi_arg__);
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  (void) DUMMY_VAR__;  // suppress unused var warning
  
  try {
    local_scalar_t__ lp;
    lp = DUMMY_VAR__;
    
    int pos;
    pos = std::numeric_limits<int>::min();
    
    current_statement__ = 473;
    pos = 1;
    current_statement__ = 474;
    lp = (-0.5 *
           dot_self(
             subtract(
               rvalue(phi, cons_list(index_multi(node1), nil_index_list()),
                 "phi"),
               rvalue(phi, cons_list(index_multi(node2), nil_index_list()),
                 "phi"))));
    current_statement__ = 489;
    if (has_theta) {
      current_statement__ = 487;
      for (int j = 1; j <= k; ++j) {
        current_statement__ = 484;
        lp = (lp +
               normal_lpdf<false>(
                 sum(
                   rvalue(phi,
                     cons_list(
                       index_multi(segment(group_idx, pos,
                                     group_size[(j - 1)])), nil_index_list()),
                     "phi")), 0, (0.001 * group_size[(j - 1)])));
        current_statement__ = 485;
        pos = (pos + group_size[(j - 1)]);}
    } else {
      current_statement__ = 482;
      for (int j = 1; j <= k; ++j) {
        current_statement__ = 479;
        if (logical_gt(group_size[(j - 1)], 1)) {
          current_statement__ = 477;
          lp = (lp +
                 normal_lpdf<false>(
                   sum(
                     rvalue(phi,
                       cons_list(
                         index_multi(segment(group_idx, pos,
                                       group_size[(j - 1)])),
                         nil_index_list()), "phi")), 0,
                   (0.001 * group_size[(j - 1)])));
        } else {
          current_statement__ = 475;
          lp = (lp +
                 normal_lpdf<false>(
                   rvalue(phi,
                     cons_list(
                       index_multi(segment(group_idx, pos,
                                     group_size[(j - 1)])), nil_index_list()),
                     "phi"), 0, spatial_scale));
        }
        current_statement__ = 480;
        pos = (pos + group_size[(j - 1)]);}
    }
    current_statement__ = 490;
    return lp;
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
  }
  
}
struct icar_normal_lpdf_functor__ {
template <bool propto__, typename T0__, typename T1__>
stan::promote_args_t<stan::value_type_t<T0__>,
T1__>
operator()(const T0__& phi, const T1__& spatial_scale,
           const std::vector<int>& node1, const std::vector<int>& node2,
           const int& k, const std::vector<int>& group_size,
           const std::vector<int>& group_idx, const int& has_theta,
           std::ostream* pstream__)  const 
{
return icar_normal_lpdf<propto__>(phi, spatial_scale, node1, node2, k,
         group_size, group_idx, has_theta, pstream__);
}
};
template <typename T0__, typename T1__, typename T2__, typename T3__>
Eigen::Matrix<stan::promote_args_t<stan::value_type_t<T0__>, T1__, T2__,
stan::value_type_t<T3__>>, -1, 1>
make_phi(const T0__& phi_tilde_arg__, const T1__& phi_scale, const T2__& rho,
         const T3__& inv_sqrt_scale_factor_arg__, const int& n, const int& k,
         const std::vector<int>& group_size,
         const std::vector<int>& group_idx, std::ostream* pstream__) {
  using local_scalar_t__ = stan::promote_args_t<stan::value_type_t<T0__>,
          T1__,
          T2__,
          stan::value_type_t<T3__>>;
  const auto& phi_tilde = to_ref(phi_tilde_arg__);
  const auto& inv_sqrt_scale_factor = to_ref(inv_sqrt_scale_factor_arg__);
  const static bool propto__ = true;
  (void) propto__;
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  (void) DUMMY_VAR__;  // suppress unused var warning
  
  try {
    current_statement__ = 492;
    validate_non_negative_index("phi", "n", n);
    Eigen::Matrix<local_scalar_t__, -1, 1> phi;
    phi = Eigen::Matrix<local_scalar_t__, -1, 1>(n);
    stan::math::fill(phi, DUMMY_VAR__);
    
    int pos;
    pos = std::numeric_limits<int>::min();
    
    current_statement__ = 494;
    pos = 1;
    current_statement__ = 498;
    for (int j = 1; j <= k; ++j) {
      current_statement__ = 495;
      assign(phi,
        cons_list(index_multi(segment(group_idx, pos, group_size[(j - 1)])),
          nil_index_list()),
        multiply(
          ((phi_scale * stan::math::sqrt(rho)) *
            inv_sqrt_scale_factor[(j - 1)]),
          rvalue(phi_tilde,
            cons_list(
              index_multi(segment(group_idx, pos, group_size[(j - 1)])),
              nil_index_list()), "phi_tilde")), "assigning variable phi");
      current_statement__ = 496;
      pos = (pos + group_size[(j - 1)]);}
    current_statement__ = 499;
    return phi;
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
  }
  
}
struct make_phi_functor__ {
template <typename T0__, typename T1__, typename T2__, typename T3__>
Eigen::Matrix<stan::promote_args_t<stan::value_type_t<T0__>, T1__, T2__,
stan::value_type_t<T3__>>, -1, 1>
operator()(const T0__& phi_tilde, const T1__& phi_scale, const T2__& rho,
           const T3__& inv_sqrt_scale_factor, const int& n, const int& k,
           const std::vector<int>& group_size,
           const std::vector<int>& group_idx, std::ostream* pstream__)  const 
{
return make_phi(phi_tilde, phi_scale, rho, inv_sqrt_scale_factor, n, k,
         group_size, group_idx, pstream__);
}
};
template <typename T0__, typename T1__>
Eigen::Matrix<stan::promote_args_t<stan::value_type_t<T0__>,
stan::value_type_t<T1__>>, -1, 1>
convolve_bym(const T0__& phi_arg__, const T1__& theta_arg__, const int& n,
             const int& k, const std::vector<int>& group_size,
             const std::vector<int>& group_idx, std::ostream* pstream__) {
  using local_scalar_t__ = stan::promote_args_t<stan::value_type_t<T0__>,
          stan::value_type_t<T1__>>;
  const auto& phi = to_ref(phi_arg__);
  const auto& theta = to_ref(theta_arg__);
  const static bool propto__ = true;
  (void) propto__;
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  (void) DUMMY_VAR__;  // suppress unused var warning
  
  try {
    current_statement__ = 501;
    validate_non_negative_index("convolution", "n", n);
    Eigen::Matrix<local_scalar_t__, -1, 1> convolution;
    convolution = Eigen::Matrix<local_scalar_t__, -1, 1>(n);
    stan::math::fill(convolution, DUMMY_VAR__);
    
    int pos;
    pos = std::numeric_limits<int>::min();
    
    current_statement__ = 503;
    pos = 1;
    current_statement__ = 511;
    for (int j = 1; j <= k; ++j) {
      current_statement__ = 508;
      if (logical_eq(group_size[(j - 1)], 1)) {
        current_statement__ = 506;
        assign(convolution,
          cons_list(
            index_multi(segment(group_idx, pos, group_size[(j - 1)])),
            nil_index_list()),
          rvalue(theta,
            cons_list(
              index_multi(segment(group_idx, pos, group_size[(j - 1)])),
              nil_index_list()), "theta"), "assigning variable convolution");
      } else {
        current_statement__ = 504;
        assign(convolution,
          cons_list(
            index_multi(segment(group_idx, pos, group_size[(j - 1)])),
            nil_index_list()),
          add(
            rvalue(phi,
              cons_list(
                index_multi(segment(group_idx, pos, group_size[(j - 1)])),
                nil_index_list()), "phi"),
            rvalue(theta,
              cons_list(
                index_multi(segment(group_idx, pos, group_size[(j - 1)])),
                nil_index_list()), "theta")),
          "assigning variable convolution");
      }
      current_statement__ = 509;
      pos = (pos + group_size[(j - 1)]);}
    current_statement__ = 512;
    return convolution;
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
  }
  
}
struct convolve_bym_functor__ {
template <typename T0__, typename T1__>
Eigen::Matrix<stan::promote_args_t<stan::value_type_t<T0__>,
stan::value_type_t<T1__>>, -1, 1>
operator()(const T0__& phi, const T1__& theta, const int& n, const int& k,
           const std::vector<int>& group_size,
           const std::vector<int>& group_idx, std::ostream* pstream__)  const 
{
return convolve_bym(phi, theta, n, k, group_size, group_idx, pstream__);
}
};
template <typename T0__, typename T1__, typename T2__, typename T7__,
typename T8__>
Eigen::Matrix<stan::promote_args_t<stan::value_type_t<T0__>, stan::value_type_t<T1__>,
T2__, T7__,
stan::value_type_t<T8__>>, -1, 1>
convolve_bym2(const T0__& phi_tilde_arg__, const T1__& theta_tilde_arg__,
              const T2__& spatial_scale, const int& n, const int& k,
              const std::vector<int>& group_size,
              const std::vector<int>& group_idx, const T7__& rho,
              const T8__& inv_sqrt_scale_factor_arg__,
              std::ostream* pstream__) {
  using local_scalar_t__ = stan::promote_args_t<stan::value_type_t<T0__>,
          stan::value_type_t<T1__>,
          T2__,
          T7__,
          stan::value_type_t<T8__>>;
  const auto& phi_tilde = to_ref(phi_tilde_arg__);
  const auto& theta_tilde = to_ref(theta_tilde_arg__);
  const auto& inv_sqrt_scale_factor = to_ref(inv_sqrt_scale_factor_arg__);
  const static bool propto__ = true;
  (void) propto__;
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  (void) DUMMY_VAR__;  // suppress unused var warning
  
  try {
    current_statement__ = 514;
    validate_non_negative_index("convolution", "n", n);
    Eigen::Matrix<local_scalar_t__, -1, 1> convolution;
    convolution = Eigen::Matrix<local_scalar_t__, -1, 1>(n);
    stan::math::fill(convolution, DUMMY_VAR__);
    
    int pos;
    pos = std::numeric_limits<int>::min();
    
    current_statement__ = 516;
    pos = 1;
    current_statement__ = 524;
    for (int j = 1; j <= k; ++j) {
      current_statement__ = 521;
      if (logical_eq(group_size[(j - 1)], 1)) {
        current_statement__ = 519;
        assign(convolution,
          cons_list(
            index_multi(segment(group_idx, pos, group_size[(j - 1)])),
            nil_index_list()),
          multiply(spatial_scale,
            rvalue(theta_tilde,
              cons_list(
                index_multi(segment(group_idx, pos, group_size[(j - 1)])),
                nil_index_list()), "theta_tilde")),
          "assigning variable convolution");
      } else {
        current_statement__ = 517;
        assign(convolution,
          cons_list(
            index_multi(segment(group_idx, pos, group_size[(j - 1)])),
            nil_index_list()),
          multiply(spatial_scale,
            add(
              multiply(
                (stan::math::sqrt(rho) * inv_sqrt_scale_factor[(j - 1)]),
                rvalue(phi_tilde,
                  cons_list(
                    index_multi(segment(group_idx, pos, group_size[(j - 1)])),
                    nil_index_list()), "phi_tilde")),
              multiply(stan::math::sqrt((1 - rho)),
                rvalue(theta_tilde,
                  cons_list(
                    index_multi(segment(group_idx, pos, group_size[(j - 1)])),
                    nil_index_list()), "theta_tilde")))),
          "assigning variable convolution");
      }
      current_statement__ = 522;
      pos = (pos + group_size[(j - 1)]);}
    current_statement__ = 525;
    return convolution;
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
  }
  
}
struct convolve_bym2_functor__ {
template <typename T0__, typename T1__, typename T2__, typename T7__,
typename T8__>
Eigen::Matrix<stan::promote_args_t<stan::value_type_t<T0__>, stan::value_type_t<T1__>,
T2__, T7__,
stan::value_type_t<T8__>>, -1, 1>
operator()(const T0__& phi_tilde, const T1__& theta_tilde,
           const T2__& spatial_scale, const int& n, const int& k,
           const std::vector<int>& group_size,
           const std::vector<int>& group_idx, const T7__& rho,
           const T8__& inv_sqrt_scale_factor, std::ostream* pstream__)  const 
{
return convolve_bym2(phi_tilde, theta_tilde, spatial_scale, n, k, group_size,
         group_idx, rho, inv_sqrt_scale_factor, pstream__);
}
};
#include <stan_meta_header.hpp>
class model_foundation final : public model_base_crtp<model_foundation> {
private:
  int family;
  int n;
  int center_x;
  int n_mis;
  int n_obs;
  std::vector<int> y_mis_idx;
  std::vector<int> y_obs_idx;
  int censor_point;
  Eigen::Matrix<double, -1, 1> y;
  std::vector<int> y_int;
  std::vector<int> trials;
  int prior_only;
  Eigen::Matrix<double, -1, 1> input_offset;
  int dwx;
  std::vector<int> wx_idx;
  int dw_nonzero;
  Eigen::Matrix<double, -1, 1> W_w;
  std::vector<int> W_v;
  std::vector<int> W_u;
  std::vector<double> bounds;
  int dx_obs;
  int dx_me;
  std::vector<int> use_logit;
  std::vector<int> x_obs_idx;
  std::vector<int> x_me_idx;
  Eigen::Matrix<double, -1, -1> x_obs;
  std::vector<Eigen::Matrix<double, -1, 1>> x_me;
  std::vector<Eigen::Matrix<double, -1, 1>> sigma_me;
  Eigen::Matrix<double, -1, 1> prior_nux_true_alpha;
  Eigen::Matrix<double, -1, 1> prior_nux_true_beta;
  Eigen::Matrix<double, -1, 1> prior_mux_true_location;
  Eigen::Matrix<double, -1, 1> prior_mux_true_scale;
  Eigen::Matrix<double, -1, 1> prior_sigmax_true_df;
  Eigen::Matrix<double, -1, 1> prior_sigmax_true_location;
  Eigen::Matrix<double, -1, 1> prior_sigmax_true_scale;
  Eigen::Matrix<double, -1, 1> prior_rhox_true;
  int spatial_me;
  int WCAR;
  int nAx_w;
  int nC;
  Eigen::Matrix<double, -1, 1> Ax_w;
  std::vector<int> Ax_v;
  std::vector<int> Ax_u;
  std::vector<int> Cidx;
  Eigen::Matrix<double, -1, 1> Delta_inv;
  double log_det_Delta_inv;
  Eigen::Matrix<double, -1, 1> lambda;
  int has_re;
  int n_ids;
  std::vector<int> id;
  Eigen::Matrix<double, -1, 1> prior_alpha;
  int dbeta_prior;
  Eigen::Matrix<double, -1, 1> prior_beta_location;
  Eigen::Matrix<double, -1, 1> prior_beta_scale;
  Eigen::Matrix<double, -1, 1> prior_alpha_tau;
  Eigen::Matrix<double, -1, 1> prior_t_nu;
  Eigen::Matrix<double, -1, 1> prior_sigma;
  int type;
  int k;
  std::vector<int> group_size;
  std::vector<int> group_idx;
  int m;
  Eigen::Matrix<double, -1, -1> A;
  int n_edges;
  std::vector<int> node1;
  std::vector<int> node2;
  Eigen::Matrix<double, -1, 1> weight;
  std::vector<int> comp_id;
  Eigen::Matrix<double, -1, 1> inv_sqrt_scale_factor;
  int dev;
  Eigen::Matrix<double, -1, -1> EV;
  double global_scale;
  double slab_scale;
  double slab_df;
  std::vector<double> car_rho_lims;
  int car;
  int nImW_w;
  int nW;
  Eigen::Matrix<double, -1, 1> ImW_w;
  std::vector<int> ImW_v;
  std::vector<int> ImW_u;
  std::vector<int> Widx;
  Eigen::Matrix<double, -1, 1> eigenvalues_w;
  std::vector<double> sar_rho_lims;
  int sar;
  int has_theta;
  int is_gaussian;
  int is_student;
  int is_poisson;
  int is_binomial;
  int is_auto_gaussian;
  int has_sigma;
  int has_offset;
  int dx_all;
  int has_me;
  int phi_tilde_1dim__;
  int spatial_scale_1dim__;
  int theta_tilde_1dim__;
  int theta_scale_1dim__;
  int rho_1dim__;
  int aux1_global_1dim__;
  int aux2_global_1dim__;
  int caux_1dim__;
  int log_lambda_1dim__;
  int car_scale_1dim__;
  int car_rho_1dim__;
  int sar_scale_1dim__;
  int sar_rho_1dim__;
  int car_rho_x_true_1dim__;
  int nu_x_true_1dim__;
  int esf_1dim__;
  int error_scale_1dim__;
  int phi_1dim__;
  int theta_1dim__;
  int log_lambda_mu_1dim__;
  int log_lik_1dim__;
 
public:
  ~model_foundation() { }
  
  inline std::string model_name() const final { return "model_foundation"; }
  inline std::vector<std::string> model_compile_info() const noexcept {
    return std::vector<std::string>{"stanc_version = stanc3 v2.26.1-4-gd72b68b7-dirty", "stancflags = "};
  }
  
  
  model_foundation(stan::io::var_context& context__,
                   unsigned int random_seed__ = 0,
                   std::ostream* pstream__ = nullptr) : model_base_crtp(0) {
    using local_scalar_t__ = double ;
    boost::ecuyer1988 base_rng__ = 
        stan::services::util::create_rng(random_seed__, 0);
    (void) base_rng__;  // suppress unused var warning
    static const char* function__ = "model_foundation_namespace::model_foundation";
    (void) function__;  // suppress unused var warning
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    (void) DUMMY_VAR__;  // suppress unused var warning
    
    try {
      int pos__;
      pos__ = std::numeric_limits<int>::min();
      
      pos__ = 1;
      current_statement__ = 222;
      context__.validate_dims("data initialization","family","int",
          context__.to_vec());
      family = std::numeric_limits<int>::min();
      
      current_statement__ = 222;
      family = context__.vals_i("family")[(1 - 1)];
      current_statement__ = 222;
      current_statement__ = 222;
      check_greater_or_equal(function__, "family", family, 0);
      current_statement__ = 222;
      current_statement__ = 222;
      check_less_or_equal(function__, "family", family, 6);
      current_statement__ = 223;
      context__.validate_dims("data initialization","n","int",
          context__.to_vec());
      n = std::numeric_limits<int>::min();
      
      current_statement__ = 223;
      n = context__.vals_i("n")[(1 - 1)];
      current_statement__ = 223;
      current_statement__ = 223;
      check_greater_or_equal(function__, "n", n, 0);
      current_statement__ = 224;
      context__.validate_dims("data initialization","center_x","int",
          context__.to_vec());
      center_x = std::numeric_limits<int>::min();
      
      current_statement__ = 224;
      center_x = context__.vals_i("center_x")[(1 - 1)];
      current_statement__ = 224;
      current_statement__ = 224;
      check_greater_or_equal(function__, "center_x", center_x, 0);
      current_statement__ = 225;
      context__.validate_dims("data initialization","n_mis","int",
          context__.to_vec());
      n_mis = std::numeric_limits<int>::min();
      
      current_statement__ = 225;
      n_mis = context__.vals_i("n_mis")[(1 - 1)];
      current_statement__ = 225;
      current_statement__ = 225;
      check_greater_or_equal(function__, "n_mis", n_mis, 0);
      current_statement__ = 226;
      context__.validate_dims("data initialization","n_obs","int",
          context__.to_vec());
      n_obs = std::numeric_limits<int>::min();
      
      current_statement__ = 226;
      n_obs = context__.vals_i("n_obs")[(1 - 1)];
      current_statement__ = 226;
      current_statement__ = 226;
      check_greater_or_equal(function__, "n_obs", n_obs, 0);
      current_statement__ = 227;
      validate_non_negative_index("y_mis_idx", "n_mis", n_mis);
      current_statement__ = 228;
      context__.validate_dims("data initialization","y_mis_idx","int",
          context__.to_vec(n_mis));
      y_mis_idx = std::vector<int>(n_mis, std::numeric_limits<int>::min());
      
      current_statement__ = 228;
      assign(y_mis_idx, nil_index_list(), context__.vals_i("y_mis_idx"),
        "assigning variable y_mis_idx");
      current_statement__ = 229;
      validate_non_negative_index("y_obs_idx", "n_obs", n_obs);
      current_statement__ = 230;
      context__.validate_dims("data initialization","y_obs_idx","int",
          context__.to_vec(n_obs));
      y_obs_idx = std::vector<int>(n_obs, std::numeric_limits<int>::min());
      
      current_statement__ = 230;
      assign(y_obs_idx, nil_index_list(), context__.vals_i("y_obs_idx"),
        "assigning variable y_obs_idx");
      current_statement__ = 231;
      context__.validate_dims("data initialization","censor_point","int",
          context__.to_vec());
      censor_point = std::numeric_limits<int>::min();
      
      current_statement__ = 231;
      censor_point = context__.vals_i("censor_point")[(1 - 1)];
      current_statement__ = 232;
      validate_non_negative_index("y", "n", n);
      current_statement__ = 233;
      context__.validate_dims("data initialization","y","double",
          context__.to_vec(n));
      y = Eigen::Matrix<double, -1, 1>(n);
      stan::math::fill(y, std::numeric_limits<double>::quiet_NaN());
      
      {
        std::vector<local_scalar_t__> y_flat__;
        current_statement__ = 233;
        assign(y_flat__, nil_index_list(), context__.vals_r("y"),
          "assigning variable y_flat__");
        current_statement__ = 233;
        pos__ = 1;
        current_statement__ = 233;
        for (int sym1__ = 1; sym1__ <= n; ++sym1__) {
          current_statement__ = 233;
          assign(y, cons_list(index_uni(sym1__), nil_index_list()),
            y_flat__[(pos__ - 1)], "assigning variable y");
          current_statement__ = 233;
          pos__ = (pos__ + 1);}
      }
      current_statement__ = 234;
      validate_non_negative_index("y_int", "n", n);
      current_statement__ = 235;
      context__.validate_dims("data initialization","y_int","int",
          context__.to_vec(n));
      y_int = std::vector<int>(n, std::numeric_limits<int>::min());
      
      current_statement__ = 235;
      assign(y_int, nil_index_list(), context__.vals_i("y_int"),
        "assigning variable y_int");
      current_statement__ = 235;
      for (int sym1__ = 1; sym1__ <= n; ++sym1__) {
        current_statement__ = 235;
        current_statement__ = 235;
        check_greater_or_equal(function__, "y_int[sym1__]",
                               y_int[(sym1__ - 1)], 0);}
      current_statement__ = 236;
      validate_non_negative_index("trials", "n", n);
      current_statement__ = 237;
      context__.validate_dims("data initialization","trials","int",
          context__.to_vec(n));
      trials = std::vector<int>(n, std::numeric_limits<int>::min());
      
      current_statement__ = 237;
      assign(trials, nil_index_list(), context__.vals_i("trials"),
        "assigning variable trials");
      current_statement__ = 237;
      for (int sym1__ = 1; sym1__ <= n; ++sym1__) {
        current_statement__ = 237;
        current_statement__ = 237;
        check_greater_or_equal(function__, "trials[sym1__]",
                               trials[(sym1__ - 1)], 0);}
      current_statement__ = 238;
      context__.validate_dims("data initialization","prior_only","int",
          context__.to_vec());
      prior_only = std::numeric_limits<int>::min();
      
      current_statement__ = 238;
      prior_only = context__.vals_i("prior_only")[(1 - 1)];
      current_statement__ = 238;
      current_statement__ = 238;
      check_greater_or_equal(function__, "prior_only", prior_only, 0);
      current_statement__ = 238;
      current_statement__ = 238;
      check_less_or_equal(function__, "prior_only", prior_only, 1);
      current_statement__ = 239;
      validate_non_negative_index("input_offset", "n", n);
      current_statement__ = 240;
      context__.validate_dims("data initialization","input_offset","double",
          context__.to_vec(n));
      input_offset = Eigen::Matrix<double, -1, 1>(n);
      stan::math::fill(input_offset, std::numeric_limits<double>::quiet_NaN());
      
      {
        std::vector<local_scalar_t__> input_offset_flat__;
        current_statement__ = 240;
        assign(input_offset_flat__, nil_index_list(),
          context__.vals_r("input_offset"),
          "assigning variable input_offset_flat__");
        current_statement__ = 240;
        pos__ = 1;
        current_statement__ = 240;
        for (int sym1__ = 1; sym1__ <= n; ++sym1__) {
          current_statement__ = 240;
          assign(input_offset,
            cons_list(index_uni(sym1__), nil_index_list()),
            input_offset_flat__[(pos__ - 1)],
            "assigning variable input_offset");
          current_statement__ = 240;
          pos__ = (pos__ + 1);}
      }
      current_statement__ = 241;
      context__.validate_dims("data initialization","dwx","int",
          context__.to_vec());
      dwx = std::numeric_limits<int>::min();
      
      current_statement__ = 241;
      dwx = context__.vals_i("dwx")[(1 - 1)];
      current_statement__ = 241;
      current_statement__ = 241;
      check_greater_or_equal(function__, "dwx", dwx, 0);
      current_statement__ = 242;
      validate_non_negative_index("wx_idx", "dwx ? dwx : 1", (dwx ? dwx : 1));
      current_statement__ = 243;
      context__.validate_dims("data initialization","wx_idx","int",
          context__.to_vec((dwx ? dwx : 1)));
      wx_idx = std::vector<int>((dwx ? dwx : 1), std::numeric_limits<int>::min());
      
      current_statement__ = 243;
      assign(wx_idx, nil_index_list(), context__.vals_i("wx_idx"),
        "assigning variable wx_idx");
      current_statement__ = 244;
      context__.validate_dims("data initialization","dw_nonzero","int",
          context__.to_vec());
      dw_nonzero = std::numeric_limits<int>::min();
      
      current_statement__ = 244;
      dw_nonzero = context__.vals_i("dw_nonzero")[(1 - 1)];
      current_statement__ = 244;
      current_statement__ = 244;
      check_greater_or_equal(function__, "dw_nonzero", dw_nonzero, 0);
      current_statement__ = 245;
      validate_non_negative_index("W_w", "dw_nonzero", dw_nonzero);
      current_statement__ = 246;
      context__.validate_dims("data initialization","W_w","double",
          context__.to_vec(dw_nonzero));
      W_w = Eigen::Matrix<double, -1, 1>(dw_nonzero);
      stan::math::fill(W_w, std::numeric_limits<double>::quiet_NaN());
      
      {
        std::vector<local_scalar_t__> W_w_flat__;
        current_statement__ = 246;
        assign(W_w_flat__, nil_index_list(), context__.vals_r("W_w"),
          "assigning variable W_w_flat__");
        current_statement__ = 246;
        pos__ = 1;
        current_statement__ = 246;
        for (int sym1__ = 1; sym1__ <= dw_nonzero; ++sym1__) {
          current_statement__ = 246;
          assign(W_w, cons_list(index_uni(sym1__), nil_index_list()),
            W_w_flat__[(pos__ - 1)], "assigning variable W_w");
          current_statement__ = 246;
          pos__ = (pos__ + 1);}
      }
      current_statement__ = 247;
      validate_non_negative_index("W_v", "dw_nonzero", dw_nonzero);
      current_statement__ = 248;
      context__.validate_dims("data initialization","W_v","int",
          context__.to_vec(dw_nonzero));
      W_v = std::vector<int>(dw_nonzero, std::numeric_limits<int>::min());
      
      current_statement__ = 248;
      assign(W_v, nil_index_list(), context__.vals_i("W_v"),
        "assigning variable W_v");
      current_statement__ = 249;
      validate_non_negative_index("W_u", "dwx ? n + 1 : 1",
                                  (dwx ? (n + 1) : 1));
      current_statement__ = 250;
      context__.validate_dims("data initialization","W_u","int",
          context__.to_vec((dwx ? (n + 1) : 1)));
      W_u = std::vector<int>((dwx ? (n + 1) : 1), std::numeric_limits<int>::min());
      
      current_statement__ = 250;
      assign(W_u, nil_index_list(), context__.vals_i("W_u"),
        "assigning variable W_u");
      current_statement__ = 251;
      context__.validate_dims("data initialization","bounds","double",
          context__.to_vec(2));
      bounds = std::vector<double>(2, std::numeric_limits<double>::quiet_NaN());
      
      current_statement__ = 251;
      assign(bounds, nil_index_list(), context__.vals_r("bounds"),
        "assigning variable bounds");
      current_statement__ = 252;
      context__.validate_dims("data initialization","dx_obs","int",
          context__.to_vec());
      dx_obs = std::numeric_limits<int>::min();
      
      current_statement__ = 252;
      dx_obs = context__.vals_i("dx_obs")[(1 - 1)];
      current_statement__ = 252;
      current_statement__ = 252;
      check_greater_or_equal(function__, "dx_obs", dx_obs, 0);
      current_statement__ = 253;
      context__.validate_dims("data initialization","dx_me","int",
          context__.to_vec());
      dx_me = std::numeric_limits<int>::min();
      
      current_statement__ = 253;
      dx_me = context__.vals_i("dx_me")[(1 - 1)];
      current_statement__ = 253;
      current_statement__ = 253;
      check_greater_or_equal(function__, "dx_me", dx_me, 0);
      current_statement__ = 254;
      validate_non_negative_index("use_logit", "dx_me", dx_me);
      current_statement__ = 255;
      context__.validate_dims("data initialization","use_logit","int",
          context__.to_vec(dx_me));
      use_logit = std::vector<int>(dx_me, std::numeric_limits<int>::min());
      
      current_statement__ = 255;
      assign(use_logit, nil_index_list(), context__.vals_i("use_logit"),
        "assigning variable use_logit");
      current_statement__ = 255;
      for (int sym1__ = 1; sym1__ <= dx_me; ++sym1__) {
        current_statement__ = 255;
        current_statement__ = 255;
        check_greater_or_equal(function__, "use_logit[sym1__]",
                               use_logit[(sym1__ - 1)], 0);}
      current_statement__ = 255;
      for (int sym1__ = 1; sym1__ <= dx_me; ++sym1__) {
        current_statement__ = 255;
        current_statement__ = 255;
        check_less_or_equal(function__, "use_logit[sym1__]",
                            use_logit[(sym1__ - 1)], 1);}
      current_statement__ = 256;
      validate_non_negative_index("x_obs_idx", "dx_obs ? dx_obs : 1",
                                  (dx_obs ? dx_obs : 1));
      current_statement__ = 257;
      context__.validate_dims("data initialization","x_obs_idx","int",
          context__.to_vec((dx_obs ? dx_obs : 1)));
      x_obs_idx = std::vector<int>((dx_obs ? dx_obs : 1), std::numeric_limits<int>::min());
      
      current_statement__ = 257;
      assign(x_obs_idx, nil_index_list(), context__.vals_i("x_obs_idx"),
        "assigning variable x_obs_idx");
      current_statement__ = 257;
      for (int sym1__ = 1; sym1__ <= (dx_obs ? dx_obs : 1); ++sym1__) {
        current_statement__ = 257;
        current_statement__ = 257;
        check_greater_or_equal(function__, "x_obs_idx[sym1__]",
                               x_obs_idx[(sym1__ - 1)], 0);}
      current_statement__ = 258;
      validate_non_negative_index("x_me_idx", "dx_me ? dx_me : 1",
                                  (dx_me ? dx_me : 1));
      current_statement__ = 259;
      context__.validate_dims("data initialization","x_me_idx","int",
          context__.to_vec((dx_me ? dx_me : 1)));
      x_me_idx = std::vector<int>((dx_me ? dx_me : 1), std::numeric_limits<int>::min());
      
      current_statement__ = 259;
      assign(x_me_idx, nil_index_list(), context__.vals_i("x_me_idx"),
        "assigning variable x_me_idx");
      current_statement__ = 259;
      for (int sym1__ = 1; sym1__ <= (dx_me ? dx_me : 1); ++sym1__) {
        current_statement__ = 259;
        current_statement__ = 259;
        check_greater_or_equal(function__, "x_me_idx[sym1__]",
                               x_me_idx[(sym1__ - 1)], 0);}
      current_statement__ = 260;
      validate_non_negative_index("x_obs", "n", n);
      current_statement__ = 261;
      validate_non_negative_index("x_obs", "dx_obs ? dx_obs : 0",
                                  (dx_obs ? dx_obs : 0));
      current_statement__ = 262;
      context__.validate_dims("data initialization","x_obs","double",
          context__.to_vec(n, (dx_obs ? dx_obs : 0)));
      x_obs = Eigen::Matrix<double, -1, -1>(n, (dx_obs ? dx_obs : 0));
      stan::math::fill(x_obs, std::numeric_limits<double>::quiet_NaN());
      
      {
        std::vector<local_scalar_t__> x_obs_flat__;
        current_statement__ = 262;
        assign(x_obs_flat__, nil_index_list(), context__.vals_r("x_obs"),
          "assigning variable x_obs_flat__");
        current_statement__ = 262;
        pos__ = 1;
        current_statement__ = 262;
        for (int sym1__ = 1; sym1__ <= (dx_obs ? dx_obs : 0); ++sym1__) {
          current_statement__ = 262;
          for (int sym2__ = 1; sym2__ <= n; ++sym2__) {
            current_statement__ = 262;
            assign(x_obs,
              cons_list(index_uni(sym2__),
                cons_list(index_uni(sym1__), nil_index_list())),
              x_obs_flat__[(pos__ - 1)], "assigning variable x_obs");
            current_statement__ = 262;
            pos__ = (pos__ + 1);}}
      }
      current_statement__ = 263;
      validate_non_negative_index("x_me", "dx_me", dx_me);
      current_statement__ = 264;
      validate_non_negative_index("x_me", "n", n);
      current_statement__ = 265;
      context__.validate_dims("data initialization","x_me","double",
          context__.to_vec(dx_me, n));
      x_me = std::vector<Eigen::Matrix<double, -1, 1>>(dx_me, Eigen::Matrix<double, -1, 1>(n));
      stan::math::fill(x_me, std::numeric_limits<double>::quiet_NaN());
      
      {
        std::vector<local_scalar_t__> x_me_flat__;
        current_statement__ = 265;
        assign(x_me_flat__, nil_index_list(), context__.vals_r("x_me"),
          "assigning variable x_me_flat__");
        current_statement__ = 265;
        pos__ = 1;
        current_statement__ = 265;
        for (int sym1__ = 1; sym1__ <= n; ++sym1__) {
          current_statement__ = 265;
          for (int sym2__ = 1; sym2__ <= dx_me; ++sym2__) {
            current_statement__ = 265;
            assign(x_me,
              cons_list(index_uni(sym2__),
                cons_list(index_uni(sym1__), nil_index_list())),
              x_me_flat__[(pos__ - 1)], "assigning variable x_me");
            current_statement__ = 265;
            pos__ = (pos__ + 1);}}
      }
      current_statement__ = 266;
      validate_non_negative_index("sigma_me", "dx_me", dx_me);
      current_statement__ = 267;
      validate_non_negative_index("sigma_me", "n", n);
      current_statement__ = 268;
      context__.validate_dims("data initialization","sigma_me","double",
          context__.to_vec(dx_me, n));
      sigma_me = std::vector<Eigen::Matrix<double, -1, 1>>(dx_me, Eigen::Matrix<double, -1, 1>(n));
      stan::math::fill(sigma_me, std::numeric_limits<double>::quiet_NaN());
      
      {
        std::vector<local_scalar_t__> sigma_me_flat__;
        current_statement__ = 268;
        assign(sigma_me_flat__, nil_index_list(),
          context__.vals_r("sigma_me"), "assigning variable sigma_me_flat__");
        current_statement__ = 268;
        pos__ = 1;
        current_statement__ = 268;
        for (int sym1__ = 1; sym1__ <= n; ++sym1__) {
          current_statement__ = 268;
          for (int sym2__ = 1; sym2__ <= dx_me; ++sym2__) {
            current_statement__ = 268;
            assign(sigma_me,
              cons_list(index_uni(sym2__),
                cons_list(index_uni(sym1__), nil_index_list())),
              sigma_me_flat__[(pos__ - 1)], "assigning variable sigma_me");
            current_statement__ = 268;
            pos__ = (pos__ + 1);}}
      }
      current_statement__ = 268;
      for (int sym1__ = 1; sym1__ <= dx_me; ++sym1__) {
        current_statement__ = 268;
        for (int sym2__ = 1; sym2__ <= n; ++sym2__) {
          current_statement__ = 268;
          current_statement__ = 268;
          check_greater_or_equal(function__, "sigma_me[sym1__, sym2__]",
                                 sigma_me[(sym1__ - 1)][(sym2__ - 1)], 0);}}
      current_statement__ = 269;
      validate_non_negative_index("prior_nux_true_alpha", "dx_me", dx_me);
      current_statement__ = 270;
      context__.validate_dims("data initialization","prior_nux_true_alpha",
          "double",context__.to_vec(dx_me));
      prior_nux_true_alpha = Eigen::Matrix<double, -1, 1>(dx_me);
      stan::math::fill(prior_nux_true_alpha, std::numeric_limits<double>::quiet_NaN());
      
      {
        std::vector<local_scalar_t__> prior_nux_true_alpha_flat__;
        current_statement__ = 270;
        assign(prior_nux_true_alpha_flat__, nil_index_list(),
          context__.vals_r("prior_nux_true_alpha"),
          "assigning variable prior_nux_true_alpha_flat__");
        current_statement__ = 270;
        pos__ = 1;
        current_statement__ = 270;
        for (int sym1__ = 1; sym1__ <= dx_me; ++sym1__) {
          current_statement__ = 270;
          assign(prior_nux_true_alpha,
            cons_list(index_uni(sym1__), nil_index_list()),
            prior_nux_true_alpha_flat__[(pos__ - 1)],
            "assigning variable prior_nux_true_alpha");
          current_statement__ = 270;
          pos__ = (pos__ + 1);}
      }
      current_statement__ = 271;
      validate_non_negative_index("prior_nux_true_beta", "dx_me", dx_me);
      current_statement__ = 272;
      context__.validate_dims("data initialization","prior_nux_true_beta",
          "double",context__.to_vec(dx_me));
      prior_nux_true_beta = Eigen::Matrix<double, -1, 1>(dx_me);
      stan::math::fill(prior_nux_true_beta, std::numeric_limits<double>::quiet_NaN());
      
      {
        std::vector<local_scalar_t__> prior_nux_true_beta_flat__;
        current_statement__ = 272;
        assign(prior_nux_true_beta_flat__, nil_index_list(),
          context__.vals_r("prior_nux_true_beta"),
          "assigning variable prior_nux_true_beta_flat__");
        current_statement__ = 272;
        pos__ = 1;
        current_statement__ = 272;
        for (int sym1__ = 1; sym1__ <= dx_me; ++sym1__) {
          current_statement__ = 272;
          assign(prior_nux_true_beta,
            cons_list(index_uni(sym1__), nil_index_list()),
            prior_nux_true_beta_flat__[(pos__ - 1)],
            "assigning variable prior_nux_true_beta");
          current_statement__ = 272;
          pos__ = (pos__ + 1);}
      }
      current_statement__ = 273;
      validate_non_negative_index("prior_mux_true_location", "dx_me", dx_me);
      current_statement__ = 274;
      context__.validate_dims("data initialization",
          "prior_mux_true_location","double",context__.to_vec(dx_me));
      prior_mux_true_location = Eigen::Matrix<double, -1, 1>(dx_me);
      stan::math::fill(prior_mux_true_location, std::numeric_limits<double>::quiet_NaN());
      
      {
        std::vector<local_scalar_t__> prior_mux_true_location_flat__;
        current_statement__ = 274;
        assign(prior_mux_true_location_flat__, nil_index_list(),
          context__.vals_r("prior_mux_true_location"),
          "assigning variable prior_mux_true_location_flat__");
        current_statement__ = 274;
        pos__ = 1;
        current_statement__ = 274;
        for (int sym1__ = 1; sym1__ <= dx_me; ++sym1__) {
          current_statement__ = 274;
          assign(prior_mux_true_location,
            cons_list(index_uni(sym1__), nil_index_list()),
            prior_mux_true_location_flat__[(pos__ - 1)],
            "assigning variable prior_mux_true_location");
          current_statement__ = 274;
          pos__ = (pos__ + 1);}
      }
      current_statement__ = 275;
      validate_non_negative_index("prior_mux_true_scale", "dx_me", dx_me);
      current_statement__ = 276;
      context__.validate_dims("data initialization","prior_mux_true_scale",
          "double",context__.to_vec(dx_me));
      prior_mux_true_scale = Eigen::Matrix<double, -1, 1>(dx_me);
      stan::math::fill(prior_mux_true_scale, std::numeric_limits<double>::quiet_NaN());
      
      {
        std::vector<local_scalar_t__> prior_mux_true_scale_flat__;
        current_statement__ = 276;
        assign(prior_mux_true_scale_flat__, nil_index_list(),
          context__.vals_r("prior_mux_true_scale"),
          "assigning variable prior_mux_true_scale_flat__");
        current_statement__ = 276;
        pos__ = 1;
        current_statement__ = 276;
        for (int sym1__ = 1; sym1__ <= dx_me; ++sym1__) {
          current_statement__ = 276;
          assign(prior_mux_true_scale,
            cons_list(index_uni(sym1__), nil_index_list()),
            prior_mux_true_scale_flat__[(pos__ - 1)],
            "assigning variable prior_mux_true_scale");
          current_statement__ = 276;
          pos__ = (pos__ + 1);}
      }
      current_statement__ = 277;
      validate_non_negative_index("prior_sigmax_true_df", "dx_me", dx_me);
      current_statement__ = 278;
      context__.validate_dims("data initialization","prior_sigmax_true_df",
          "double",context__.to_vec(dx_me));
      prior_sigmax_true_df = Eigen::Matrix<double, -1, 1>(dx_me);
      stan::math::fill(prior_sigmax_true_df, std::numeric_limits<double>::quiet_NaN());
      
      {
        std::vector<local_scalar_t__> prior_sigmax_true_df_flat__;
        current_statement__ = 278;
        assign(prior_sigmax_true_df_flat__, nil_index_list(),
          context__.vals_r("prior_sigmax_true_df"),
          "assigning variable prior_sigmax_true_df_flat__");
        current_statement__ = 278;
        pos__ = 1;
        current_statement__ = 278;
        for (int sym1__ = 1; sym1__ <= dx_me; ++sym1__) {
          current_statement__ = 278;
          assign(prior_sigmax_true_df,
            cons_list(index_uni(sym1__), nil_index_list()),
            prior_sigmax_true_df_flat__[(pos__ - 1)],
            "assigning variable prior_sigmax_true_df");
          current_statement__ = 278;
          pos__ = (pos__ + 1);}
      }
      current_statement__ = 279;
      validate_non_negative_index("prior_sigmax_true_location", "dx_me",
                                  dx_me);
      current_statement__ = 280;
      context__.validate_dims("data initialization",
          "prior_sigmax_true_location","double",context__.to_vec(dx_me));
      prior_sigmax_true_location = Eigen::Matrix<double, -1, 1>(dx_me);
      stan::math::fill(prior_sigmax_true_location, std::numeric_limits<double>::quiet_NaN());
      
      {
        std::vector<local_scalar_t__> prior_sigmax_true_location_flat__;
        current_statement__ = 280;
        assign(prior_sigmax_true_location_flat__, nil_index_list(),
          context__.vals_r("prior_sigmax_true_location"),
          "assigning variable prior_sigmax_true_location_flat__");
        current_statement__ = 280;
        pos__ = 1;
        current_statement__ = 280;
        for (int sym1__ = 1; sym1__ <= dx_me; ++sym1__) {
          current_statement__ = 280;
          assign(prior_sigmax_true_location,
            cons_list(index_uni(sym1__), nil_index_list()),
            prior_sigmax_true_location_flat__[(pos__ - 1)],
            "assigning variable prior_sigmax_true_location");
          current_statement__ = 280;
          pos__ = (pos__ + 1);}
      }
      current_statement__ = 281;
      validate_non_negative_index("prior_sigmax_true_scale", "dx_me", dx_me);
      current_statement__ = 282;
      context__.validate_dims("data initialization",
          "prior_sigmax_true_scale","double",context__.to_vec(dx_me));
      prior_sigmax_true_scale = Eigen::Matrix<double, -1, 1>(dx_me);
      stan::math::fill(prior_sigmax_true_scale, std::numeric_limits<double>::quiet_NaN());
      
      {
        std::vector<local_scalar_t__> prior_sigmax_true_scale_flat__;
        current_statement__ = 282;
        assign(prior_sigmax_true_scale_flat__, nil_index_list(),
          context__.vals_r("prior_sigmax_true_scale"),
          "assigning variable prior_sigmax_true_scale_flat__");
        current_statement__ = 282;
        pos__ = 1;
        current_statement__ = 282;
        for (int sym1__ = 1; sym1__ <= dx_me; ++sym1__) {
          current_statement__ = 282;
          assign(prior_sigmax_true_scale,
            cons_list(index_uni(sym1__), nil_index_list()),
            prior_sigmax_true_scale_flat__[(pos__ - 1)],
            "assigning variable prior_sigmax_true_scale");
          current_statement__ = 282;
          pos__ = (pos__ + 1);}
      }
      current_statement__ = 283;
      context__.validate_dims("data initialization","prior_rhox_true",
          "double",context__.to_vec(2));
      prior_rhox_true = Eigen::Matrix<double, -1, 1>(2);
      stan::math::fill(prior_rhox_true, std::numeric_limits<double>::quiet_NaN());
      
      {
        std::vector<local_scalar_t__> prior_rhox_true_flat__;
        current_statement__ = 283;
        assign(prior_rhox_true_flat__, nil_index_list(),
          context__.vals_r("prior_rhox_true"),
          "assigning variable prior_rhox_true_flat__");
        current_statement__ = 283;
        pos__ = 1;
        current_statement__ = 283;
        for (int sym1__ = 1; sym1__ <= 2; ++sym1__) {
          current_statement__ = 283;
          assign(prior_rhox_true,
            cons_list(index_uni(sym1__), nil_index_list()),
            prior_rhox_true_flat__[(pos__ - 1)],
            "assigning variable prior_rhox_true");
          current_statement__ = 283;
          pos__ = (pos__ + 1);}
      }
      current_statement__ = 284;
      context__.validate_dims("data initialization","spatial_me","int",
          context__.to_vec());
      spatial_me = std::numeric_limits<int>::min();
      
      current_statement__ = 284;
      spatial_me = context__.vals_i("spatial_me")[(1 - 1)];
      current_statement__ = 284;
      current_statement__ = 284;
      check_greater_or_equal(function__, "spatial_me", spatial_me, 0);
      current_statement__ = 284;
      current_statement__ = 284;
      check_less_or_equal(function__, "spatial_me", spatial_me, 1);
      current_statement__ = 285;
      context__.validate_dims("data initialization","WCAR","int",
          context__.to_vec());
      WCAR = std::numeric_limits<int>::min();
      
      current_statement__ = 285;
      WCAR = context__.vals_i("WCAR")[(1 - 1)];
      current_statement__ = 285;
      current_statement__ = 285;
      check_greater_or_equal(function__, "WCAR", WCAR, 0);
      current_statement__ = 285;
      current_statement__ = 285;
      check_less_or_equal(function__, "WCAR", WCAR, 1);
      current_statement__ = 286;
      context__.validate_dims("data initialization","nAx_w","int",
          context__.to_vec());
      nAx_w = std::numeric_limits<int>::min();
      
      current_statement__ = 286;
      nAx_w = context__.vals_i("nAx_w")[(1 - 1)];
      current_statement__ = 287;
      context__.validate_dims("data initialization","nC","int",
          context__.to_vec());
      nC = std::numeric_limits<int>::min();
      
      current_statement__ = 287;
      nC = context__.vals_i("nC")[(1 - 1)];
      current_statement__ = 288;
      validate_non_negative_index("Ax_w", "nAx_w", nAx_w);
      current_statement__ = 289;
      context__.validate_dims("data initialization","Ax_w","double",
          context__.to_vec(nAx_w));
      Ax_w = Eigen::Matrix<double, -1, 1>(nAx_w);
      stan::math::fill(Ax_w, std::numeric_limits<double>::quiet_NaN());
      
      {
        std::vector<local_scalar_t__> Ax_w_flat__;
        current_statement__ = 289;
        assign(Ax_w_flat__, nil_index_list(), context__.vals_r("Ax_w"),
          "assigning variable Ax_w_flat__");
        current_statement__ = 289;
        pos__ = 1;
        current_statement__ = 289;
        for (int sym1__ = 1; sym1__ <= nAx_w; ++sym1__) {
          current_statement__ = 289;
          assign(Ax_w, cons_list(index_uni(sym1__), nil_index_list()),
            Ax_w_flat__[(pos__ - 1)], "assigning variable Ax_w");
          current_statement__ = 289;
          pos__ = (pos__ + 1);}
      }
      current_statement__ = 290;
      validate_non_negative_index("Ax_v", "nAx_w", nAx_w);
      current_statement__ = 291;
      context__.validate_dims("data initialization","Ax_v","int",
          context__.to_vec(nAx_w));
      Ax_v = std::vector<int>(nAx_w, std::numeric_limits<int>::min());
      
      current_statement__ = 291;
      assign(Ax_v, nil_index_list(), context__.vals_i("Ax_v"),
        "assigning variable Ax_v");
      current_statement__ = 292;
      validate_non_negative_index("Ax_u", "n + 1", (n + 1));
      current_statement__ = 293;
      context__.validate_dims("data initialization","Ax_u","int",
          context__.to_vec((n + 1)));
      Ax_u = std::vector<int>((n + 1), std::numeric_limits<int>::min());
      
      current_statement__ = 293;
      assign(Ax_u, nil_index_list(), context__.vals_i("Ax_u"),
        "assigning variable Ax_u");
      current_statement__ = 294;
      validate_non_negative_index("Cidx", "nC", nC);
      current_statement__ = 295;
      context__.validate_dims("data initialization","Cidx","int",
          context__.to_vec(nC));
      Cidx = std::vector<int>(nC, std::numeric_limits<int>::min());
      
      current_statement__ = 295;
      assign(Cidx, nil_index_list(), context__.vals_i("Cidx"),
        "assigning variable Cidx");
      current_statement__ = 296;
      validate_non_negative_index("Delta_inv", "n", n);
      current_statement__ = 297;
      context__.validate_dims("data initialization","Delta_inv","double",
          context__.to_vec(n));
      Delta_inv = Eigen::Matrix<double, -1, 1>(n);
      stan::math::fill(Delta_inv, std::numeric_limits<double>::quiet_NaN());
      
      {
        std::vector<local_scalar_t__> Delta_inv_flat__;
        current_statement__ = 297;
        assign(Delta_inv_flat__, nil_index_list(),
          context__.vals_r("Delta_inv"),
          "assigning variable Delta_inv_flat__");
        current_statement__ = 297;
        pos__ = 1;
        current_statement__ = 297;
        for (int sym1__ = 1; sym1__ <= n; ++sym1__) {
          current_statement__ = 297;
          assign(Delta_inv, cons_list(index_uni(sym1__), nil_index_list()),
            Delta_inv_flat__[(pos__ - 1)], "assigning variable Delta_inv");
          current_statement__ = 297;
          pos__ = (pos__ + 1);}
      }
      current_statement__ = 298;
      context__.validate_dims("data initialization","log_det_Delta_inv",
          "double",context__.to_vec());
      log_det_Delta_inv = std::numeric_limits<double>::quiet_NaN();
      
      current_statement__ = 298;
      log_det_Delta_inv = context__.vals_r("log_det_Delta_inv")[(1 - 1)];
      current_statement__ = 299;
      validate_non_negative_index("lambda", "n", n);
      current_statement__ = 300;
      context__.validate_dims("data initialization","lambda","double",
          context__.to_vec(n));
      lambda = Eigen::Matrix<double, -1, 1>(n);
      stan::math::fill(lambda, std::numeric_limits<double>::quiet_NaN());
      
      {
        std::vector<local_scalar_t__> lambda_flat__;
        current_statement__ = 300;
        assign(lambda_flat__, nil_index_list(), context__.vals_r("lambda"),
          "assigning variable lambda_flat__");
        current_statement__ = 300;
        pos__ = 1;
        current_statement__ = 300;
        for (int sym1__ = 1; sym1__ <= n; ++sym1__) {
          current_statement__ = 300;
          assign(lambda, cons_list(index_uni(sym1__), nil_index_list()),
            lambda_flat__[(pos__ - 1)], "assigning variable lambda");
          current_statement__ = 300;
          pos__ = (pos__ + 1);}
      }
      current_statement__ = 301;
      context__.validate_dims("data initialization","has_re","int",
          context__.to_vec());
      has_re = std::numeric_limits<int>::min();
      
      current_statement__ = 301;
      has_re = context__.vals_i("has_re")[(1 - 1)];
      current_statement__ = 301;
      current_statement__ = 301;
      check_greater_or_equal(function__, "has_re", has_re, 0);
      current_statement__ = 301;
      current_statement__ = 301;
      check_less_or_equal(function__, "has_re", has_re, 1);
      current_statement__ = 302;
      context__.validate_dims("data initialization","n_ids","int",
          context__.to_vec());
      n_ids = std::numeric_limits<int>::min();
      
      current_statement__ = 302;
      n_ids = context__.vals_i("n_ids")[(1 - 1)];
      current_statement__ = 302;
      current_statement__ = 302;
      check_greater_or_equal(function__, "n_ids", n_ids, 0);
      current_statement__ = 303;
      validate_non_negative_index("id", "n", n);
      current_statement__ = 304;
      context__.validate_dims("data initialization","id","int",
          context__.to_vec(n));
      id = std::vector<int>(n, std::numeric_limits<int>::min());
      
      current_statement__ = 304;
      assign(id, nil_index_list(), context__.vals_i("id"),
        "assigning variable id");
      current_statement__ = 304;
      for (int sym1__ = 1; sym1__ <= n; ++sym1__) {
        current_statement__ = 304;
        current_statement__ = 304;
        check_greater_or_equal(function__, "id[sym1__]", id[(sym1__ - 1)], 0);
      }
      current_statement__ = 304;
      for (int sym1__ = 1; sym1__ <= n; ++sym1__) {
        current_statement__ = 304;
        current_statement__ = 304;
        check_less_or_equal(function__, "id[sym1__]", id[(sym1__ - 1)], n_ids);
      }
      current_statement__ = 305;
      context__.validate_dims("data initialization","prior_alpha","double",
          context__.to_vec(2));
      prior_alpha = Eigen::Matrix<double, -1, 1>(2);
      stan::math::fill(prior_alpha, std::numeric_limits<double>::quiet_NaN());
      
      {
        std::vector<local_scalar_t__> prior_alpha_flat__;
        current_statement__ = 305;
        assign(prior_alpha_flat__, nil_index_list(),
          context__.vals_r("prior_alpha"),
          "assigning variable prior_alpha_flat__");
        current_statement__ = 305;
        pos__ = 1;
        current_statement__ = 305;
        for (int sym1__ = 1; sym1__ <= 2; ++sym1__) {
          current_statement__ = 305;
          assign(prior_alpha, cons_list(index_uni(sym1__), nil_index_list()),
            prior_alpha_flat__[(pos__ - 1)], "assigning variable prior_alpha");
          current_statement__ = 305;
          pos__ = (pos__ + 1);}
      }
      current_statement__ = 306;
      context__.validate_dims("data initialization","dbeta_prior","int",
          context__.to_vec());
      dbeta_prior = std::numeric_limits<int>::min();
      
      current_statement__ = 306;
      dbeta_prior = context__.vals_i("dbeta_prior")[(1 - 1)];
      current_statement__ = 306;
      current_statement__ = 306;
      check_greater_or_equal(function__, "dbeta_prior", dbeta_prior, 0);
      current_statement__ = 307;
      validate_non_negative_index("prior_beta_location", "dbeta_prior",
                                  dbeta_prior);
      current_statement__ = 308;
      context__.validate_dims("data initialization","prior_beta_location",
          "double",context__.to_vec(dbeta_prior));
      prior_beta_location = Eigen::Matrix<double, -1, 1>(dbeta_prior);
      stan::math::fill(prior_beta_location, std::numeric_limits<double>::quiet_NaN());
      
      {
        std::vector<local_scalar_t__> prior_beta_location_flat__;
        current_statement__ = 308;
        assign(prior_beta_location_flat__, nil_index_list(),
          context__.vals_r("prior_beta_location"),
          "assigning variable prior_beta_location_flat__");
        current_statement__ = 308;
        pos__ = 1;
        current_statement__ = 308;
        for (int sym1__ = 1; sym1__ <= dbeta_prior; ++sym1__) {
          current_statement__ = 308;
          assign(prior_beta_location,
            cons_list(index_uni(sym1__), nil_index_list()),
            prior_beta_location_flat__[(pos__ - 1)],
            "assigning variable prior_beta_location");
          current_statement__ = 308;
          pos__ = (pos__ + 1);}
      }
      current_statement__ = 309;
      validate_non_negative_index("prior_beta_scale", "dbeta_prior",
                                  dbeta_prior);
      current_statement__ = 310;
      context__.validate_dims("data initialization","prior_beta_scale",
          "double",context__.to_vec(dbeta_prior));
      prior_beta_scale = Eigen::Matrix<double, -1, 1>(dbeta_prior);
      stan::math::fill(prior_beta_scale, std::numeric_limits<double>::quiet_NaN());
      
      {
        std::vector<local_scalar_t__> prior_beta_scale_flat__;
        current_statement__ = 310;
        assign(prior_beta_scale_flat__, nil_index_list(),
          context__.vals_r("prior_beta_scale"),
          "assigning variable prior_beta_scale_flat__");
        current_statement__ = 310;
        pos__ = 1;
        current_statement__ = 310;
        for (int sym1__ = 1; sym1__ <= dbeta_prior; ++sym1__) {
          current_statement__ = 310;
          assign(prior_beta_scale,
            cons_list(index_uni(sym1__), nil_index_list()),
            prior_beta_scale_flat__[(pos__ - 1)],
            "assigning variable prior_beta_scale");
          current_statement__ = 310;
          pos__ = (pos__ + 1);}
      }
      current_statement__ = 310;
      for (int sym1__ = 1; sym1__ <= dbeta_prior; ++sym1__) {
        current_statement__ = 310;
        current_statement__ = 310;
        check_greater_or_equal(function__, "prior_beta_scale[sym1__]",
                               prior_beta_scale[(sym1__ - 1)], 0);}
      current_statement__ = 311;
      context__.validate_dims("data initialization","prior_alpha_tau",
          "double",context__.to_vec(3));
      prior_alpha_tau = Eigen::Matrix<double, -1, 1>(3);
      stan::math::fill(prior_alpha_tau, std::numeric_limits<double>::quiet_NaN());
      
      {
        std::vector<local_scalar_t__> prior_alpha_tau_flat__;
        current_statement__ = 311;
        assign(prior_alpha_tau_flat__, nil_index_list(),
          context__.vals_r("prior_alpha_tau"),
          "assigning variable prior_alpha_tau_flat__");
        current_statement__ = 311;
        pos__ = 1;
        current_statement__ = 311;
        for (int sym1__ = 1; sym1__ <= 3; ++sym1__) {
          current_statement__ = 311;
          assign(prior_alpha_tau,
            cons_list(index_uni(sym1__), nil_index_list()),
            prior_alpha_tau_flat__[(pos__ - 1)],
            "assigning variable prior_alpha_tau");
          current_statement__ = 311;
          pos__ = (pos__ + 1);}
      }
      current_statement__ = 312;
      context__.validate_dims("data initialization","prior_t_nu","double",
          context__.to_vec(2));
      prior_t_nu = Eigen::Matrix<double, -1, 1>(2);
      stan::math::fill(prior_t_nu, std::numeric_limits<double>::quiet_NaN());
      
      {
        std::vector<local_scalar_t__> prior_t_nu_flat__;
        current_statement__ = 312;
        assign(prior_t_nu_flat__, nil_index_list(),
          context__.vals_r("prior_t_nu"),
          "assigning variable prior_t_nu_flat__");
        current_statement__ = 312;
        pos__ = 1;
        current_statement__ = 312;
        for (int sym1__ = 1; sym1__ <= 2; ++sym1__) {
          current_statement__ = 312;
          assign(prior_t_nu, cons_list(index_uni(sym1__), nil_index_list()),
            prior_t_nu_flat__[(pos__ - 1)], "assigning variable prior_t_nu");
          current_statement__ = 312;
          pos__ = (pos__ + 1);}
      }
      current_statement__ = 313;
      context__.validate_dims("data initialization","prior_sigma","double",
          context__.to_vec(3));
      prior_sigma = Eigen::Matrix<double, -1, 1>(3);
      stan::math::fill(prior_sigma, std::numeric_limits<double>::quiet_NaN());
      
      {
        std::vector<local_scalar_t__> prior_sigma_flat__;
        current_statement__ = 313;
        assign(prior_sigma_flat__, nil_index_list(),
          context__.vals_r("prior_sigma"),
          "assigning variable prior_sigma_flat__");
        current_statement__ = 313;
        pos__ = 1;
        current_statement__ = 313;
        for (int sym1__ = 1; sym1__ <= 3; ++sym1__) {
          current_statement__ = 313;
          assign(prior_sigma, cons_list(index_uni(sym1__), nil_index_list()),
            prior_sigma_flat__[(pos__ - 1)], "assigning variable prior_sigma");
          current_statement__ = 313;
          pos__ = (pos__ + 1);}
      }
      current_statement__ = 314;
      context__.validate_dims("data initialization","type","int",
          context__.to_vec());
      type = std::numeric_limits<int>::min();
      
      current_statement__ = 314;
      type = context__.vals_i("type")[(1 - 1)];
      current_statement__ = 314;
      current_statement__ = 314;
      check_greater_or_equal(function__, "type", type, 0);
      current_statement__ = 314;
      current_statement__ = 314;
      check_less_or_equal(function__, "type", type, 3);
      current_statement__ = 315;
      context__.validate_dims("data initialization","k","int",
          context__.to_vec());
      k = std::numeric_limits<int>::min();
      
      current_statement__ = 315;
      k = context__.vals_i("k")[(1 - 1)];
      current_statement__ = 315;
      current_statement__ = 315;
      check_greater_or_equal(function__, "k", k, 1);
      current_statement__ = 316;
      validate_non_negative_index("group_size", "k", k);
      current_statement__ = 317;
      context__.validate_dims("data initialization","group_size","int",
          context__.to_vec(k));
      group_size = std::vector<int>(k, std::numeric_limits<int>::min());
      
      current_statement__ = 317;
      assign(group_size, nil_index_list(), context__.vals_i("group_size"),
        "assigning variable group_size");
      current_statement__ = 318;
      validate_non_negative_index("group_idx", "n", n);
      current_statement__ = 319;
      context__.validate_dims("data initialization","group_idx","int",
          context__.to_vec(n));
      group_idx = std::vector<int>(n, std::numeric_limits<int>::min());
      
      current_statement__ = 319;
      assign(group_idx, nil_index_list(), context__.vals_i("group_idx"),
        "assigning variable group_idx");
      current_statement__ = 320;
      context__.validate_dims("data initialization","m","int",
          context__.to_vec());
      m = std::numeric_limits<int>::min();
      
      current_statement__ = 320;
      m = context__.vals_i("m")[(1 - 1)];
      current_statement__ = 320;
      current_statement__ = 320;
      check_greater_or_equal(function__, "m", m, 0);
      current_statement__ = 321;
      validate_non_negative_index("A", "n", n);
      current_statement__ = 322;
      validate_non_negative_index("A", "m", m);
      current_statement__ = 323;
      context__.validate_dims("data initialization","A","double",
          context__.to_vec(n, m));
      A = Eigen::Matrix<double, -1, -1>(n, m);
      stan::math::fill(A, std::numeric_limits<double>::quiet_NaN());
      
      {
        std::vector<local_scalar_t__> A_flat__;
        current_statement__ = 323;
        assign(A_flat__, nil_index_list(), context__.vals_r("A"),
          "assigning variable A_flat__");
        current_statement__ = 323;
        pos__ = 1;
        current_statement__ = 323;
        for (int sym1__ = 1; sym1__ <= m; ++sym1__) {
          current_statement__ = 323;
          for (int sym2__ = 1; sym2__ <= n; ++sym2__) {
            current_statement__ = 323;
            assign(A,
              cons_list(index_uni(sym2__),
                cons_list(index_uni(sym1__), nil_index_list())),
              A_flat__[(pos__ - 1)], "assigning variable A");
            current_statement__ = 323;
            pos__ = (pos__ + 1);}}
      }
      current_statement__ = 324;
      context__.validate_dims("data initialization","n_edges","int",
          context__.to_vec());
      n_edges = std::numeric_limits<int>::min();
      
      current_statement__ = 324;
      n_edges = context__.vals_i("n_edges")[(1 - 1)];
      current_statement__ = 324;
      current_statement__ = 324;
      check_greater_or_equal(function__, "n_edges", n_edges, 1);
      current_statement__ = 325;
      validate_non_negative_index("node1", "n_edges", n_edges);
      current_statement__ = 326;
      context__.validate_dims("data initialization","node1","int",
          context__.to_vec(n_edges));
      node1 = std::vector<int>(n_edges, std::numeric_limits<int>::min());
      
      current_statement__ = 326;
      assign(node1, nil_index_list(), context__.vals_i("node1"),
        "assigning variable node1");
      current_statement__ = 326;
      for (int sym1__ = 1; sym1__ <= n_edges; ++sym1__) {
        current_statement__ = 326;
        current_statement__ = 326;
        check_greater_or_equal(function__, "node1[sym1__]",
                               node1[(sym1__ - 1)], 1);}
      current_statement__ = 326;
      for (int sym1__ = 1; sym1__ <= n_edges; ++sym1__) {
        current_statement__ = 326;
        current_statement__ = 326;
        check_less_or_equal(function__, "node1[sym1__]", node1[(sym1__ - 1)],
                            n);}
      current_statement__ = 327;
      validate_non_negative_index("node2", "n_edges", n_edges);
      current_statement__ = 328;
      context__.validate_dims("data initialization","node2","int",
          context__.to_vec(n_edges));
      node2 = std::vector<int>(n_edges, std::numeric_limits<int>::min());
      
      current_statement__ = 328;
      assign(node2, nil_index_list(), context__.vals_i("node2"),
        "assigning variable node2");
      current_statement__ = 328;
      for (int sym1__ = 1; sym1__ <= n_edges; ++sym1__) {
        current_statement__ = 328;
        current_statement__ = 328;
        check_greater_or_equal(function__, "node2[sym1__]",
                               node2[(sym1__ - 1)], 1);}
      current_statement__ = 328;
      for (int sym1__ = 1; sym1__ <= n_edges; ++sym1__) {
        current_statement__ = 328;
        current_statement__ = 328;
        check_less_or_equal(function__, "node2[sym1__]", node2[(sym1__ - 1)],
                            n);}
      current_statement__ = 329;
      validate_non_negative_index("weight", "n_edges", n_edges);
      current_statement__ = 330;
      context__.validate_dims("data initialization","weight","double",
          context__.to_vec(n_edges));
      weight = Eigen::Matrix<double, -1, 1>(n_edges);
      stan::math::fill(weight, std::numeric_limits<double>::quiet_NaN());
      
      {
        std::vector<local_scalar_t__> weight_flat__;
        current_statement__ = 330;
        assign(weight_flat__, nil_index_list(), context__.vals_r("weight"),
          "assigning variable weight_flat__");
        current_statement__ = 330;
        pos__ = 1;
        current_statement__ = 330;
        for (int sym1__ = 1; sym1__ <= n_edges; ++sym1__) {
          current_statement__ = 330;
          assign(weight, cons_list(index_uni(sym1__), nil_index_list()),
            weight_flat__[(pos__ - 1)], "assigning variable weight");
          current_statement__ = 330;
          pos__ = (pos__ + 1);}
      }
      current_statement__ = 331;
      validate_non_negative_index("comp_id", "n", n);
      current_statement__ = 332;
      context__.validate_dims("data initialization","comp_id","int",
          context__.to_vec(n));
      comp_id = std::vector<int>(n, std::numeric_limits<int>::min());
      
      current_statement__ = 332;
      assign(comp_id, nil_index_list(), context__.vals_i("comp_id"),
        "assigning variable comp_id");
      current_statement__ = 332;
      for (int sym1__ = 1; sym1__ <= n; ++sym1__) {
        current_statement__ = 332;
        current_statement__ = 332;
        check_greater_or_equal(function__, "comp_id[sym1__]",
                               comp_id[(sym1__ - 1)], 1);}
      current_statement__ = 332;
      for (int sym1__ = 1; sym1__ <= n; ++sym1__) {
        current_statement__ = 332;
        current_statement__ = 332;
        check_less_or_equal(function__, "comp_id[sym1__]",
                            comp_id[(sym1__ - 1)], k);}
      current_statement__ = 333;
      validate_non_negative_index("inv_sqrt_scale_factor", "k", k);
      current_statement__ = 334;
      context__.validate_dims("data initialization","inv_sqrt_scale_factor",
          "double",context__.to_vec(k));
      inv_sqrt_scale_factor = Eigen::Matrix<double, -1, 1>(k);
      stan::math::fill(inv_sqrt_scale_factor, std::numeric_limits<double>::quiet_NaN());
      
      {
        std::vector<local_scalar_t__> inv_sqrt_scale_factor_flat__;
        current_statement__ = 334;
        assign(inv_sqrt_scale_factor_flat__, nil_index_list(),
          context__.vals_r("inv_sqrt_scale_factor"),
          "assigning variable inv_sqrt_scale_factor_flat__");
        current_statement__ = 334;
        pos__ = 1;
        current_statement__ = 334;
        for (int sym1__ = 1; sym1__ <= k; ++sym1__) {
          current_statement__ = 334;
          assign(inv_sqrt_scale_factor,
            cons_list(index_uni(sym1__), nil_index_list()),
            inv_sqrt_scale_factor_flat__[(pos__ - 1)],
            "assigning variable inv_sqrt_scale_factor");
          current_statement__ = 334;
          pos__ = (pos__ + 1);}
      }
      current_statement__ = 335;
      context__.validate_dims("data initialization","dev","int",
          context__.to_vec());
      dev = std::numeric_limits<int>::min();
      
      current_statement__ = 335;
      dev = context__.vals_i("dev")[(1 - 1)];
      current_statement__ = 335;
      current_statement__ = 335;
      check_greater_or_equal(function__, "dev", dev, 0);
      current_statement__ = 336;
      validate_non_negative_index("EV", "n", n);
      current_statement__ = 337;
      validate_non_negative_index("EV", "dev", dev);
      current_statement__ = 338;
      context__.validate_dims("data initialization","EV","double",
          context__.to_vec(n, dev));
      EV = Eigen::Matrix<double, -1, -1>(n, dev);
      stan::math::fill(EV, std::numeric_limits<double>::quiet_NaN());
      
      {
        std::vector<local_scalar_t__> EV_flat__;
        current_statement__ = 338;
        assign(EV_flat__, nil_index_list(), context__.vals_r("EV"),
          "assigning variable EV_flat__");
        current_statement__ = 338;
        pos__ = 1;
        current_statement__ = 338;
        for (int sym1__ = 1; sym1__ <= dev; ++sym1__) {
          current_statement__ = 338;
          for (int sym2__ = 1; sym2__ <= n; ++sym2__) {
            current_statement__ = 338;
            assign(EV,
              cons_list(index_uni(sym2__),
                cons_list(index_uni(sym1__), nil_index_list())),
              EV_flat__[(pos__ - 1)], "assigning variable EV");
            current_statement__ = 338;
            pos__ = (pos__ + 1);}}
      }
      current_statement__ = 339;
      context__.validate_dims("data initialization","global_scale","double",
          context__.to_vec());
      global_scale = std::numeric_limits<double>::quiet_NaN();
      
      current_statement__ = 339;
      global_scale = context__.vals_r("global_scale")[(1 - 1)];
      current_statement__ = 339;
      current_statement__ = 339;
      check_greater_or_equal(function__, "global_scale", global_scale, 0);
      current_statement__ = 340;
      context__.validate_dims("data initialization","slab_scale","double",
          context__.to_vec());
      slab_scale = std::numeric_limits<double>::quiet_NaN();
      
      current_statement__ = 340;
      slab_scale = context__.vals_r("slab_scale")[(1 - 1)];
      current_statement__ = 340;
      current_statement__ = 340;
      check_greater_or_equal(function__, "slab_scale", slab_scale, 0);
      current_statement__ = 341;
      context__.validate_dims("data initialization","slab_df","double",
          context__.to_vec());
      slab_df = std::numeric_limits<double>::quiet_NaN();
      
      current_statement__ = 341;
      slab_df = context__.vals_r("slab_df")[(1 - 1)];
      current_statement__ = 341;
      current_statement__ = 341;
      check_greater_or_equal(function__, "slab_df", slab_df, 0);
      current_statement__ = 342;
      context__.validate_dims("data initialization","car_rho_lims","double",
          context__.to_vec(2));
      car_rho_lims = std::vector<double>(2, std::numeric_limits<double>::quiet_NaN());
      
      current_statement__ = 342;
      assign(car_rho_lims, nil_index_list(),
        context__.vals_r("car_rho_lims"), "assigning variable car_rho_lims");
      current_statement__ = 343;
      context__.validate_dims("data initialization","car","int",
          context__.to_vec());
      car = std::numeric_limits<int>::min();
      
      current_statement__ = 343;
      car = context__.vals_i("car")[(1 - 1)];
      current_statement__ = 343;
      current_statement__ = 343;
      check_greater_or_equal(function__, "car", car, 0);
      current_statement__ = 343;
      current_statement__ = 343;
      check_less_or_equal(function__, "car", car, 1);
      current_statement__ = 344;
      context__.validate_dims("data initialization","nImW_w","int",
          context__.to_vec());
      nImW_w = std::numeric_limits<int>::min();
      
      current_statement__ = 344;
      nImW_w = context__.vals_i("nImW_w")[(1 - 1)];
      current_statement__ = 345;
      context__.validate_dims("data initialization","nW","int",
          context__.to_vec());
      nW = std::numeric_limits<int>::min();
      
      current_statement__ = 345;
      nW = context__.vals_i("nW")[(1 - 1)];
      current_statement__ = 346;
      validate_non_negative_index("ImW_w", "nImW_w", nImW_w);
      current_statement__ = 347;
      context__.validate_dims("data initialization","ImW_w","double",
          context__.to_vec(nImW_w));
      ImW_w = Eigen::Matrix<double, -1, 1>(nImW_w);
      stan::math::fill(ImW_w, std::numeric_limits<double>::quiet_NaN());
      
      {
        std::vector<local_scalar_t__> ImW_w_flat__;
        current_statement__ = 347;
        assign(ImW_w_flat__, nil_index_list(), context__.vals_r("ImW_w"),
          "assigning variable ImW_w_flat__");
        current_statement__ = 347;
        pos__ = 1;
        current_statement__ = 347;
        for (int sym1__ = 1; sym1__ <= nImW_w; ++sym1__) {
          current_statement__ = 347;
          assign(ImW_w, cons_list(index_uni(sym1__), nil_index_list()),
            ImW_w_flat__[(pos__ - 1)], "assigning variable ImW_w");
          current_statement__ = 347;
          pos__ = (pos__ + 1);}
      }
      current_statement__ = 348;
      validate_non_negative_index("ImW_v", "nImW_w", nImW_w);
      current_statement__ = 349;
      context__.validate_dims("data initialization","ImW_v","int",
          context__.to_vec(nImW_w));
      ImW_v = std::vector<int>(nImW_w, std::numeric_limits<int>::min());
      
      current_statement__ = 349;
      assign(ImW_v, nil_index_list(), context__.vals_i("ImW_v"),
        "assigning variable ImW_v");
      current_statement__ = 350;
      validate_non_negative_index("ImW_u", "n + 1", (n + 1));
      current_statement__ = 351;
      context__.validate_dims("data initialization","ImW_u","int",
          context__.to_vec((n + 1)));
      ImW_u = std::vector<int>((n + 1), std::numeric_limits<int>::min());
      
      current_statement__ = 351;
      assign(ImW_u, nil_index_list(), context__.vals_i("ImW_u"),
        "assigning variable ImW_u");
      current_statement__ = 352;
      validate_non_negative_index("Widx", "nW", nW);
      current_statement__ = 353;
      context__.validate_dims("data initialization","Widx","int",
          context__.to_vec(nW));
      Widx = std::vector<int>(nW, std::numeric_limits<int>::min());
      
      current_statement__ = 353;
      assign(Widx, nil_index_list(), context__.vals_i("Widx"),
        "assigning variable Widx");
      current_statement__ = 354;
      validate_non_negative_index("eigenvalues_w", "n", n);
      current_statement__ = 355;
      context__.validate_dims("data initialization","eigenvalues_w","double",
          context__.to_vec(n));
      eigenvalues_w = Eigen::Matrix<double, -1, 1>(n);
      stan::math::fill(eigenvalues_w, std::numeric_limits<double>::quiet_NaN());
      
      {
        std::vector<local_scalar_t__> eigenvalues_w_flat__;
        current_statement__ = 355;
        assign(eigenvalues_w_flat__, nil_index_list(),
          context__.vals_r("eigenvalues_w"),
          "assigning variable eigenvalues_w_flat__");
        current_statement__ = 355;
        pos__ = 1;
        current_statement__ = 355;
        for (int sym1__ = 1; sym1__ <= n; ++sym1__) {
          current_statement__ = 355;
          assign(eigenvalues_w,
            cons_list(index_uni(sym1__), nil_index_list()),
            eigenvalues_w_flat__[(pos__ - 1)],
            "assigning variable eigenvalues_w");
          current_statement__ = 355;
          pos__ = (pos__ + 1);}
      }
      current_statement__ = 356;
      context__.validate_dims("data initialization","sar_rho_lims","double",
          context__.to_vec(2));
      sar_rho_lims = std::vector<double>(2, std::numeric_limits<double>::quiet_NaN());
      
      current_statement__ = 356;
      assign(sar_rho_lims, nil_index_list(),
        context__.vals_r("sar_rho_lims"), "assigning variable sar_rho_lims");
      current_statement__ = 357;
      context__.validate_dims("data initialization","sar","int",
          context__.to_vec());
      sar = std::numeric_limits<int>::min();
      
      current_statement__ = 357;
      sar = context__.vals_i("sar")[(1 - 1)];
      current_statement__ = 357;
      current_statement__ = 357;
      check_greater_or_equal(function__, "sar", sar, 0);
      current_statement__ = 357;
      current_statement__ = 357;
      check_less_or_equal(function__, "sar", sar, 1);
      current_statement__ = 358;
      has_theta = std::numeric_limits<int>::min();
      
      current_statement__ = 358;
      has_theta = logical_gt(type, 1);
      current_statement__ = 359;
      is_gaussian = std::numeric_limits<int>::min();
      
      current_statement__ = 360;
      is_student = std::numeric_limits<int>::min();
      
      current_statement__ = 361;
      is_poisson = std::numeric_limits<int>::min();
      
      current_statement__ = 362;
      is_binomial = std::numeric_limits<int>::min();
      
      current_statement__ = 363;
      is_auto_gaussian = std::numeric_limits<int>::min();
      
      current_statement__ = 364;
      has_sigma = std::numeric_limits<int>::min();
      
      current_statement__ = 365;
      has_offset = std::numeric_limits<int>::min();
      
      current_statement__ = 366;
      dx_all = std::numeric_limits<int>::min();
      
      current_statement__ = 367;
      has_me = std::numeric_limits<int>::min();
      
      current_statement__ = 368;
      is_gaussian = logical_eq(family, 1);
      current_statement__ = 369;
      is_student = logical_eq(family, 2);
      current_statement__ = 370;
      is_poisson = logical_eq(family, 3);
      current_statement__ = 371;
      is_binomial = logical_eq(family, 4);
      current_statement__ = 372;
      is_auto_gaussian = (primitive_value(logical_eq(family, 5)) ||
          primitive_value(logical_eq(family, 6)));
      current_statement__ = 373;
      has_sigma = logical_lt(family, 3);
      current_statement__ = 374;
      has_offset = logical_neq(sum(input_offset), 0);
      current_statement__ = 375;
      dx_all = (dx_obs + dx_me);
      current_statement__ = 376;
      has_me = logical_gt(dx_me, 0);
      current_statement__ = 359;
      current_statement__ = 359;
      check_greater_or_equal(function__, "is_gaussian", is_gaussian, 0);
      current_statement__ = 359;
      current_statement__ = 359;
      check_less_or_equal(function__, "is_gaussian", is_gaussian, 1);
      current_statement__ = 360;
      current_statement__ = 360;
      check_greater_or_equal(function__, "is_student", is_student, 0);
      current_statement__ = 360;
      current_statement__ = 360;
      check_less_or_equal(function__, "is_student", is_student, 1);
      current_statement__ = 361;
      current_statement__ = 361;
      check_greater_or_equal(function__, "is_poisson", is_poisson, 0);
      current_statement__ = 361;
      current_statement__ = 361;
      check_less_or_equal(function__, "is_poisson", is_poisson, 1);
      current_statement__ = 362;
      current_statement__ = 362;
      check_greater_or_equal(function__, "is_binomial", is_binomial, 0);
      current_statement__ = 362;
      current_statement__ = 362;
      check_less_or_equal(function__, "is_binomial", is_binomial, 1);
      current_statement__ = 363;
      current_statement__ = 363;
      check_greater_or_equal(function__, "is_auto_gaussian",
                             is_auto_gaussian, 0);
      current_statement__ = 363;
      current_statement__ = 363;
      check_less_or_equal(function__, "is_auto_gaussian", is_auto_gaussian, 1);
      current_statement__ = 364;
      current_statement__ = 364;
      check_greater_or_equal(function__, "has_sigma", has_sigma, 0);
      current_statement__ = 364;
      current_statement__ = 364;
      check_less_or_equal(function__, "has_sigma", has_sigma, 1);
      current_statement__ = 365;
      current_statement__ = 365;
      check_greater_or_equal(function__, "has_offset", has_offset, 0);
      current_statement__ = 365;
      current_statement__ = 365;
      check_less_or_equal(function__, "has_offset", has_offset, 1);
      current_statement__ = 366;
      current_statement__ = 366;
      check_greater_or_equal(function__, "dx_all", dx_all, 0);
      current_statement__ = 367;
      current_statement__ = 367;
      check_greater_or_equal(function__, "has_me", has_me, 0);
      current_statement__ = 377;
      validate_non_negative_index("alpha_phi", "m", m);
      current_statement__ = 378;
      phi_tilde_1dim__ = std::numeric_limits<int>::min();
      
      current_statement__ = 378;
      phi_tilde_1dim__ = (type ? n : 0);
      current_statement__ = 378;
      validate_non_negative_index("phi_tilde", "type ? n : 0",
                                  phi_tilde_1dim__);
      current_statement__ = 379;
      spatial_scale_1dim__ = std::numeric_limits<int>::min();
      
      current_statement__ = 379;
      spatial_scale_1dim__ = (type ? 1 : 0);
      current_statement__ = 379;
      validate_non_negative_index("spatial_scale", "type ? 1 : 0",
                                  spatial_scale_1dim__);
      current_statement__ = 380;
      theta_tilde_1dim__ = std::numeric_limits<int>::min();
      
      current_statement__ = 380;
      theta_tilde_1dim__ = (logical_gt(type, 1) ? n : 0);
      current_statement__ = 380;
      validate_non_negative_index("theta_tilde", "type > 1 ? n : 0",
                                  theta_tilde_1dim__);
      current_statement__ = 381;
      theta_scale_1dim__ = std::numeric_limits<int>::min();
      
      current_statement__ = 381;
      theta_scale_1dim__ = logical_eq(type, 2);
      current_statement__ = 381;
      validate_non_negative_index("theta_scale", "type == 2",
                                  theta_scale_1dim__);
      current_statement__ = 382;
      rho_1dim__ = std::numeric_limits<int>::min();
      
      current_statement__ = 382;
      rho_1dim__ = logical_eq(type, 3);
      current_statement__ = 382;
      validate_non_negative_index("rho", "type == 3", rho_1dim__);
      current_statement__ = 383;
      aux1_global_1dim__ = std::numeric_limits<int>::min();
      
      current_statement__ = 383;
      aux1_global_1dim__ = (dev ? 1 : 0);
      current_statement__ = 383;
      validate_non_negative_index("aux1_global", "dev ? 1 : 0",
                                  aux1_global_1dim__);
      current_statement__ = 384;
      aux2_global_1dim__ = std::numeric_limits<int>::min();
      
      current_statement__ = 384;
      aux2_global_1dim__ = (dev ? 1 : 0);
      current_statement__ = 384;
      validate_non_negative_index("aux2_global", "dev ? 1 : 0",
                                  aux2_global_1dim__);
      current_statement__ = 385;
      validate_non_negative_index("aux1_local", "dev", dev);
      current_statement__ = 386;
      validate_non_negative_index("aux2_local", "dev", dev);
      current_statement__ = 387;
      caux_1dim__ = std::numeric_limits<int>::min();
      
      current_statement__ = 387;
      caux_1dim__ = (dev ? 1 : 0);
      current_statement__ = 387;
      validate_non_negative_index("caux", "dev ? 1 : 0", caux_1dim__);
      current_statement__ = 388;
      validate_non_negative_index("z", "dev", dev);
      current_statement__ = 389;
      log_lambda_1dim__ = std::numeric_limits<int>::min();
      
      current_statement__ = 389;
      log_lambda_1dim__ = ((primitive_value((primitive_value(car) ||
                             primitive_value(sar))) && primitive_value(
                             logical_negation(is_auto_gaussian))) ? n : 0);
      current_statement__ = 389;
      validate_non_negative_index("log_lambda",
                                  "(car || sar) && !is_auto_gaussian ? n : 0",
                                  log_lambda_1dim__);
      current_statement__ = 390;
      car_scale_1dim__ = std::numeric_limits<int>::min();
      
      current_statement__ = 390;
      car_scale_1dim__ = (car ? 1 : 0);
      current_statement__ = 390;
      validate_non_negative_index("car_scale", "car ? 1 : 0",
                                  car_scale_1dim__);
      current_statement__ = 391;
      car_rho_1dim__ = std::numeric_limits<int>::min();
      
      current_statement__ = 391;
      car_rho_1dim__ = (car ? 1 : 0);
      current_statement__ = 391;
      validate_non_negative_index("car_rho", "car ? 1 : 0", car_rho_1dim__);
      current_statement__ = 392;
      sar_scale_1dim__ = std::numeric_limits<int>::min();
      
      current_statement__ = 392;
      sar_scale_1dim__ = (sar ? 1 : 0);
      current_statement__ = 392;
      validate_non_negative_index("sar_scale", "sar ? 1 : 0",
                                  sar_scale_1dim__);
      current_statement__ = 393;
      sar_rho_1dim__ = std::numeric_limits<int>::min();
      
      current_statement__ = 393;
      sar_rho_1dim__ = (sar ? 1 : 0);
      current_statement__ = 393;
      validate_non_negative_index("sar_rho", "sar ? 1 : 0", sar_rho_1dim__);
      current_statement__ = 394;
      validate_non_negative_index("gamma", "dwx", dwx);
      current_statement__ = 395;
      validate_non_negative_index("beta", "dx_all", dx_all);
      current_statement__ = 396;
      validate_non_negative_index("nu", "is_student", is_student);
      current_statement__ = 397;
      validate_non_negative_index("sigma", "has_sigma", has_sigma);
      current_statement__ = 398;
      validate_non_negative_index("alpha_re", "n_ids", n_ids);
      current_statement__ = 399;
      validate_non_negative_index("alpha_tau", "has_re", has_re);
      current_statement__ = 400;
      validate_non_negative_index("x_true", "dx_me", dx_me);
      current_statement__ = 401;
      validate_non_negative_index("x_true", "n", n);
      current_statement__ = 402;
      validate_non_negative_index("mu_x_true", "dx_me", dx_me);
      current_statement__ = 403;
      validate_non_negative_index("sigma_x_true", "dx_me", dx_me);
      current_statement__ = 404;
      car_rho_x_true_1dim__ = std::numeric_limits<int>::min();
      
      current_statement__ = 404;
      car_rho_x_true_1dim__ = (spatial_me ? dx_me : 0);
      current_statement__ = 404;
      validate_non_negative_index("car_rho_x_true", "spatial_me ? dx_me : 0",
                                  car_rho_x_true_1dim__);
      current_statement__ = 405;
      nu_x_true_1dim__ = std::numeric_limits<int>::min();
      
      current_statement__ = 405;
      nu_x_true_1dim__ = (spatial_me ? 0 : dx_me);
      current_statement__ = 405;
      validate_non_negative_index("nu_x_true", "spatial_me ? 0 : dx_me",
                                  nu_x_true_1dim__);
      current_statement__ = 406;
      validate_non_negative_index("beta_ev", "dev", dev);
      current_statement__ = 407;
      esf_1dim__ = std::numeric_limits<int>::min();
      
      current_statement__ = 407;
      esf_1dim__ = (dev ? n : 0);
      current_statement__ = 407;
      validate_non_negative_index("esf", "dev ? n : 0", esf_1dim__);
      current_statement__ = 408;
      error_scale_1dim__ = std::numeric_limits<int>::min();
      
      current_statement__ = 408;
      error_scale_1dim__ = (dev ? 1 : 0);
      current_statement__ = 408;
      validate_non_negative_index("error_scale", "dev ? 1 : 0",
                                  error_scale_1dim__);
      current_statement__ = 409;
      phi_1dim__ = std::numeric_limits<int>::min();
      
      current_statement__ = 409;
      phi_1dim__ = (type ? n : 0);
      current_statement__ = 409;
      validate_non_negative_index("phi", "type ? n : 0", phi_1dim__);
      current_statement__ = 410;
      theta_1dim__ = std::numeric_limits<int>::min();
      
      current_statement__ = 410;
      theta_1dim__ = (logical_gt(type, 1) ? n : 0);
      current_statement__ = 410;
      validate_non_negative_index("theta", "type > 1 ? n : 0", theta_1dim__);
      current_statement__ = 411;
      log_lambda_mu_1dim__ = std::numeric_limits<int>::min();
      
      current_statement__ = 411;
      log_lambda_mu_1dim__ = ((primitive_value(car) || primitive_value(sar))
                                ? n : 0);
      current_statement__ = 411;
      validate_non_negative_index("log_lambda_mu", "car || sar ? n : 0",
                                  log_lambda_mu_1dim__);
      current_statement__ = 412;
      validate_non_negative_index("x_all", "n", n);
      current_statement__ = 413;
      validate_non_negative_index("x_all", "dx_all", dx_all);
      current_statement__ = 414;
      validate_non_negative_index("fitted", "n", n);
      current_statement__ = 415;
      log_lik_1dim__ = std::numeric_limits<int>::min();
      
      current_statement__ = 415;
      log_lik_1dim__ = (is_auto_gaussian ? 1 : n);
      current_statement__ = 415;
      validate_non_negative_index("log_lik", "is_auto_gaussian ? 1 : n",
                                  log_lik_1dim__);
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
    }
    num_params_r__ = 0U;
    
    try {
      num_params_r__ += m;
      num_params_r__ += phi_tilde_1dim__;
      num_params_r__ += spatial_scale_1dim__;
      num_params_r__ += theta_tilde_1dim__;
      num_params_r__ += theta_scale_1dim__;
      num_params_r__ += rho_1dim__;
      num_params_r__ += aux1_global_1dim__;
      num_params_r__ += aux2_global_1dim__;
      num_params_r__ += dev;
      num_params_r__ += dev;
      num_params_r__ += caux_1dim__;
      num_params_r__ += dev;
      num_params_r__ += log_lambda_1dim__;
      num_params_r__ += car_scale_1dim__;
      num_params_r__ += car_rho_1dim__;
      num_params_r__ += sar_scale_1dim__;
      num_params_r__ += sar_rho_1dim__;
      num_params_r__ += 1;
      num_params_r__ += dwx;
      num_params_r__ += dx_all;
      num_params_r__ += is_student;
      num_params_r__ += has_sigma;
      num_params_r__ += n_ids;
      num_params_r__ += has_re;
      num_params_r__ += dx_me * n;
      num_params_r__ += dx_me;
      num_params_r__ += dx_me;
      num_params_r__ += car_rho_x_true_1dim__;
      num_params_r__ += nu_x_true_1dim__;
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
    }
  }
  template <bool propto__, bool jacobian__, typename VecR, typename VecI, stan::require_vector_like_t<VecR>* = nullptr, stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr>
  inline stan::scalar_type_t<VecR> log_prob_impl(VecR& params_r__,
                                                 VecI& params_i__,
                                                 std::ostream* pstream__ = nullptr) const {
    using T__ = stan::scalar_type_t<VecR>;
    using local_scalar_t__ = T__;
    T__ lp__(0.0);
    stan::math::accumulator<T__> lp_accum__;
    static const char* function__ = "model_foundation_namespace::log_prob";
(void) function__;  // suppress unused var warning
    stan::io::reader<local_scalar_t__> in__(params_r__, params_i__);
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    (void) DUMMY_VAR__;  // suppress unused var warning
    
    try {
      Eigen::Matrix<local_scalar_t__, -1, 1> alpha_phi;
      alpha_phi = Eigen::Matrix<local_scalar_t__, -1, 1>(m);
      stan::math::fill(alpha_phi, DUMMY_VAR__);
      
      current_statement__ = 1;
      alpha_phi = in__.vector(m);
      Eigen::Matrix<local_scalar_t__, -1, 1> phi_tilde;
      phi_tilde = Eigen::Matrix<local_scalar_t__, -1, 1>(phi_tilde_1dim__);
      stan::math::fill(phi_tilde, DUMMY_VAR__);
      
      current_statement__ = 2;
      phi_tilde = in__.vector(phi_tilde_1dim__);
      std::vector<local_scalar_t__> spatial_scale;
      spatial_scale = std::vector<local_scalar_t__>(spatial_scale_1dim__, DUMMY_VAR__);
      
      current_statement__ = 3;
      for (int sym1__ = 1; sym1__ <= spatial_scale_1dim__; ++sym1__) {
        current_statement__ = 3;
        assign(spatial_scale, cons_list(index_uni(sym1__), nil_index_list()),
          in__.scalar(), "assigning variable spatial_scale");}
      current_statement__ = 3;
      for (int sym1__ = 1; sym1__ <= spatial_scale_1dim__; ++sym1__) {
        current_statement__ = 3;
        if (jacobian__) {
          current_statement__ = 3;
          assign(spatial_scale,
            cons_list(index_uni(sym1__), nil_index_list()),
            stan::math::lb_constrain(spatial_scale[(sym1__ - 1)], 0, lp__),
            "assigning variable spatial_scale");
        } else {
          current_statement__ = 3;
          assign(spatial_scale,
            cons_list(index_uni(sym1__), nil_index_list()),
            stan::math::lb_constrain(spatial_scale[(sym1__ - 1)], 0),
            "assigning variable spatial_scale");
        }}
      Eigen::Matrix<local_scalar_t__, -1, 1> theta_tilde;
      theta_tilde = Eigen::Matrix<local_scalar_t__, -1, 1>(theta_tilde_1dim__);
      stan::math::fill(theta_tilde, DUMMY_VAR__);
      
      current_statement__ = 4;
      theta_tilde = in__.vector(theta_tilde_1dim__);
      std::vector<local_scalar_t__> theta_scale;
      theta_scale = std::vector<local_scalar_t__>(theta_scale_1dim__, DUMMY_VAR__);
      
      current_statement__ = 5;
      for (int sym1__ = 1; sym1__ <= theta_scale_1dim__; ++sym1__) {
        current_statement__ = 5;
        assign(theta_scale, cons_list(index_uni(sym1__), nil_index_list()),
          in__.scalar(), "assigning variable theta_scale");}
      current_statement__ = 5;
      for (int sym1__ = 1; sym1__ <= theta_scale_1dim__; ++sym1__) {
        current_statement__ = 5;
        if (jacobian__) {
          current_statement__ = 5;
          assign(theta_scale, cons_list(index_uni(sym1__), nil_index_list()),
            stan::math::lb_constrain(theta_scale[(sym1__ - 1)], 0, lp__),
            "assigning variable theta_scale");
        } else {
          current_statement__ = 5;
          assign(theta_scale, cons_list(index_uni(sym1__), nil_index_list()),
            stan::math::lb_constrain(theta_scale[(sym1__ - 1)], 0),
            "assigning variable theta_scale");
        }}
      std::vector<local_scalar_t__> rho;
      rho = std::vector<local_scalar_t__>(rho_1dim__, DUMMY_VAR__);
      
      current_statement__ = 6;
      for (int sym1__ = 1; sym1__ <= rho_1dim__; ++sym1__) {
        current_statement__ = 6;
        assign(rho, cons_list(index_uni(sym1__), nil_index_list()),
          in__.scalar(), "assigning variable rho");}
      current_statement__ = 6;
      for (int sym1__ = 1; sym1__ <= rho_1dim__; ++sym1__) {
        current_statement__ = 6;
        if (jacobian__) {
          current_statement__ = 6;
          assign(rho, cons_list(index_uni(sym1__), nil_index_list()),
            stan::math::lub_constrain(rho[(sym1__ - 1)], 0, 1, lp__),
            "assigning variable rho");
        } else {
          current_statement__ = 6;
          assign(rho, cons_list(index_uni(sym1__), nil_index_list()),
            stan::math::lub_constrain(rho[(sym1__ - 1)], 0, 1),
            "assigning variable rho");
        }}
      std::vector<local_scalar_t__> aux1_global;
      aux1_global = std::vector<local_scalar_t__>(aux1_global_1dim__, DUMMY_VAR__);
      
      current_statement__ = 7;
      for (int sym1__ = 1; sym1__ <= aux1_global_1dim__; ++sym1__) {
        current_statement__ = 7;
        assign(aux1_global, cons_list(index_uni(sym1__), nil_index_list()),
          in__.scalar(), "assigning variable aux1_global");}
      current_statement__ = 7;
      for (int sym1__ = 1; sym1__ <= aux1_global_1dim__; ++sym1__) {
        current_statement__ = 7;
        if (jacobian__) {
          current_statement__ = 7;
          assign(aux1_global, cons_list(index_uni(sym1__), nil_index_list()),
            stan::math::lb_constrain(aux1_global[(sym1__ - 1)], 0, lp__),
            "assigning variable aux1_global");
        } else {
          current_statement__ = 7;
          assign(aux1_global, cons_list(index_uni(sym1__), nil_index_list()),
            stan::math::lb_constrain(aux1_global[(sym1__ - 1)], 0),
            "assigning variable aux1_global");
        }}
      std::vector<local_scalar_t__> aux2_global;
      aux2_global = std::vector<local_scalar_t__>(aux2_global_1dim__, DUMMY_VAR__);
      
      current_statement__ = 8;
      for (int sym1__ = 1; sym1__ <= aux2_global_1dim__; ++sym1__) {
        current_statement__ = 8;
        assign(aux2_global, cons_list(index_uni(sym1__), nil_index_list()),
          in__.scalar(), "assigning variable aux2_global");}
      current_statement__ = 8;
      for (int sym1__ = 1; sym1__ <= aux2_global_1dim__; ++sym1__) {
        current_statement__ = 8;
        if (jacobian__) {
          current_statement__ = 8;
          assign(aux2_global, cons_list(index_uni(sym1__), nil_index_list()),
            stan::math::lb_constrain(aux2_global[(sym1__ - 1)], 0, lp__),
            "assigning variable aux2_global");
        } else {
          current_statement__ = 8;
          assign(aux2_global, cons_list(index_uni(sym1__), nil_index_list()),
            stan::math::lb_constrain(aux2_global[(sym1__ - 1)], 0),
            "assigning variable aux2_global");
        }}
      Eigen::Matrix<local_scalar_t__, -1, 1> aux1_local;
      aux1_local = Eigen::Matrix<local_scalar_t__, -1, 1>(dev);
      stan::math::fill(aux1_local, DUMMY_VAR__);
      
      current_statement__ = 9;
      aux1_local = in__.vector(dev);
      current_statement__ = 9;
      for (int sym1__ = 1; sym1__ <= dev; ++sym1__) {
        current_statement__ = 9;
        if (jacobian__) {
          current_statement__ = 9;
          assign(aux1_local, cons_list(index_uni(sym1__), nil_index_list()),
            stan::math::lb_constrain(aux1_local[(sym1__ - 1)], 0, lp__),
            "assigning variable aux1_local");
        } else {
          current_statement__ = 9;
          assign(aux1_local, cons_list(index_uni(sym1__), nil_index_list()),
            stan::math::lb_constrain(aux1_local[(sym1__ - 1)], 0),
            "assigning variable aux1_local");
        }}
      Eigen::Matrix<local_scalar_t__, -1, 1> aux2_local;
      aux2_local = Eigen::Matrix<local_scalar_t__, -1, 1>(dev);
      stan::math::fill(aux2_local, DUMMY_VAR__);
      
      current_statement__ = 10;
      aux2_local = in__.vector(dev);
      current_statement__ = 10;
      for (int sym1__ = 1; sym1__ <= dev; ++sym1__) {
        current_statement__ = 10;
        if (jacobian__) {
          current_statement__ = 10;
          assign(aux2_local, cons_list(index_uni(sym1__), nil_index_list()),
            stan::math::lb_constrain(aux2_local[(sym1__ - 1)], 0, lp__),
            "assigning variable aux2_local");
        } else {
          current_statement__ = 10;
          assign(aux2_local, cons_list(index_uni(sym1__), nil_index_list()),
            stan::math::lb_constrain(aux2_local[(sym1__ - 1)], 0),
            "assigning variable aux2_local");
        }}
      std::vector<local_scalar_t__> caux;
      caux = std::vector<local_scalar_t__>(caux_1dim__, DUMMY_VAR__);
      
      current_statement__ = 11;
      for (int sym1__ = 1; sym1__ <= caux_1dim__; ++sym1__) {
        current_statement__ = 11;
        assign(caux, cons_list(index_uni(sym1__), nil_index_list()),
          in__.scalar(), "assigning variable caux");}
      current_statement__ = 11;
      for (int sym1__ = 1; sym1__ <= caux_1dim__; ++sym1__) {
        current_statement__ = 11;
        if (jacobian__) {
          current_statement__ = 11;
          assign(caux, cons_list(index_uni(sym1__), nil_index_list()),
            stan::math::lb_constrain(caux[(sym1__ - 1)], 0, lp__),
            "assigning variable caux");
        } else {
          current_statement__ = 11;
          assign(caux, cons_list(index_uni(sym1__), nil_index_list()),
            stan::math::lb_constrain(caux[(sym1__ - 1)], 0),
            "assigning variable caux");
        }}
      Eigen::Matrix<local_scalar_t__, -1, 1> z;
      z = Eigen::Matrix<local_scalar_t__, -1, 1>(dev);
      stan::math::fill(z, DUMMY_VAR__);
      
      current_statement__ = 12;
      z = in__.vector(dev);
      Eigen::Matrix<local_scalar_t__, -1, 1> log_lambda;
      log_lambda = Eigen::Matrix<local_scalar_t__, -1, 1>(log_lambda_1dim__);
      stan::math::fill(log_lambda, DUMMY_VAR__);
      
      current_statement__ = 13;
      log_lambda = in__.vector(log_lambda_1dim__);
      std::vector<local_scalar_t__> car_scale;
      car_scale = std::vector<local_scalar_t__>(car_scale_1dim__, DUMMY_VAR__);
      
      current_statement__ = 14;
      for (int sym1__ = 1; sym1__ <= car_scale_1dim__; ++sym1__) {
        current_statement__ = 14;
        assign(car_scale, cons_list(index_uni(sym1__), nil_index_list()),
          in__.scalar(), "assigning variable car_scale");}
      current_statement__ = 14;
      for (int sym1__ = 1; sym1__ <= car_scale_1dim__; ++sym1__) {
        current_statement__ = 14;
        if (jacobian__) {
          current_statement__ = 14;
          assign(car_scale, cons_list(index_uni(sym1__), nil_index_list()),
            stan::math::lb_constrain(car_scale[(sym1__ - 1)], 0, lp__),
            "assigning variable car_scale");
        } else {
          current_statement__ = 14;
          assign(car_scale, cons_list(index_uni(sym1__), nil_index_list()),
            stan::math::lb_constrain(car_scale[(sym1__ - 1)], 0),
            "assigning variable car_scale");
        }}
      std::vector<local_scalar_t__> car_rho;
      car_rho = std::vector<local_scalar_t__>(car_rho_1dim__, DUMMY_VAR__);
      
      current_statement__ = 15;
      for (int sym1__ = 1; sym1__ <= car_rho_1dim__; ++sym1__) {
        current_statement__ = 15;
        assign(car_rho, cons_list(index_uni(sym1__), nil_index_list()),
          in__.scalar(), "assigning variable car_rho");}
      current_statement__ = 15;
      for (int sym1__ = 1; sym1__ <= car_rho_1dim__; ++sym1__) {
        current_statement__ = 15;
        if (jacobian__) {
          current_statement__ = 15;
          assign(car_rho, cons_list(index_uni(sym1__), nil_index_list()),
            stan::math::lub_constrain(car_rho[(sym1__ - 1)],
              car_rho_lims[(1 - 1)], car_rho_lims[(2 - 1)], lp__),
            "assigning variable car_rho");
        } else {
          current_statement__ = 15;
          assign(car_rho, cons_list(index_uni(sym1__), nil_index_list()),
            stan::math::lub_constrain(car_rho[(sym1__ - 1)],
              car_rho_lims[(1 - 1)], car_rho_lims[(2 - 1)]),
            "assigning variable car_rho");
        }}
      std::vector<local_scalar_t__> sar_scale;
      sar_scale = std::vector<local_scalar_t__>(sar_scale_1dim__, DUMMY_VAR__);
      
      current_statement__ = 16;
      for (int sym1__ = 1; sym1__ <= sar_scale_1dim__; ++sym1__) {
        current_statement__ = 16;
        assign(sar_scale, cons_list(index_uni(sym1__), nil_index_list()),
          in__.scalar(), "assigning variable sar_scale");}
      current_statement__ = 16;
      for (int sym1__ = 1; sym1__ <= sar_scale_1dim__; ++sym1__) {
        current_statement__ = 16;
        if (jacobian__) {
          current_statement__ = 16;
          assign(sar_scale, cons_list(index_uni(sym1__), nil_index_list()),
            stan::math::lb_constrain(sar_scale[(sym1__ - 1)], 0, lp__),
            "assigning variable sar_scale");
        } else {
          current_statement__ = 16;
          assign(sar_scale, cons_list(index_uni(sym1__), nil_index_list()),
            stan::math::lb_constrain(sar_scale[(sym1__ - 1)], 0),
            "assigning variable sar_scale");
        }}
      std::vector<local_scalar_t__> sar_rho;
      sar_rho = std::vector<local_scalar_t__>(sar_rho_1dim__, DUMMY_VAR__);
      
      current_statement__ = 17;
      for (int sym1__ = 1; sym1__ <= sar_rho_1dim__; ++sym1__) {
        current_statement__ = 17;
        assign(sar_rho, cons_list(index_uni(sym1__), nil_index_list()),
          in__.scalar(), "assigning variable sar_rho");}
      current_statement__ = 17;
      for (int sym1__ = 1; sym1__ <= sar_rho_1dim__; ++sym1__) {
        current_statement__ = 17;
        if (jacobian__) {
          current_statement__ = 17;
          assign(sar_rho, cons_list(index_uni(sym1__), nil_index_list()),
            stan::math::lub_constrain(sar_rho[(sym1__ - 1)],
              sar_rho_lims[(1 - 1)], sar_rho_lims[(2 - 1)], lp__),
            "assigning variable sar_rho");
        } else {
          current_statement__ = 17;
          assign(sar_rho, cons_list(index_uni(sym1__), nil_index_list()),
            stan::math::lub_constrain(sar_rho[(sym1__ - 1)],
              sar_rho_lims[(1 - 1)], sar_rho_lims[(2 - 1)]),
            "assigning variable sar_rho");
        }}
      local_scalar_t__ intercept;
      intercept = DUMMY_VAR__;
      
      current_statement__ = 18;
      intercept = in__.scalar();
      Eigen::Matrix<local_scalar_t__, -1, 1> gamma;
      gamma = Eigen::Matrix<local_scalar_t__, -1, 1>(dwx);
      stan::math::fill(gamma, DUMMY_VAR__);
      
      current_statement__ = 19;
      gamma = in__.vector(dwx);
      Eigen::Matrix<local_scalar_t__, -1, 1> beta;
      beta = Eigen::Matrix<local_scalar_t__, -1, 1>(dx_all);
      stan::math::fill(beta, DUMMY_VAR__);
      
      current_statement__ = 20;
      beta = in__.vector(dx_all);
      std::vector<local_scalar_t__> nu;
      nu = std::vector<local_scalar_t__>(is_student, DUMMY_VAR__);
      
      current_statement__ = 21;
      for (int sym1__ = 1; sym1__ <= is_student; ++sym1__) {
        current_statement__ = 21;
        assign(nu, cons_list(index_uni(sym1__), nil_index_list()),
          in__.scalar(), "assigning variable nu");}
      current_statement__ = 21;
      for (int sym1__ = 1; sym1__ <= is_student; ++sym1__) {
        current_statement__ = 21;
        if (jacobian__) {
          current_statement__ = 21;
          assign(nu, cons_list(index_uni(sym1__), nil_index_list()),
            stan::math::lb_constrain(nu[(sym1__ - 1)], 0, lp__),
            "assigning variable nu");
        } else {
          current_statement__ = 21;
          assign(nu, cons_list(index_uni(sym1__), nil_index_list()),
            stan::math::lb_constrain(nu[(sym1__ - 1)], 0),
            "assigning variable nu");
        }}
      std::vector<local_scalar_t__> sigma;
      sigma = std::vector<local_scalar_t__>(has_sigma, DUMMY_VAR__);
      
      current_statement__ = 22;
      for (int sym1__ = 1; sym1__ <= has_sigma; ++sym1__) {
        current_statement__ = 22;
        assign(sigma, cons_list(index_uni(sym1__), nil_index_list()),
          in__.scalar(), "assigning variable sigma");}
      current_statement__ = 22;
      for (int sym1__ = 1; sym1__ <= has_sigma; ++sym1__) {
        current_statement__ = 22;
        if (jacobian__) {
          current_statement__ = 22;
          assign(sigma, cons_list(index_uni(sym1__), nil_index_list()),
            stan::math::lb_constrain(sigma[(sym1__ - 1)], 0, lp__),
            "assigning variable sigma");
        } else {
          current_statement__ = 22;
          assign(sigma, cons_list(index_uni(sym1__), nil_index_list()),
            stan::math::lb_constrain(sigma[(sym1__ - 1)], 0),
            "assigning variable sigma");
        }}
      Eigen::Matrix<local_scalar_t__, -1, 1> alpha_re;
      alpha_re = Eigen::Matrix<local_scalar_t__, -1, 1>(n_ids);
      stan::math::fill(alpha_re, DUMMY_VAR__);
      
      current_statement__ = 23;
      alpha_re = in__.vector(n_ids);
      std::vector<local_scalar_t__> alpha_tau;
      alpha_tau = std::vector<local_scalar_t__>(has_re, DUMMY_VAR__);
      
      current_statement__ = 24;
      for (int sym1__ = 1; sym1__ <= has_re; ++sym1__) {
        current_statement__ = 24;
        assign(alpha_tau, cons_list(index_uni(sym1__), nil_index_list()),
          in__.scalar(), "assigning variable alpha_tau");}
      current_statement__ = 24;
      for (int sym1__ = 1; sym1__ <= has_re; ++sym1__) {
        current_statement__ = 24;
        if (jacobian__) {
          current_statement__ = 24;
          assign(alpha_tau, cons_list(index_uni(sym1__), nil_index_list()),
            stan::math::lb_constrain(alpha_tau[(sym1__ - 1)], 0, lp__),
            "assigning variable alpha_tau");
        } else {
          current_statement__ = 24;
          assign(alpha_tau, cons_list(index_uni(sym1__), nil_index_list()),
            stan::math::lb_constrain(alpha_tau[(sym1__ - 1)], 0),
            "assigning variable alpha_tau");
        }}
      std::vector<Eigen::Matrix<local_scalar_t__, -1, 1>> x_true;
      x_true = std::vector<Eigen::Matrix<local_scalar_t__, -1, 1>>(dx_me, Eigen::Matrix<local_scalar_t__, -1, 1>(n));
      stan::math::fill(x_true, DUMMY_VAR__);
      
      current_statement__ = 25;
      for (int sym1__ = 1; sym1__ <= dx_me; ++sym1__) {
        current_statement__ = 25;
        assign(x_true, cons_list(index_uni(sym1__), nil_index_list()),
          in__.vector(n), "assigning variable x_true");}
      current_statement__ = 25;
      for (int sym1__ = 1; sym1__ <= dx_me; ++sym1__) {
        current_statement__ = 25;
        for (int sym2__ = 1; sym2__ <= n; ++sym2__) {
          current_statement__ = 25;
          if (jacobian__) {
            current_statement__ = 25;
            assign(x_true,
              cons_list(index_uni(sym1__),
                cons_list(index_uni(sym2__), nil_index_list())),
              stan::math::lub_constrain(x_true[(sym1__ - 1)][(sym2__ - 1)],
                bounds[(1 - 1)], bounds[(2 - 1)], lp__),
              "assigning variable x_true");
          } else {
            current_statement__ = 25;
            assign(x_true,
              cons_list(index_uni(sym1__),
                cons_list(index_uni(sym2__), nil_index_list())),
              stan::math::lub_constrain(x_true[(sym1__ - 1)][(sym2__ - 1)],
                bounds[(1 - 1)], bounds[(2 - 1)]),
              "assigning variable x_true");
          }}}
      Eigen::Matrix<local_scalar_t__, -1, 1> mu_x_true;
      mu_x_true = Eigen::Matrix<local_scalar_t__, -1, 1>(dx_me);
      stan::math::fill(mu_x_true, DUMMY_VAR__);
      
      current_statement__ = 26;
      mu_x_true = in__.vector(dx_me);
      Eigen::Matrix<local_scalar_t__, -1, 1> sigma_x_true;
      sigma_x_true = Eigen::Matrix<local_scalar_t__, -1, 1>(dx_me);
      stan::math::fill(sigma_x_true, DUMMY_VAR__);
      
      current_statement__ = 27;
      sigma_x_true = in__.vector(dx_me);
      current_statement__ = 27;
      for (int sym1__ = 1; sym1__ <= dx_me; ++sym1__) {
        current_statement__ = 27;
        if (jacobian__) {
          current_statement__ = 27;
          assign(sigma_x_true,
            cons_list(index_uni(sym1__), nil_index_list()),
            stan::math::lb_constrain(sigma_x_true[(sym1__ - 1)], 0, lp__),
            "assigning variable sigma_x_true");
        } else {
          current_statement__ = 27;
          assign(sigma_x_true,
            cons_list(index_uni(sym1__), nil_index_list()),
            stan::math::lb_constrain(sigma_x_true[(sym1__ - 1)], 0),
            "assigning variable sigma_x_true");
        }}
      Eigen::Matrix<local_scalar_t__, -1, 1> car_rho_x_true;
      car_rho_x_true = Eigen::Matrix<local_scalar_t__, -1, 1>(car_rho_x_true_1dim__);
      stan::math::fill(car_rho_x_true, DUMMY_VAR__);
      
      current_statement__ = 28;
      car_rho_x_true = in__.vector(car_rho_x_true_1dim__);
      current_statement__ = 28;
      for (int sym1__ = 1; sym1__ <= car_rho_x_true_1dim__; ++sym1__) {
        current_statement__ = 28;
        if (jacobian__) {
          current_statement__ = 28;
          assign(car_rho_x_true,
            cons_list(index_uni(sym1__), nil_index_list()),
            stan::math::lub_constrain(car_rho_x_true[(sym1__ - 1)],
              prior_rhox_true[(1 - 1)], prior_rhox_true[(2 - 1)], lp__),
            "assigning variable car_rho_x_true");
        } else {
          current_statement__ = 28;
          assign(car_rho_x_true,
            cons_list(index_uni(sym1__), nil_index_list()),
            stan::math::lub_constrain(car_rho_x_true[(sym1__ - 1)],
              prior_rhox_true[(1 - 1)], prior_rhox_true[(2 - 1)]),
            "assigning variable car_rho_x_true");
        }}
      Eigen::Matrix<local_scalar_t__, -1, 1> nu_x_true;
      nu_x_true = Eigen::Matrix<local_scalar_t__, -1, 1>(nu_x_true_1dim__);
      stan::math::fill(nu_x_true, DUMMY_VAR__);
      
      current_statement__ = 29;
      nu_x_true = in__.vector(nu_x_true_1dim__);
      current_statement__ = 29;
      for (int sym1__ = 1; sym1__ <= nu_x_true_1dim__; ++sym1__) {
        current_statement__ = 29;
        if (jacobian__) {
          current_statement__ = 29;
          assign(nu_x_true, cons_list(index_uni(sym1__), nil_index_list()),
            stan::math::lb_constrain(nu_x_true[(sym1__ - 1)], 0, lp__),
            "assigning variable nu_x_true");
        } else {
          current_statement__ = 29;
          assign(nu_x_true, cons_list(index_uni(sym1__), nil_index_list()),
            stan::math::lb_constrain(nu_x_true[(sym1__ - 1)], 0),
            "assigning variable nu_x_true");
        }}
      Eigen::Matrix<local_scalar_t__, -1, 1> beta_ev;
      beta_ev = Eigen::Matrix<local_scalar_t__, -1, 1>(dev);
      stan::math::fill(beta_ev, DUMMY_VAR__);
      
      Eigen::Matrix<local_scalar_t__, -1, 1> esf;
      esf = Eigen::Matrix<local_scalar_t__, -1, 1>(esf_1dim__);
      stan::math::fill(esf, DUMMY_VAR__);
      
      std::vector<local_scalar_t__> error_scale;
      error_scale = std::vector<local_scalar_t__>(error_scale_1dim__, DUMMY_VAR__);
      
      Eigen::Matrix<local_scalar_t__, -1, 1> phi;
      phi = Eigen::Matrix<local_scalar_t__, -1, 1>(phi_1dim__);
      stan::math::fill(phi, DUMMY_VAR__);
      
      Eigen::Matrix<local_scalar_t__, -1, 1> theta;
      theta = Eigen::Matrix<local_scalar_t__, -1, 1>(theta_1dim__);
      stan::math::fill(theta, DUMMY_VAR__);
      
      Eigen::Matrix<local_scalar_t__, -1, 1> log_lambda_mu;
      log_lambda_mu = Eigen::Matrix<local_scalar_t__, -1, 1>(log_lambda_mu_1dim__);
      stan::math::fill(log_lambda_mu, DUMMY_VAR__);
      
      Eigen::Matrix<local_scalar_t__, -1, -1> x_all;
      x_all = Eigen::Matrix<local_scalar_t__, -1, -1>(n, dx_all);
      stan::math::fill(x_all, DUMMY_VAR__);
      
      Eigen::Matrix<local_scalar_t__, -1, 1> fitted;
      fitted = Eigen::Matrix<local_scalar_t__, -1, 1>(n);
      stan::math::fill(fitted, DUMMY_VAR__);
      
      current_statement__ = 39;
      if (dx_obs) {
        current_statement__ = 38;
        assign(x_all,
          cons_list(index_omni(),
            cons_list(index_multi(x_obs_idx), nil_index_list())), x_obs,
          "assigning variable x_all");
      } 
      current_statement__ = 42;
      if (dx_me) {
        current_statement__ = 41;
        for (int j = 1; j <= dx_me; ++j) {
          current_statement__ = 40;
          assign(x_all,
            cons_list(index_omni(),
              cons_list(index_uni(x_me_idx[(j - 1)]), nil_index_list())),
            x_true[(j - 1)], "assigning variable x_all");}
      } 
      current_statement__ = 45;
      if (center_x) {
        current_statement__ = 44;
        for (int j = 1; j <= dx_all; ++j) {
          current_statement__ = 43;
          assign(x_all,
            cons_list(index_omni(),
              cons_list(index_uni(j), nil_index_list())),
            subtract(
              stan::model::deep_copy(
                rvalue(x_all,
                  cons_list(index_omni(),
                    cons_list(index_uni(j), nil_index_list())), "x_all")),
              mean(
                rvalue(x_all,
                  cons_list(index_omni(),
                    cons_list(index_uni(j), nil_index_list())), "x_all"))),
            "assigning variable x_all");}
      } 
      current_statement__ = 47;
      if (logical_negation(car)) {
        current_statement__ = 46;
        assign(fitted, nil_index_list(), add(input_offset, intercept),
          "assigning variable fitted");
      } 
      current_statement__ = 53;
      if (logical_eq(type, 1)) {
        current_statement__ = 48;
        assign(phi, nil_index_list(),
          make_phi(phi_tilde, spatial_scale[(1 - 1)], 1,
            inv_sqrt_scale_factor, n, k, group_size, group_idx, pstream__),
          "assigning variable phi");
        current_statement__ = 50;
        if (m) {
          current_statement__ = 49;
          assign(phi, nil_index_list(),
            add(stan::model::deep_copy(phi), multiply(A, alpha_phi)),
            "assigning variable phi");
        } 
        current_statement__ = 51;
        assign(fitted, nil_index_list(),
          add(stan::model::deep_copy(fitted), phi),
          "assigning variable fitted");
      } 
      current_statement__ = 60;
      if (logical_eq(type, 2)) {
        current_statement__ = 54;
        assign(theta, nil_index_list(),
          multiply(theta_tilde, theta_scale[(1 - 1)]),
          "assigning variable theta");
        current_statement__ = 55;
        assign(phi, nil_index_list(),
          make_phi(phi_tilde, spatial_scale[(1 - 1)], 1,
            inv_sqrt_scale_factor, n, k, group_size, group_idx, pstream__),
          "assigning variable phi");
        current_statement__ = 57;
        if (m) {
          current_statement__ = 56;
          assign(phi, nil_index_list(),
            add(stan::model::deep_copy(phi), multiply(A, alpha_phi)),
            "assigning variable phi");
        } 
        current_statement__ = 58;
        assign(fitted, nil_index_list(),
          add(stan::model::deep_copy(fitted),
            convolve_bym(phi, theta, n, k, group_size, group_idx, pstream__)),
          "assigning variable fitted");
      } 
      current_statement__ = 67;
      if (logical_eq(type, 3)) {
        current_statement__ = 61;
        assign(theta, nil_index_list(),
          multiply(
            (spatial_scale[(1 - 1)] * stan::math::sqrt((1 - rho[(1 - 1)]))),
            theta_tilde), "assigning variable theta");
        current_statement__ = 62;
        assign(phi, nil_index_list(),
          make_phi(phi_tilde, spatial_scale[(1 - 1)], rho[(1 - 1)],
            inv_sqrt_scale_factor, n, k, group_size, group_idx, pstream__),
          "assigning variable phi");
        current_statement__ = 64;
        if (m) {
          current_statement__ = 63;
          assign(phi, nil_index_list(),
            add(stan::model::deep_copy(phi), multiply(A, alpha_phi)),
            "assigning variable phi");
        } 
        current_statement__ = 65;
        assign(fitted, nil_index_list(),
          add(stan::model::deep_copy(fitted),
            convolve_bym2(phi_tilde, theta_tilde, spatial_scale[(1 - 1)], n,
              k, group_size, group_idx, rho[(1 - 1)],
              inv_sqrt_scale_factor, pstream__)), "assigning variable fitted");
      } 
      current_statement__ = 77;
      if (dev) {
        current_statement__ = 72;
        if (has_sigma) {
          current_statement__ = 70;
          assign(error_scale, cons_list(index_uni(1), nil_index_list()),
            sigma[(1 - 1)], "assigning variable error_scale");
        } else {
          current_statement__ = 68;
          assign(error_scale, cons_list(index_uni(1), nil_index_list()), 1,
            "assigning variable error_scale");
        }
        current_statement__ = 73;
        assign(beta_ev, nil_index_list(),
          rhs_prior(dev, z, aux1_global[(1 - 1)], aux2_global[(1 - 1)],
            aux1_local, aux2_local, caux[(1 - 1)], global_scale, slab_scale,
            error_scale[(1 - 1)], pstream__), "assigning variable beta_ev");
        current_statement__ = 74;
        assign(esf, nil_index_list(), multiply(EV, beta_ev),
          "assigning variable esf");
        current_statement__ = 75;
        assign(fitted, nil_index_list(),
          add(stan::model::deep_copy(fitted), esf),
          "assigning variable fitted");
      } 
      current_statement__ = 96;
      if ((primitive_value(car) || primitive_value(sar))) {
        current_statement__ = 78;
        assign(log_lambda_mu, nil_index_list(), rep_vector(intercept, n),
          "assigning variable log_lambda_mu");
        current_statement__ = 83;
        if (has_re) {
          current_statement__ = 81;
          for (int i = 1; i <= n; ++i) {
            current_statement__ = 79;
            assign(log_lambda_mu, cons_list(index_uni(i), nil_index_list()),
              (log_lambda_mu[(i - 1)] + alpha_re[(id[(i - 1)] - 1)]),
              "assigning variable log_lambda_mu");}
        } 
        current_statement__ = 87;
        if (dwx) {
          current_statement__ = 85;
          for (int i = 1; i <= dwx; ++i) {
            current_statement__ = 84;
            assign(log_lambda_mu, nil_index_list(),
              add(stan::model::deep_copy(log_lambda_mu),
                multiply(
                  csr_matrix_times_vector(n, n, W_w, W_v, W_u,
                    rvalue(x_all,
                      cons_list(index_omni(),
                        cons_list(index_uni(wx_idx[(i - 1)]),
                          nil_index_list())), "x_all")), gamma[(i - 1)])),
              "assigning variable log_lambda_mu");}
        } 
        current_statement__ = 89;
        if (dx_all) {
          current_statement__ = 88;
          assign(log_lambda_mu, nil_index_list(),
            add(stan::model::deep_copy(log_lambda_mu), multiply(x_all, beta)),
            "assigning variable log_lambda_mu");
        } 
        current_statement__ = 94;
        if (is_auto_gaussian) {
          current_statement__ = 92;
          assign(fitted, nil_index_list(), add(input_offset, log_lambda_mu),
            "assigning variable fitted");
        } else {
          current_statement__ = 90;
          assign(fitted, nil_index_list(), add(input_offset, log_lambda),
            "assigning variable fitted");
        }
      } 
      current_statement__ = 109;
      if ((primitive_value(logical_negation(car)) && primitive_value(
          logical_negation(sar)))) {
        current_statement__ = 101;
        if (has_re) {
          current_statement__ = 99;
          for (int i = 1; i <= n; ++i) {
            current_statement__ = 97;
            assign(fitted, cons_list(index_uni(i), nil_index_list()),
              (fitted[(i - 1)] + alpha_re[(id[(i - 1)] - 1)]),
              "assigning variable fitted");}
        } 
        current_statement__ = 105;
        if (dwx) {
          current_statement__ = 103;
          for (int i = 1; i <= dwx; ++i) {
            current_statement__ = 102;
            assign(fitted, nil_index_list(),
              add(stan::model::deep_copy(fitted),
                multiply(
                  csr_matrix_times_vector(n, n, W_w, W_v, W_u,
                    rvalue(x_all,
                      cons_list(index_omni(),
                        cons_list(index_uni(wx_idx[(i - 1)]),
                          nil_index_list())), "x_all")), gamma[(i - 1)])),
              "assigning variable fitted");}
        } 
        current_statement__ = 107;
        if (dx_all) {
          current_statement__ = 106;
          assign(fitted, nil_index_list(),
            add(stan::model::deep_copy(fitted), multiply(x_all, beta)),
            "assigning variable fitted");
        } 
      } 
      current_statement__ = 111;
      if (is_binomial) {
        current_statement__ = 110;
        assign(fitted, nil_index_list(),
          inv_logit(stan::model::deep_copy(fitted)),
          "assigning variable fitted");
      } 
      current_statement__ = 113;
      if (is_poisson) {
        current_statement__ = 112;
        assign(fitted, nil_index_list(),
          stan::math::exp(stan::model::deep_copy(fitted)),
          "assigning variable fitted");
      } 
      {
        current_statement__ = 135;
        validate_non_negative_index("x_true_transform", "dx_me", dx_me);
        current_statement__ = 136;
        validate_non_negative_index("x_true_transform", "n", n);
        std::vector<Eigen::Matrix<local_scalar_t__, -1, 1>> x_true_transform;
        x_true_transform = std::vector<Eigen::Matrix<local_scalar_t__, -1, 1>>(dx_me, Eigen::Matrix<local_scalar_t__, -1, 1>(n));
        stan::math::fill(x_true_transform, DUMMY_VAR__);
        
        current_statement__ = 138;
        assign(x_true_transform, nil_index_list(), x_true,
          "assigning variable x_true_transform");
        current_statement__ = 139;
        lp_accum__.add(
          normal_lpdf<false>(intercept, prior_alpha[(1 - 1)],
            prior_alpha[(2 - 1)]));
        current_statement__ = 141;
        if (dx_all) {
          current_statement__ = 140;
          lp_accum__.add(
            normal_lpdf<false>(append_row(gamma, beta), prior_beta_location,
              prior_beta_scale));
        } 
        current_statement__ = 143;
        if (has_sigma) {
          current_statement__ = 142;
          lp_accum__.add(
            student_t_lpdf<false>(sigma, prior_sigma[(1 - 1)],
              prior_sigma[(2 - 1)], prior_sigma[(3 - 1)]));
        } 
        current_statement__ = 145;
        if (is_student) {
          current_statement__ = 144;
          lp_accum__.add(
            gamma_lpdf<false>(nu[(1 - 1)], prior_t_nu[(1 - 1)],
              prior_t_nu[(2 - 1)]));
        } 
        current_statement__ = 167;
        if (dx_me) {
          current_statement__ = 163;
          if (spatial_me) {
            current_statement__ = 161;
            for (int j = 1; j <= dx_me; ++j) {
              current_statement__ = 154;
              validate_non_negative_index("mu_x_true_tmp", "n", n);
              Eigen::Matrix<local_scalar_t__, -1, 1> mu_x_true_tmp;
              mu_x_true_tmp = Eigen::Matrix<local_scalar_t__, -1, 1>(n);
              stan::math::fill(mu_x_true_tmp, DUMMY_VAR__);
              
              current_statement__ = 155;
              assign(mu_x_true_tmp, nil_index_list(),
                rep_vector(mu_x_true[(j - 1)], n),
                "assigning variable mu_x_true_tmp");
              current_statement__ = 156;
              lp_accum__.add(
                normal_lpdf<false>(x_me[(j - 1)], x_true[(j - 1)],
                  sigma_me[(j - 1)]));
              current_statement__ = 158;
              if (logical_gt(use_logit[(j - 1)], 0)) {
                current_statement__ = 157;
                assign(x_true_transform,
                  cons_list(index_uni(j), nil_index_list()),
                  logit(x_true[(j - 1)]),
                  "assigning variable x_true_transform");
              } 
              current_statement__ = 159;
              lp_accum__.add(
                auto_normal_lpdf<false>(x_true_transform[(j - 1)],
                  mu_x_true_tmp, sigma_x_true[(j - 1)],
                  car_rho_x_true[(j - 1)], Ax_w, Ax_v, Ax_u, Cidx, Delta_inv,
                  log_det_Delta_inv, lambda, n, WCAR, pstream__));}
          } else {
            current_statement__ = 152;
            for (int j = 1; j <= dx_me; ++j) {
              current_statement__ = 146;
              lp_accum__.add(
                normal_lpdf<false>(x_me[(j - 1)], x_true[(j - 1)],
                  sigma_me[(j - 1)]));
              current_statement__ = 148;
              if (logical_gt(use_logit[(j - 1)], 0)) {
                current_statement__ = 147;
                assign(x_true_transform,
                  cons_list(index_uni(j), nil_index_list()),
                  logit(x_true[(j - 1)]),
                  "assigning variable x_true_transform");
              } 
              current_statement__ = 149;
              lp_accum__.add(
                student_t_lpdf<false>(x_true_transform[(j - 1)],
                  nu_x_true[(j - 1)], mu_x_true[(j - 1)],
                  sigma_x_true[(j - 1)]));
              current_statement__ = 150;
              lp_accum__.add(
                gamma_lpdf<false>(nu_x_true[(j - 1)],
                  prior_nux_true_alpha[(j - 1)],
                  prior_nux_true_beta[(j - 1)]));}
          }
          current_statement__ = 164;
          lp_accum__.add(
            normal_lpdf<false>(mu_x_true, prior_mux_true_location,
              prior_mux_true_scale));
          current_statement__ = 165;
          lp_accum__.add(
            student_t_lpdf<false>(sigma_x_true, prior_sigmax_true_df,
              prior_sigmax_true_location, prior_sigmax_true_scale));
        } 
        current_statement__ = 171;
        if (has_re) {
          current_statement__ = 168;
          lp_accum__.add(
            normal_lpdf<false>(alpha_re, 0, alpha_tau[(has_re - 1)]));
          current_statement__ = 169;
          lp_accum__.add(
            student_t_lpdf<false>(alpha_tau[(has_re - 1)],
              prior_alpha_tau[(1 - 1)], prior_alpha_tau[(2 - 1)],
              prior_alpha_tau[(3 - 1)]));
        } 
        current_statement__ = 184;
        if (logical_negation(prior_only)) {
          current_statement__ = 173;
          if (is_student) {
            current_statement__ = 172;
            lp_accum__.add(
              student_t_lpdf<false>(y, nu[(1 - 1)], fitted,
                sigma[(has_sigma - 1)]));
          } 
          current_statement__ = 175;
          if (is_gaussian) {
            current_statement__ = 174;
            lp_accum__.add(
              normal_lpdf<false>(y, fitted, sigma[(has_sigma - 1)]));
          } 
          current_statement__ = 180;
          if (is_poisson) {
            current_statement__ = 176;
            lp_accum__.add(
              poisson_lpmf<false>(
                rvalue(y_int,
                  cons_list(index_multi(y_obs_idx), nil_index_list()),
                  "y_int"),
                rvalue(fitted,
                  cons_list(index_multi(y_obs_idx), nil_index_list()),
                  "fitted")));
            current_statement__ = 178;
            if (logical_gt(censor_point, 0)) {
              current_statement__ = 177;
              lp_accum__.add(
                poisson_lcdf(censor_point,
                  rvalue(fitted,
                    cons_list(index_multi(y_mis_idx), nil_index_list()),
                    "fitted")));
            } 
          } 
          current_statement__ = 182;
          if (is_binomial) {
            current_statement__ = 181;
            lp_accum__.add(binomial_lpmf<false>(y_int, trials, fitted));
          } 
        } 
        current_statement__ = 195;
        if (type) {
          current_statement__ = 189;
          if (has_theta) {
            current_statement__ = 185;
            lp_accum__.add(std_normal_lpdf<false>(theta_tilde));
            current_statement__ = 187;
            if (logical_eq(type, 2)) {
              current_statement__ = 186;
              lp_accum__.add(std_normal_lpdf<false>(theta_scale[(1 - 1)]));
            } 
          } 
          current_statement__ = 190;
          lp_accum__.add(std_normal_lpdf<false>(spatial_scale[(1 - 1)]));
          current_statement__ = 191;
          lp_accum__.add(
            icar_normal_lpdf<propto__>(phi_tilde, spatial_scale[(1 - 1)],
              node1, node2, k, group_size, group_idx, has_theta, pstream__));
          current_statement__ = 193;
          if (m) {
            current_statement__ = 192;
            lp_accum__.add(
              normal_lpdf<false>(alpha_phi, 0, prior_alpha[(2 - 1)]));
          } 
        } 
        current_statement__ = 203;
        if (dev) {
          current_statement__ = 196;
          lp_accum__.add(std_normal_lpdf<false>(z));
          current_statement__ = 197;
          lp_accum__.add(std_normal_lpdf<false>(aux1_local));
          current_statement__ = 198;
          lp_accum__.add(inv_gamma_lpdf<false>(aux2_local, 0.5, 0.5));
          current_statement__ = 199;
          lp_accum__.add(std_normal_lpdf<false>(aux1_global[(1 - 1)]));
          current_statement__ = 200;
          lp_accum__.add(
            inv_gamma_lpdf<false>(aux2_global[(1 - 1)], 0.5, 0.5));
          current_statement__ = 201;
          lp_accum__.add(
            inv_gamma_lpdf<false>(caux[(1 - 1)], (0.5 * slab_df),
              (0.5 * slab_df)));
        } 
        current_statement__ = 212;
        if (car) {
          current_statement__ = 204;
          lp_accum__.add(
            student_t_lpdf<false>(car_scale[(1 - 1)], prior_sigma[(1 - 1)],
              prior_sigma[(2 - 1)], prior_sigma[(3 - 1)]));
          current_statement__ = 207;
          if ((primitive_value(is_auto_gaussian) && primitive_value(
              logical_negation(prior_only)))) {
            current_statement__ = 205;
            lp_accum__.add(
              auto_normal_lpdf<false>(y, fitted, car_scale[(1 - 1)],
                car_rho[(1 - 1)], Ax_w, Ax_v, Ax_u, Cidx, Delta_inv,
                log_det_Delta_inv, lambda, n, WCAR, pstream__));
          } 
          current_statement__ = 210;
          if (logical_negation(is_auto_gaussian)) {
            current_statement__ = 208;
            lp_accum__.add(
              auto_normal_lpdf<false>(log_lambda, log_lambda_mu,
                car_scale[(1 - 1)], car_rho[(1 - 1)], Ax_w, Ax_v, Ax_u, Cidx,
                Delta_inv, log_det_Delta_inv, lambda, n, WCAR, pstream__));
          } 
        } 
        current_statement__ = 221;
        if (sar) {
          current_statement__ = 213;
          lp_accum__.add(
            student_t_lpdf<false>(sar_scale[(1 - 1)], prior_sigma[(1 - 1)],
              prior_sigma[(2 - 1)], prior_sigma[(3 - 1)]));
          current_statement__ = 216;
          if ((primitive_value(is_auto_gaussian) && primitive_value(
              logical_negation(prior_only)))) {
            current_statement__ = 214;
            lp_accum__.add(
              sar_normal_lpdf<false>(y, fitted, sar_scale[(1 - 1)],
                sar_rho[(1 - 1)], ImW_w, ImW_v, ImW_u, Widx, eigenvalues_w,
                n, pstream__));
          } 
          current_statement__ = 219;
          if (logical_negation(is_auto_gaussian)) {
            current_statement__ = 217;
            lp_accum__.add(
              sar_normal_lpdf<false>(log_lambda, log_lambda_mu,
                sar_scale[(1 - 1)], sar_rho[(1 - 1)], ImW_w, ImW_v, ImW_u,
                Widx, eigenvalues_w, n, pstream__));
          } 
        } 
      }
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
    }
    lp_accum__.add(lp__);
    return lp_accum__.sum();
    } // log_prob_impl() 
    
  template <typename RNG, typename VecR, typename VecI, typename VecVar, stan::require_vector_like_vt<std::is_floating_point, VecR>* = nullptr, stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr, stan::require_std_vector_vt<std::is_floating_point, VecVar>* = nullptr>
  inline void write_array_impl(RNG& base_rng__, VecR& params_r__,
                               VecI& params_i__, VecVar& vars__,
                               const bool emit_transformed_parameters__ = true,
                               const bool emit_generated_quantities__ = true,
                               std::ostream* pstream__ = nullptr) const {
    using local_scalar_t__ = double;
    vars__.resize(0);
    stan::io::reader<local_scalar_t__> in__(params_r__, params_i__);
    static const char* function__ = "model_foundation_namespace::write_array";
(void) function__;  // suppress unused var warning
    (void) function__;  // suppress unused var warning
    double lp__ = 0.0;
    (void) lp__;  // dummy to suppress unused var warning
    stan::math::accumulator<double> lp_accum__;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    (void) DUMMY_VAR__;  // suppress unused var warning
    
    try {
      Eigen::Matrix<double, -1, 1> alpha_phi;
      alpha_phi = Eigen::Matrix<double, -1, 1>(m);
      stan::math::fill(alpha_phi, std::numeric_limits<double>::quiet_NaN());
      
      current_statement__ = 1;
      alpha_phi = in__.vector(m);
      Eigen::Matrix<double, -1, 1> phi_tilde;
      phi_tilde = Eigen::Matrix<double, -1, 1>(phi_tilde_1dim__);
      stan::math::fill(phi_tilde, std::numeric_limits<double>::quiet_NaN());
      
      current_statement__ = 2;
      phi_tilde = in__.vector(phi_tilde_1dim__);
      std::vector<double> spatial_scale;
      spatial_scale = std::vector<double>(spatial_scale_1dim__, std::numeric_limits<double>::quiet_NaN());
      
      current_statement__ = 3;
      for (int sym1__ = 1; sym1__ <= spatial_scale_1dim__; ++sym1__) {
        current_statement__ = 3;
        assign(spatial_scale, cons_list(index_uni(sym1__), nil_index_list()),
          in__.scalar(), "assigning variable spatial_scale");}
      current_statement__ = 3;
      for (int sym1__ = 1; sym1__ <= spatial_scale_1dim__; ++sym1__) {
        current_statement__ = 3;
        assign(spatial_scale, cons_list(index_uni(sym1__), nil_index_list()),
          stan::math::lb_constrain(spatial_scale[(sym1__ - 1)], 0),
          "assigning variable spatial_scale");}
      Eigen::Matrix<double, -1, 1> theta_tilde;
      theta_tilde = Eigen::Matrix<double, -1, 1>(theta_tilde_1dim__);
      stan::math::fill(theta_tilde, std::numeric_limits<double>::quiet_NaN());
      
      current_statement__ = 4;
      theta_tilde = in__.vector(theta_tilde_1dim__);
      std::vector<double> theta_scale;
      theta_scale = std::vector<double>(theta_scale_1dim__, std::numeric_limits<double>::quiet_NaN());
      
      current_statement__ = 5;
      for (int sym1__ = 1; sym1__ <= theta_scale_1dim__; ++sym1__) {
        current_statement__ = 5;
        assign(theta_scale, cons_list(index_uni(sym1__), nil_index_list()),
          in__.scalar(), "assigning variable theta_scale");}
      current_statement__ = 5;
      for (int sym1__ = 1; sym1__ <= theta_scale_1dim__; ++sym1__) {
        current_statement__ = 5;
        assign(theta_scale, cons_list(index_uni(sym1__), nil_index_list()),
          stan::math::lb_constrain(theta_scale[(sym1__ - 1)], 0),
          "assigning variable theta_scale");}
      std::vector<double> rho;
      rho = std::vector<double>(rho_1dim__, std::numeric_limits<double>::quiet_NaN());
      
      current_statement__ = 6;
      for (int sym1__ = 1; sym1__ <= rho_1dim__; ++sym1__) {
        current_statement__ = 6;
        assign(rho, cons_list(index_uni(sym1__), nil_index_list()),
          in__.scalar(), "assigning variable rho");}
      current_statement__ = 6;
      for (int sym1__ = 1; sym1__ <= rho_1dim__; ++sym1__) {
        current_statement__ = 6;
        assign(rho, cons_list(index_uni(sym1__), nil_index_list()),
          stan::math::lub_constrain(rho[(sym1__ - 1)], 0, 1),
          "assigning variable rho");}
      std::vector<double> aux1_global;
      aux1_global = std::vector<double>(aux1_global_1dim__, std::numeric_limits<double>::quiet_NaN());
      
      current_statement__ = 7;
      for (int sym1__ = 1; sym1__ <= aux1_global_1dim__; ++sym1__) {
        current_statement__ = 7;
        assign(aux1_global, cons_list(index_uni(sym1__), nil_index_list()),
          in__.scalar(), "assigning variable aux1_global");}
      current_statement__ = 7;
      for (int sym1__ = 1; sym1__ <= aux1_global_1dim__; ++sym1__) {
        current_statement__ = 7;
        assign(aux1_global, cons_list(index_uni(sym1__), nil_index_list()),
          stan::math::lb_constrain(aux1_global[(sym1__ - 1)], 0),
          "assigning variable aux1_global");}
      std::vector<double> aux2_global;
      aux2_global = std::vector<double>(aux2_global_1dim__, std::numeric_limits<double>::quiet_NaN());
      
      current_statement__ = 8;
      for (int sym1__ = 1; sym1__ <= aux2_global_1dim__; ++sym1__) {
        current_statement__ = 8;
        assign(aux2_global, cons_list(index_uni(sym1__), nil_index_list()),
          in__.scalar(), "assigning variable aux2_global");}
      current_statement__ = 8;
      for (int sym1__ = 1; sym1__ <= aux2_global_1dim__; ++sym1__) {
        current_statement__ = 8;
        assign(aux2_global, cons_list(index_uni(sym1__), nil_index_list()),
          stan::math::lb_constrain(aux2_global[(sym1__ - 1)], 0),
          "assigning variable aux2_global");}
      Eigen::Matrix<double, -1, 1> aux1_local;
      aux1_local = Eigen::Matrix<double, -1, 1>(dev);
      stan::math::fill(aux1_local, std::numeric_limits<double>::quiet_NaN());
      
      current_statement__ = 9;
      aux1_local = in__.vector(dev);
      current_statement__ = 9;
      for (int sym1__ = 1; sym1__ <= dev; ++sym1__) {
        current_statement__ = 9;
        assign(aux1_local, cons_list(index_uni(sym1__), nil_index_list()),
          stan::math::lb_constrain(aux1_local[(sym1__ - 1)], 0),
          "assigning variable aux1_local");}
      Eigen::Matrix<double, -1, 1> aux2_local;
      aux2_local = Eigen::Matrix<double, -1, 1>(dev);
      stan::math::fill(aux2_local, std::numeric_limits<double>::quiet_NaN());
      
      current_statement__ = 10;
      aux2_local = in__.vector(dev);
      current_statement__ = 10;
      for (int sym1__ = 1; sym1__ <= dev; ++sym1__) {
        current_statement__ = 10;
        assign(aux2_local, cons_list(index_uni(sym1__), nil_index_list()),
          stan::math::lb_constrain(aux2_local[(sym1__ - 1)], 0),
          "assigning variable aux2_local");}
      std::vector<double> caux;
      caux = std::vector<double>(caux_1dim__, std::numeric_limits<double>::quiet_NaN());
      
      current_statement__ = 11;
      for (int sym1__ = 1; sym1__ <= caux_1dim__; ++sym1__) {
        current_statement__ = 11;
        assign(caux, cons_list(index_uni(sym1__), nil_index_list()),
          in__.scalar(), "assigning variable caux");}
      current_statement__ = 11;
      for (int sym1__ = 1; sym1__ <= caux_1dim__; ++sym1__) {
        current_statement__ = 11;
        assign(caux, cons_list(index_uni(sym1__), nil_index_list()),
          stan::math::lb_constrain(caux[(sym1__ - 1)], 0),
          "assigning variable caux");}
      Eigen::Matrix<double, -1, 1> z;
      z = Eigen::Matrix<double, -1, 1>(dev);
      stan::math::fill(z, std::numeric_limits<double>::quiet_NaN());
      
      current_statement__ = 12;
      z = in__.vector(dev);
      Eigen::Matrix<double, -1, 1> log_lambda;
      log_lambda = Eigen::Matrix<double, -1, 1>(log_lambda_1dim__);
      stan::math::fill(log_lambda, std::numeric_limits<double>::quiet_NaN());
      
      current_statement__ = 13;
      log_lambda = in__.vector(log_lambda_1dim__);
      std::vector<double> car_scale;
      car_scale = std::vector<double>(car_scale_1dim__, std::numeric_limits<double>::quiet_NaN());
      
      current_statement__ = 14;
      for (int sym1__ = 1; sym1__ <= car_scale_1dim__; ++sym1__) {
        current_statement__ = 14;
        assign(car_scale, cons_list(index_uni(sym1__), nil_index_list()),
          in__.scalar(), "assigning variable car_scale");}
      current_statement__ = 14;
      for (int sym1__ = 1; sym1__ <= car_scale_1dim__; ++sym1__) {
        current_statement__ = 14;
        assign(car_scale, cons_list(index_uni(sym1__), nil_index_list()),
          stan::math::lb_constrain(car_scale[(sym1__ - 1)], 0),
          "assigning variable car_scale");}
      std::vector<double> car_rho;
      car_rho = std::vector<double>(car_rho_1dim__, std::numeric_limits<double>::quiet_NaN());
      
      current_statement__ = 15;
      for (int sym1__ = 1; sym1__ <= car_rho_1dim__; ++sym1__) {
        current_statement__ = 15;
        assign(car_rho, cons_list(index_uni(sym1__), nil_index_list()),
          in__.scalar(), "assigning variable car_rho");}
      current_statement__ = 15;
      for (int sym1__ = 1; sym1__ <= car_rho_1dim__; ++sym1__) {
        current_statement__ = 15;
        assign(car_rho, cons_list(index_uni(sym1__), nil_index_list()),
          stan::math::lub_constrain(car_rho[(sym1__ - 1)],
            car_rho_lims[(1 - 1)], car_rho_lims[(2 - 1)]),
          "assigning variable car_rho");}
      std::vector<double> sar_scale;
      sar_scale = std::vector<double>(sar_scale_1dim__, std::numeric_limits<double>::quiet_NaN());
      
      current_statement__ = 16;
      for (int sym1__ = 1; sym1__ <= sar_scale_1dim__; ++sym1__) {
        current_statement__ = 16;
        assign(sar_scale, cons_list(index_uni(sym1__), nil_index_list()),
          in__.scalar(), "assigning variable sar_scale");}
      current_statement__ = 16;
      for (int sym1__ = 1; sym1__ <= sar_scale_1dim__; ++sym1__) {
        current_statement__ = 16;
        assign(sar_scale, cons_list(index_uni(sym1__), nil_index_list()),
          stan::math::lb_constrain(sar_scale[(sym1__ - 1)], 0),
          "assigning variable sar_scale");}
      std::vector<double> sar_rho;
      sar_rho = std::vector<double>(sar_rho_1dim__, std::numeric_limits<double>::quiet_NaN());
      
      current_statement__ = 17;
      for (int sym1__ = 1; sym1__ <= sar_rho_1dim__; ++sym1__) {
        current_statement__ = 17;
        assign(sar_rho, cons_list(index_uni(sym1__), nil_index_list()),
          in__.scalar(), "assigning variable sar_rho");}
      current_statement__ = 17;
      for (int sym1__ = 1; sym1__ <= sar_rho_1dim__; ++sym1__) {
        current_statement__ = 17;
        assign(sar_rho, cons_list(index_uni(sym1__), nil_index_list()),
          stan::math::lub_constrain(sar_rho[(sym1__ - 1)],
            sar_rho_lims[(1 - 1)], sar_rho_lims[(2 - 1)]),
          "assigning variable sar_rho");}
      double intercept;
      intercept = std::numeric_limits<double>::quiet_NaN();
      
      current_statement__ = 18;
      intercept = in__.scalar();
      Eigen::Matrix<double, -1, 1> gamma;
      gamma = Eigen::Matrix<double, -1, 1>(dwx);
      stan::math::fill(gamma, std::numeric_limits<double>::quiet_NaN());
      
      current_statement__ = 19;
      gamma = in__.vector(dwx);
      Eigen::Matrix<double, -1, 1> beta;
      beta = Eigen::Matrix<double, -1, 1>(dx_all);
      stan::math::fill(beta, std::numeric_limits<double>::quiet_NaN());
      
      current_statement__ = 20;
      beta = in__.vector(dx_all);
      std::vector<double> nu;
      nu = std::vector<double>(is_student, std::numeric_limits<double>::quiet_NaN());
      
      current_statement__ = 21;
      for (int sym1__ = 1; sym1__ <= is_student; ++sym1__) {
        current_statement__ = 21;
        assign(nu, cons_list(index_uni(sym1__), nil_index_list()),
          in__.scalar(), "assigning variable nu");}
      current_statement__ = 21;
      for (int sym1__ = 1; sym1__ <= is_student; ++sym1__) {
        current_statement__ = 21;
        assign(nu, cons_list(index_uni(sym1__), nil_index_list()),
          stan::math::lb_constrain(nu[(sym1__ - 1)], 0),
          "assigning variable nu");}
      std::vector<double> sigma;
      sigma = std::vector<double>(has_sigma, std::numeric_limits<double>::quiet_NaN());
      
      current_statement__ = 22;
      for (int sym1__ = 1; sym1__ <= has_sigma; ++sym1__) {
        current_statement__ = 22;
        assign(sigma, cons_list(index_uni(sym1__), nil_index_list()),
          in__.scalar(), "assigning variable sigma");}
      current_statement__ = 22;
      for (int sym1__ = 1; sym1__ <= has_sigma; ++sym1__) {
        current_statement__ = 22;
        assign(sigma, cons_list(index_uni(sym1__), nil_index_list()),
          stan::math::lb_constrain(sigma[(sym1__ - 1)], 0),
          "assigning variable sigma");}
      Eigen::Matrix<double, -1, 1> alpha_re;
      alpha_re = Eigen::Matrix<double, -1, 1>(n_ids);
      stan::math::fill(alpha_re, std::numeric_limits<double>::quiet_NaN());
      
      current_statement__ = 23;
      alpha_re = in__.vector(n_ids);
      std::vector<double> alpha_tau;
      alpha_tau = std::vector<double>(has_re, std::numeric_limits<double>::quiet_NaN());
      
      current_statement__ = 24;
      for (int sym1__ = 1; sym1__ <= has_re; ++sym1__) {
        current_statement__ = 24;
        assign(alpha_tau, cons_list(index_uni(sym1__), nil_index_list()),
          in__.scalar(), "assigning variable alpha_tau");}
      current_statement__ = 24;
      for (int sym1__ = 1; sym1__ <= has_re; ++sym1__) {
        current_statement__ = 24;
        assign(alpha_tau, cons_list(index_uni(sym1__), nil_index_list()),
          stan::math::lb_constrain(alpha_tau[(sym1__ - 1)], 0),
          "assigning variable alpha_tau");}
      std::vector<Eigen::Matrix<double, -1, 1>> x_true;
      x_true = std::vector<Eigen::Matrix<double, -1, 1>>(dx_me, Eigen::Matrix<double, -1, 1>(n));
      stan::math::fill(x_true, std::numeric_limits<double>::quiet_NaN());
      
      current_statement__ = 25;
      for (int sym1__ = 1; sym1__ <= dx_me; ++sym1__) {
        current_statement__ = 25;
        assign(x_true, cons_list(index_uni(sym1__), nil_index_list()),
          in__.vector(n), "assigning variable x_true");}
      current_statement__ = 25;
      for (int sym1__ = 1; sym1__ <= dx_me; ++sym1__) {
        current_statement__ = 25;
        for (int sym2__ = 1; sym2__ <= n; ++sym2__) {
          current_statement__ = 25;
          assign(x_true,
            cons_list(index_uni(sym1__),
              cons_list(index_uni(sym2__), nil_index_list())),
            stan::math::lub_constrain(x_true[(sym1__ - 1)][(sym2__ - 1)],
              bounds[(1 - 1)], bounds[(2 - 1)]), "assigning variable x_true");
        }}
      Eigen::Matrix<double, -1, 1> mu_x_true;
      mu_x_true = Eigen::Matrix<double, -1, 1>(dx_me);
      stan::math::fill(mu_x_true, std::numeric_limits<double>::quiet_NaN());
      
      current_statement__ = 26;
      mu_x_true = in__.vector(dx_me);
      Eigen::Matrix<double, -1, 1> sigma_x_true;
      sigma_x_true = Eigen::Matrix<double, -1, 1>(dx_me);
      stan::math::fill(sigma_x_true, std::numeric_limits<double>::quiet_NaN());
      
      current_statement__ = 27;
      sigma_x_true = in__.vector(dx_me);
      current_statement__ = 27;
      for (int sym1__ = 1; sym1__ <= dx_me; ++sym1__) {
        current_statement__ = 27;
        assign(sigma_x_true, cons_list(index_uni(sym1__), nil_index_list()),
          stan::math::lb_constrain(sigma_x_true[(sym1__ - 1)], 0),
          "assigning variable sigma_x_true");}
      Eigen::Matrix<double, -1, 1> car_rho_x_true;
      car_rho_x_true = Eigen::Matrix<double, -1, 1>(car_rho_x_true_1dim__);
      stan::math::fill(car_rho_x_true, std::numeric_limits<double>::quiet_NaN());
      
      current_statement__ = 28;
      car_rho_x_true = in__.vector(car_rho_x_true_1dim__);
      current_statement__ = 28;
      for (int sym1__ = 1; sym1__ <= car_rho_x_true_1dim__; ++sym1__) {
        current_statement__ = 28;
        assign(car_rho_x_true,
          cons_list(index_uni(sym1__), nil_index_list()),
          stan::math::lub_constrain(car_rho_x_true[(sym1__ - 1)],
            prior_rhox_true[(1 - 1)], prior_rhox_true[(2 - 1)]),
          "assigning variable car_rho_x_true");}
      Eigen::Matrix<double, -1, 1> nu_x_true;
      nu_x_true = Eigen::Matrix<double, -1, 1>(nu_x_true_1dim__);
      stan::math::fill(nu_x_true, std::numeric_limits<double>::quiet_NaN());
      
      current_statement__ = 29;
      nu_x_true = in__.vector(nu_x_true_1dim__);
      current_statement__ = 29;
      for (int sym1__ = 1; sym1__ <= nu_x_true_1dim__; ++sym1__) {
        current_statement__ = 29;
        assign(nu_x_true, cons_list(index_uni(sym1__), nil_index_list()),
          stan::math::lb_constrain(nu_x_true[(sym1__ - 1)], 0),
          "assigning variable nu_x_true");}
      Eigen::Matrix<double, -1, 1> beta_ev;
      beta_ev = Eigen::Matrix<double, -1, 1>(dev);
      stan::math::fill(beta_ev, std::numeric_limits<double>::quiet_NaN());
      
      Eigen::Matrix<double, -1, 1> esf;
      esf = Eigen::Matrix<double, -1, 1>(esf_1dim__);
      stan::math::fill(esf, std::numeric_limits<double>::quiet_NaN());
      
      std::vector<double> error_scale;
      error_scale = std::vector<double>(error_scale_1dim__, std::numeric_limits<double>::quiet_NaN());
      
      Eigen::Matrix<double, -1, 1> phi;
      phi = Eigen::Matrix<double, -1, 1>(phi_1dim__);
      stan::math::fill(phi, std::numeric_limits<double>::quiet_NaN());
      
      Eigen::Matrix<double, -1, 1> theta;
      theta = Eigen::Matrix<double, -1, 1>(theta_1dim__);
      stan::math::fill(theta, std::numeric_limits<double>::quiet_NaN());
      
      Eigen::Matrix<double, -1, 1> log_lambda_mu;
      log_lambda_mu = Eigen::Matrix<double, -1, 1>(log_lambda_mu_1dim__);
      stan::math::fill(log_lambda_mu, std::numeric_limits<double>::quiet_NaN());
      
      Eigen::Matrix<double, -1, -1> x_all;
      x_all = Eigen::Matrix<double, -1, -1>(n, dx_all);
      stan::math::fill(x_all, std::numeric_limits<double>::quiet_NaN());
      
      Eigen::Matrix<double, -1, 1> fitted;
      fitted = Eigen::Matrix<double, -1, 1>(n);
      stan::math::fill(fitted, std::numeric_limits<double>::quiet_NaN());
      
      for (int sym1__ = 1; sym1__ <= m; ++sym1__) {
        vars__.emplace_back(alpha_phi[(sym1__ - 1)]);}
      for (int sym1__ = 1; sym1__ <= phi_tilde_1dim__; ++sym1__) {
        vars__.emplace_back(phi_tilde[(sym1__ - 1)]);}
      for (int sym1__ = 1; sym1__ <= spatial_scale_1dim__; ++sym1__) {
        vars__.emplace_back(spatial_scale[(sym1__ - 1)]);}
      for (int sym1__ = 1; sym1__ <= theta_tilde_1dim__; ++sym1__) {
        vars__.emplace_back(theta_tilde[(sym1__ - 1)]);}
      for (int sym1__ = 1; sym1__ <= theta_scale_1dim__; ++sym1__) {
        vars__.emplace_back(theta_scale[(sym1__ - 1)]);}
      for (int sym1__ = 1; sym1__ <= rho_1dim__; ++sym1__) {
        vars__.emplace_back(rho[(sym1__ - 1)]);}
      for (int sym1__ = 1; sym1__ <= aux1_global_1dim__; ++sym1__) {
        vars__.emplace_back(aux1_global[(sym1__ - 1)]);}
      for (int sym1__ = 1; sym1__ <= aux2_global_1dim__; ++sym1__) {
        vars__.emplace_back(aux2_global[(sym1__ - 1)]);}
      for (int sym1__ = 1; sym1__ <= dev; ++sym1__) {
        vars__.emplace_back(aux1_local[(sym1__ - 1)]);}
      for (int sym1__ = 1; sym1__ <= dev; ++sym1__) {
        vars__.emplace_back(aux2_local[(sym1__ - 1)]);}
      for (int sym1__ = 1; sym1__ <= caux_1dim__; ++sym1__) {
        vars__.emplace_back(caux[(sym1__ - 1)]);}
      for (int sym1__ = 1; sym1__ <= dev; ++sym1__) {
        vars__.emplace_back(z[(sym1__ - 1)]);}
      for (int sym1__ = 1; sym1__ <= log_lambda_1dim__; ++sym1__) {
        vars__.emplace_back(log_lambda[(sym1__ - 1)]);}
      for (int sym1__ = 1; sym1__ <= car_scale_1dim__; ++sym1__) {
        vars__.emplace_back(car_scale[(sym1__ - 1)]);}
      for (int sym1__ = 1; sym1__ <= car_rho_1dim__; ++sym1__) {
        vars__.emplace_back(car_rho[(sym1__ - 1)]);}
      for (int sym1__ = 1; sym1__ <= sar_scale_1dim__; ++sym1__) {
        vars__.emplace_back(sar_scale[(sym1__ - 1)]);}
      for (int sym1__ = 1; sym1__ <= sar_rho_1dim__; ++sym1__) {
        vars__.emplace_back(sar_rho[(sym1__ - 1)]);}
      vars__.emplace_back(intercept);
      for (int sym1__ = 1; sym1__ <= dwx; ++sym1__) {
        vars__.emplace_back(gamma[(sym1__ - 1)]);}
      for (int sym1__ = 1; sym1__ <= dx_all; ++sym1__) {
        vars__.emplace_back(beta[(sym1__ - 1)]);}
      for (int sym1__ = 1; sym1__ <= is_student; ++sym1__) {
        vars__.emplace_back(nu[(sym1__ - 1)]);}
      for (int sym1__ = 1; sym1__ <= has_sigma; ++sym1__) {
        vars__.emplace_back(sigma[(sym1__ - 1)]);}
      for (int sym1__ = 1; sym1__ <= n_ids; ++sym1__) {
        vars__.emplace_back(alpha_re[(sym1__ - 1)]);}
      for (int sym1__ = 1; sym1__ <= has_re; ++sym1__) {
        vars__.emplace_back(alpha_tau[(sym1__ - 1)]);}
      for (int sym1__ = 1; sym1__ <= n; ++sym1__) {
        for (int sym2__ = 1; sym2__ <= dx_me; ++sym2__) {
          vars__.emplace_back(x_true[(sym2__ - 1)][(sym1__ - 1)]);}}
      for (int sym1__ = 1; sym1__ <= dx_me; ++sym1__) {
        vars__.emplace_back(mu_x_true[(sym1__ - 1)]);}
      for (int sym1__ = 1; sym1__ <= dx_me; ++sym1__) {
        vars__.emplace_back(sigma_x_true[(sym1__ - 1)]);}
      for (int sym1__ = 1; sym1__ <= car_rho_x_true_1dim__; ++sym1__) {
        vars__.emplace_back(car_rho_x_true[(sym1__ - 1)]);}
      for (int sym1__ = 1; sym1__ <= nu_x_true_1dim__; ++sym1__) {
        vars__.emplace_back(nu_x_true[(sym1__ - 1)]);}
      if (logical_negation((primitive_value(emit_transformed_parameters__) ||
            primitive_value(emit_generated_quantities__)))) {
        return ;
      } 
      current_statement__ = 39;
      if (dx_obs) {
        current_statement__ = 38;
        assign(x_all,
          cons_list(index_omni(),
            cons_list(index_multi(x_obs_idx), nil_index_list())), x_obs,
          "assigning variable x_all");
      } 
      current_statement__ = 42;
      if (dx_me) {
        current_statement__ = 41;
        for (int j = 1; j <= dx_me; ++j) {
          current_statement__ = 40;
          assign(x_all,
            cons_list(index_omni(),
              cons_list(index_uni(x_me_idx[(j - 1)]), nil_index_list())),
            x_true[(j - 1)], "assigning variable x_all");}
      } 
      current_statement__ = 45;
      if (center_x) {
        current_statement__ = 44;
        for (int j = 1; j <= dx_all; ++j) {
          current_statement__ = 43;
          assign(x_all,
            cons_list(index_omni(),
              cons_list(index_uni(j), nil_index_list())),
            subtract(
              stan::model::deep_copy(
                rvalue(x_all,
                  cons_list(index_omni(),
                    cons_list(index_uni(j), nil_index_list())), "x_all")),
              mean(
                rvalue(x_all,
                  cons_list(index_omni(),
                    cons_list(index_uni(j), nil_index_list())), "x_all"))),
            "assigning variable x_all");}
      } 
      current_statement__ = 47;
      if (logical_negation(car)) {
        current_statement__ = 46;
        assign(fitted, nil_index_list(), add(input_offset, intercept),
          "assigning variable fitted");
      } 
      current_statement__ = 53;
      if (logical_eq(type, 1)) {
        current_statement__ = 48;
        assign(phi, nil_index_list(),
          make_phi(phi_tilde, spatial_scale[(1 - 1)], 1,
            inv_sqrt_scale_factor, n, k, group_size, group_idx, pstream__),
          "assigning variable phi");
        current_statement__ = 50;
        if (m) {
          current_statement__ = 49;
          assign(phi, nil_index_list(),
            add(stan::model::deep_copy(phi), multiply(A, alpha_phi)),
            "assigning variable phi");
        } 
        current_statement__ = 51;
        assign(fitted, nil_index_list(),
          add(stan::model::deep_copy(fitted), phi),
          "assigning variable fitted");
      } 
      current_statement__ = 60;
      if (logical_eq(type, 2)) {
        current_statement__ = 54;
        assign(theta, nil_index_list(),
          multiply(theta_tilde, theta_scale[(1 - 1)]),
          "assigning variable theta");
        current_statement__ = 55;
        assign(phi, nil_index_list(),
          make_phi(phi_tilde, spatial_scale[(1 - 1)], 1,
            inv_sqrt_scale_factor, n, k, group_size, group_idx, pstream__),
          "assigning variable phi");
        current_statement__ = 57;
        if (m) {
          current_statement__ = 56;
          assign(phi, nil_index_list(),
            add(stan::model::deep_copy(phi), multiply(A, alpha_phi)),
            "assigning variable phi");
        } 
        current_statement__ = 58;
        assign(fitted, nil_index_list(),
          add(stan::model::deep_copy(fitted),
            convolve_bym(phi, theta, n, k, group_size, group_idx, pstream__)),
          "assigning variable fitted");
      } 
      current_statement__ = 67;
      if (logical_eq(type, 3)) {
        current_statement__ = 61;
        assign(theta, nil_index_list(),
          multiply(
            (spatial_scale[(1 - 1)] * stan::math::sqrt((1 - rho[(1 - 1)]))),
            theta_tilde), "assigning variable theta");
        current_statement__ = 62;
        assign(phi, nil_index_list(),
          make_phi(phi_tilde, spatial_scale[(1 - 1)], rho[(1 - 1)],
            inv_sqrt_scale_factor, n, k, group_size, group_idx, pstream__),
          "assigning variable phi");
        current_statement__ = 64;
        if (m) {
          current_statement__ = 63;
          assign(phi, nil_index_list(),
            add(stan::model::deep_copy(phi), multiply(A, alpha_phi)),
            "assigning variable phi");
        } 
        current_statement__ = 65;
        assign(fitted, nil_index_list(),
          add(stan::model::deep_copy(fitted),
            convolve_bym2(phi_tilde, theta_tilde, spatial_scale[(1 - 1)], n,
              k, group_size, group_idx, rho[(1 - 1)],
              inv_sqrt_scale_factor, pstream__)), "assigning variable fitted");
      } 
      current_statement__ = 77;
      if (dev) {
        current_statement__ = 72;
        if (has_sigma) {
          current_statement__ = 70;
          assign(error_scale, cons_list(index_uni(1), nil_index_list()),
            sigma[(1 - 1)], "assigning variable error_scale");
        } else {
          current_statement__ = 68;
          assign(error_scale, cons_list(index_uni(1), nil_index_list()), 1,
            "assigning variable error_scale");
        }
        current_statement__ = 73;
        assign(beta_ev, nil_index_list(),
          rhs_prior(dev, z, aux1_global[(1 - 1)], aux2_global[(1 - 1)],
            aux1_local, aux2_local, caux[(1 - 1)], global_scale, slab_scale,
            error_scale[(1 - 1)], pstream__), "assigning variable beta_ev");
        current_statement__ = 74;
        assign(esf, nil_index_list(), multiply(EV, beta_ev),
          "assigning variable esf");
        current_statement__ = 75;
        assign(fitted, nil_index_list(),
          add(stan::model::deep_copy(fitted), esf),
          "assigning variable fitted");
      } 
      current_statement__ = 96;
      if ((primitive_value(car) || primitive_value(sar))) {
        current_statement__ = 78;
        assign(log_lambda_mu, nil_index_list(), rep_vector(intercept, n),
          "assigning variable log_lambda_mu");
        current_statement__ = 83;
        if (has_re) {
          current_statement__ = 81;
          for (int i = 1; i <= n; ++i) {
            current_statement__ = 79;
            assign(log_lambda_mu, cons_list(index_uni(i), nil_index_list()),
              (log_lambda_mu[(i - 1)] + alpha_re[(id[(i - 1)] - 1)]),
              "assigning variable log_lambda_mu");}
        } 
        current_statement__ = 87;
        if (dwx) {
          current_statement__ = 85;
          for (int i = 1; i <= dwx; ++i) {
            current_statement__ = 84;
            assign(log_lambda_mu, nil_index_list(),
              add(stan::model::deep_copy(log_lambda_mu),
                multiply(
                  csr_matrix_times_vector(n, n, W_w, W_v, W_u,
                    rvalue(x_all,
                      cons_list(index_omni(),
                        cons_list(index_uni(wx_idx[(i - 1)]),
                          nil_index_list())), "x_all")), gamma[(i - 1)])),
              "assigning variable log_lambda_mu");}
        } 
        current_statement__ = 89;
        if (dx_all) {
          current_statement__ = 88;
          assign(log_lambda_mu, nil_index_list(),
            add(stan::model::deep_copy(log_lambda_mu), multiply(x_all, beta)),
            "assigning variable log_lambda_mu");
        } 
        current_statement__ = 94;
        if (is_auto_gaussian) {
          current_statement__ = 92;
          assign(fitted, nil_index_list(), add(input_offset, log_lambda_mu),
            "assigning variable fitted");
        } else {
          current_statement__ = 90;
          assign(fitted, nil_index_list(), add(input_offset, log_lambda),
            "assigning variable fitted");
        }
      } 
      current_statement__ = 109;
      if ((primitive_value(logical_negation(car)) && primitive_value(
          logical_negation(sar)))) {
        current_statement__ = 101;
        if (has_re) {
          current_statement__ = 99;
          for (int i = 1; i <= n; ++i) {
            current_statement__ = 97;
            assign(fitted, cons_list(index_uni(i), nil_index_list()),
              (fitted[(i - 1)] + alpha_re[(id[(i - 1)] - 1)]),
              "assigning variable fitted");}
        } 
        current_statement__ = 105;
        if (dwx) {
          current_statement__ = 103;
          for (int i = 1; i <= dwx; ++i) {
            current_statement__ = 102;
            assign(fitted, nil_index_list(),
              add(stan::model::deep_copy(fitted),
                multiply(
                  csr_matrix_times_vector(n, n, W_w, W_v, W_u,
                    rvalue(x_all,
                      cons_list(index_omni(),
                        cons_list(index_uni(wx_idx[(i - 1)]),
                          nil_index_list())), "x_all")), gamma[(i - 1)])),
              "assigning variable fitted");}
        } 
        current_statement__ = 107;
        if (dx_all) {
          current_statement__ = 106;
          assign(fitted, nil_index_list(),
            add(stan::model::deep_copy(fitted), multiply(x_all, beta)),
            "assigning variable fitted");
        } 
      } 
      current_statement__ = 111;
      if (is_binomial) {
        current_statement__ = 110;
        assign(fitted, nil_index_list(),
          inv_logit(stan::model::deep_copy(fitted)),
          "assigning variable fitted");
      } 
      current_statement__ = 113;
      if (is_poisson) {
        current_statement__ = 112;
        assign(fitted, nil_index_list(),
          stan::math::exp(stan::model::deep_copy(fitted)),
          "assigning variable fitted");
      } 
      if (emit_transformed_parameters__) {
        for (int sym1__ = 1; sym1__ <= dev; ++sym1__) {
          vars__.emplace_back(beta_ev[(sym1__ - 1)]);}
        for (int sym1__ = 1; sym1__ <= esf_1dim__; ++sym1__) {
          vars__.emplace_back(esf[(sym1__ - 1)]);}
        for (int sym1__ = 1; sym1__ <= error_scale_1dim__; ++sym1__) {
          vars__.emplace_back(error_scale[(sym1__ - 1)]);}
        for (int sym1__ = 1; sym1__ <= phi_1dim__; ++sym1__) {
          vars__.emplace_back(phi[(sym1__ - 1)]);}
        for (int sym1__ = 1; sym1__ <= theta_1dim__; ++sym1__) {
          vars__.emplace_back(theta[(sym1__ - 1)]);}
        for (int sym1__ = 1; sym1__ <= log_lambda_mu_1dim__; ++sym1__) {
          vars__.emplace_back(log_lambda_mu[(sym1__ - 1)]);}
        for (int sym1__ = 1; sym1__ <= dx_all; ++sym1__) {
          for (int sym2__ = 1; sym2__ <= n; ++sym2__) {
            vars__.emplace_back(
              rvalue(x_all,
                cons_list(index_uni(sym2__),
                  cons_list(index_uni(sym1__), nil_index_list())), "x_all"));
          }}
        for (int sym1__ = 1; sym1__ <= n; ++sym1__) {
          vars__.emplace_back(fitted[(sym1__ - 1)]);}
      } 
      if (logical_negation(emit_generated_quantities__)) {
        return ;
      } 
      Eigen::Matrix<double, -1, 1> log_lik;
      log_lik = Eigen::Matrix<double, -1, 1>(log_lik_1dim__);
      stan::math::fill(log_lik, std::numeric_limits<double>::quiet_NaN());
      
      current_statement__ = 117;
      if ((primitive_value(is_auto_gaussian) && primitive_value(car))) {
        current_statement__ = 115;
        assign(log_lik, cons_list(index_uni(1), nil_index_list()),
          auto_normal_lpdf<false>(y, fitted, car_scale[(1 - 1)],
            car_rho[(1 - 1)], Ax_w, Ax_v, Ax_u, Cidx, Delta_inv,
            log_det_Delta_inv, lambda, n, WCAR, pstream__),
          "assigning variable log_lik");
      } 
      current_statement__ = 120;
      if ((primitive_value(is_auto_gaussian) && primitive_value(sar))) {
        current_statement__ = 118;
        assign(log_lik, cons_list(index_uni(1), nil_index_list()),
          sar_normal_lpdf<false>(y, fitted, sar_scale[(1 - 1)],
            sar_rho[(1 - 1)], ImW_w, ImW_v, ImW_u, Widx, eigenvalues_w,
            n, pstream__), "assigning variable log_lik");
      } 
      current_statement__ = 134;
      for (int i = 1; i <= n; ++i) {
        current_statement__ = 123;
        if (is_student) {
          current_statement__ = 121;
          assign(log_lik, cons_list(index_uni(i), nil_index_list()),
            student_t_lpdf<false>(y[(i - 1)], nu[(1 - 1)], fitted[(i - 1)],
              sigma[(has_sigma - 1)]), "assigning variable log_lik");
        } 
        current_statement__ = 126;
        if (is_gaussian) {
          current_statement__ = 124;
          assign(log_lik, cons_list(index_uni(i), nil_index_list()),
            normal_lpdf<false>(y[(i - 1)], fitted[(i - 1)],
              sigma[(has_sigma - 1)]), "assigning variable log_lik");
        } 
        current_statement__ = 129;
        if (is_poisson) {
          current_statement__ = 127;
          assign(log_lik, cons_list(index_uni(i), nil_index_list()),
            poisson_lpmf<false>(y_int[(i - 1)], fitted[(i - 1)]),
            "assigning variable log_lik");
        } 
        current_statement__ = 132;
        if (is_binomial) {
          current_statement__ = 130;
          assign(log_lik, cons_list(index_uni(i), nil_index_list()),
            binomial_lpmf<false>(y_int[(i - 1)], trials[(i - 1)],
              fitted[(i - 1)]), "assigning variable log_lik");
        } }
      for (int sym1__ = 1; sym1__ <= log_lik_1dim__; ++sym1__) {
        vars__.emplace_back(log_lik[(sym1__ - 1)]);}
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
    }
    } // write_array_impl() 
    
  template <typename VecVar, typename VecI, stan::require_std_vector_t<VecVar>* = nullptr, stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr>
  inline void transform_inits_impl(const stan::io::var_context& context__,
                                   VecI& params_i__, VecVar& vars__,
                                   std::ostream* pstream__ = nullptr) const {
    using local_scalar_t__ = double;
    vars__.clear();
    vars__.reserve(num_params_r__);
    
    try {
      int pos__;
      pos__ = std::numeric_limits<int>::min();
      
      pos__ = 1;
      Eigen::Matrix<double, -1, 1> alpha_phi;
      alpha_phi = Eigen::Matrix<double, -1, 1>(m);
      stan::math::fill(alpha_phi, std::numeric_limits<double>::quiet_NaN());
      
      {
        std::vector<local_scalar_t__> alpha_phi_flat__;
        current_statement__ = 1;
        assign(alpha_phi_flat__, nil_index_list(),
          context__.vals_r("alpha_phi"),
          "assigning variable alpha_phi_flat__");
        current_statement__ = 1;
        pos__ = 1;
        current_statement__ = 1;
        for (int sym1__ = 1; sym1__ <= m; ++sym1__) {
          current_statement__ = 1;
          assign(alpha_phi, cons_list(index_uni(sym1__), nil_index_list()),
            alpha_phi_flat__[(pos__ - 1)], "assigning variable alpha_phi");
          current_statement__ = 1;
          pos__ = (pos__ + 1);}
      }
      Eigen::Matrix<double, -1, 1> phi_tilde;
      phi_tilde = Eigen::Matrix<double, -1, 1>(phi_tilde_1dim__);
      stan::math::fill(phi_tilde, std::numeric_limits<double>::quiet_NaN());
      
      {
        std::vector<local_scalar_t__> phi_tilde_flat__;
        current_statement__ = 2;
        assign(phi_tilde_flat__, nil_index_list(),
          context__.vals_r("phi_tilde"),
          "assigning variable phi_tilde_flat__");
        current_statement__ = 2;
        pos__ = 1;
        current_statement__ = 2;
        for (int sym1__ = 1; sym1__ <= phi_tilde_1dim__; ++sym1__) {
          current_statement__ = 2;
          assign(phi_tilde, cons_list(index_uni(sym1__), nil_index_list()),
            phi_tilde_flat__[(pos__ - 1)], "assigning variable phi_tilde");
          current_statement__ = 2;
          pos__ = (pos__ + 1);}
      }
      std::vector<double> spatial_scale;
      spatial_scale = std::vector<double>(spatial_scale_1dim__, std::numeric_limits<double>::quiet_NaN());
      
      current_statement__ = 3;
      assign(spatial_scale, nil_index_list(),
        context__.vals_r("spatial_scale"), "assigning variable spatial_scale");
      std::vector<double> spatial_scale_free__;
      spatial_scale_free__ = std::vector<double>(spatial_scale_1dim__, std::numeric_limits<double>::quiet_NaN());
      
      current_statement__ = 3;
      for (int sym1__ = 1; sym1__ <= spatial_scale_1dim__; ++sym1__) {
        current_statement__ = 3;
        assign(spatial_scale_free__,
          cons_list(index_uni(sym1__), nil_index_list()),
          stan::math::lb_free(spatial_scale[(sym1__ - 1)], 0),
          "assigning variable spatial_scale_free__");}
      Eigen::Matrix<double, -1, 1> theta_tilde;
      theta_tilde = Eigen::Matrix<double, -1, 1>(theta_tilde_1dim__);
      stan::math::fill(theta_tilde, std::numeric_limits<double>::quiet_NaN());
      
      {
        std::vector<local_scalar_t__> theta_tilde_flat__;
        current_statement__ = 4;
        assign(theta_tilde_flat__, nil_index_list(),
          context__.vals_r("theta_tilde"),
          "assigning variable theta_tilde_flat__");
        current_statement__ = 4;
        pos__ = 1;
        current_statement__ = 4;
        for (int sym1__ = 1; sym1__ <= theta_tilde_1dim__; ++sym1__) {
          current_statement__ = 4;
          assign(theta_tilde, cons_list(index_uni(sym1__), nil_index_list()),
            theta_tilde_flat__[(pos__ - 1)], "assigning variable theta_tilde");
          current_statement__ = 4;
          pos__ = (pos__ + 1);}
      }
      std::vector<double> theta_scale;
      theta_scale = std::vector<double>(theta_scale_1dim__, std::numeric_limits<double>::quiet_NaN());
      
      current_statement__ = 5;
      assign(theta_scale, nil_index_list(), context__.vals_r("theta_scale"),
        "assigning variable theta_scale");
      std::vector<double> theta_scale_free__;
      theta_scale_free__ = std::vector<double>(theta_scale_1dim__, std::numeric_limits<double>::quiet_NaN());
      
      current_statement__ = 5;
      for (int sym1__ = 1; sym1__ <= theta_scale_1dim__; ++sym1__) {
        current_statement__ = 5;
        assign(theta_scale_free__,
          cons_list(index_uni(sym1__), nil_index_list()),
          stan::math::lb_free(theta_scale[(sym1__ - 1)], 0),
          "assigning variable theta_scale_free__");}
      std::vector<double> rho;
      rho = std::vector<double>(rho_1dim__, std::numeric_limits<double>::quiet_NaN());
      
      current_statement__ = 6;
      assign(rho, nil_index_list(), context__.vals_r("rho"),
        "assigning variable rho");
      std::vector<double> rho_free__;
      rho_free__ = std::vector<double>(rho_1dim__, std::numeric_limits<double>::quiet_NaN());
      
      current_statement__ = 6;
      for (int sym1__ = 1; sym1__ <= rho_1dim__; ++sym1__) {
        current_statement__ = 6;
        assign(rho_free__, cons_list(index_uni(sym1__), nil_index_list()),
          stan::math::lub_free(rho[(sym1__ - 1)], 0, 1),
          "assigning variable rho_free__");}
      std::vector<double> aux1_global;
      aux1_global = std::vector<double>(aux1_global_1dim__, std::numeric_limits<double>::quiet_NaN());
      
      current_statement__ = 7;
      assign(aux1_global, nil_index_list(), context__.vals_r("aux1_global"),
        "assigning variable aux1_global");
      std::vector<double> aux1_global_free__;
      aux1_global_free__ = std::vector<double>(aux1_global_1dim__, std::numeric_limits<double>::quiet_NaN());
      
      current_statement__ = 7;
      for (int sym1__ = 1; sym1__ <= aux1_global_1dim__; ++sym1__) {
        current_statement__ = 7;
        assign(aux1_global_free__,
          cons_list(index_uni(sym1__), nil_index_list()),
          stan::math::lb_free(aux1_global[(sym1__ - 1)], 0),
          "assigning variable aux1_global_free__");}
      std::vector<double> aux2_global;
      aux2_global = std::vector<double>(aux2_global_1dim__, std::numeric_limits<double>::quiet_NaN());
      
      current_statement__ = 8;
      assign(aux2_global, nil_index_list(), context__.vals_r("aux2_global"),
        "assigning variable aux2_global");
      std::vector<double> aux2_global_free__;
      aux2_global_free__ = std::vector<double>(aux2_global_1dim__, std::numeric_limits<double>::quiet_NaN());
      
      current_statement__ = 8;
      for (int sym1__ = 1; sym1__ <= aux2_global_1dim__; ++sym1__) {
        current_statement__ = 8;
        assign(aux2_global_free__,
          cons_list(index_uni(sym1__), nil_index_list()),
          stan::math::lb_free(aux2_global[(sym1__ - 1)], 0),
          "assigning variable aux2_global_free__");}
      Eigen::Matrix<double, -1, 1> aux1_local;
      aux1_local = Eigen::Matrix<double, -1, 1>(dev);
      stan::math::fill(aux1_local, std::numeric_limits<double>::quiet_NaN());
      
      {
        std::vector<local_scalar_t__> aux1_local_flat__;
        current_statement__ = 9;
        assign(aux1_local_flat__, nil_index_list(),
          context__.vals_r("aux1_local"),
          "assigning variable aux1_local_flat__");
        current_statement__ = 9;
        pos__ = 1;
        current_statement__ = 9;
        for (int sym1__ = 1; sym1__ <= dev; ++sym1__) {
          current_statement__ = 9;
          assign(aux1_local, cons_list(index_uni(sym1__), nil_index_list()),
            aux1_local_flat__[(pos__ - 1)], "assigning variable aux1_local");
          current_statement__ = 9;
          pos__ = (pos__ + 1);}
      }
      Eigen::Matrix<double, -1, 1> aux1_local_free__;
      aux1_local_free__ = Eigen::Matrix<double, -1, 1>(dev);
      stan::math::fill(aux1_local_free__, std::numeric_limits<double>::quiet_NaN());
      
      current_statement__ = 9;
      for (int sym1__ = 1; sym1__ <= dev; ++sym1__) {
        current_statement__ = 9;
        assign(aux1_local_free__,
          cons_list(index_uni(sym1__), nil_index_list()),
          stan::math::lb_free(aux1_local[(sym1__ - 1)], 0),
          "assigning variable aux1_local_free__");}
      Eigen::Matrix<double, -1, 1> aux2_local;
      aux2_local = Eigen::Matrix<double, -1, 1>(dev);
      stan::math::fill(aux2_local, std::numeric_limits<double>::quiet_NaN());
      
      {
        std::vector<local_scalar_t__> aux2_local_flat__;
        current_statement__ = 10;
        assign(aux2_local_flat__, nil_index_list(),
          context__.vals_r("aux2_local"),
          "assigning variable aux2_local_flat__");
        current_statement__ = 10;
        pos__ = 1;
        current_statement__ = 10;
        for (int sym1__ = 1; sym1__ <= dev; ++sym1__) {
          current_statement__ = 10;
          assign(aux2_local, cons_list(index_uni(sym1__), nil_index_list()),
            aux2_local_flat__[(pos__ - 1)], "assigning variable aux2_local");
          current_statement__ = 10;
          pos__ = (pos__ + 1);}
      }
      Eigen::Matrix<double, -1, 1> aux2_local_free__;
      aux2_local_free__ = Eigen::Matrix<double, -1, 1>(dev);
      stan::math::fill(aux2_local_free__, std::numeric_limits<double>::quiet_NaN());
      
      current_statement__ = 10;
      for (int sym1__ = 1; sym1__ <= dev; ++sym1__) {
        current_statement__ = 10;
        assign(aux2_local_free__,
          cons_list(index_uni(sym1__), nil_index_list()),
          stan::math::lb_free(aux2_local[(sym1__ - 1)], 0),
          "assigning variable aux2_local_free__");}
      std::vector<double> caux;
      caux = std::vector<double>(caux_1dim__, std::numeric_limits<double>::quiet_NaN());
      
      current_statement__ = 11;
      assign(caux, nil_index_list(), context__.vals_r("caux"),
        "assigning variable caux");
      std::vector<double> caux_free__;
      caux_free__ = std::vector<double>(caux_1dim__, std::numeric_limits<double>::quiet_NaN());
      
      current_statement__ = 11;
      for (int sym1__ = 1; sym1__ <= caux_1dim__; ++sym1__) {
        current_statement__ = 11;
        assign(caux_free__, cons_list(index_uni(sym1__), nil_index_list()),
          stan::math::lb_free(caux[(sym1__ - 1)], 0),
          "assigning variable caux_free__");}
      Eigen::Matrix<double, -1, 1> z;
      z = Eigen::Matrix<double, -1, 1>(dev);
      stan::math::fill(z, std::numeric_limits<double>::quiet_NaN());
      
      {
        std::vector<local_scalar_t__> z_flat__;
        current_statement__ = 12;
        assign(z_flat__, nil_index_list(), context__.vals_r("z"),
          "assigning variable z_flat__");
        current_statement__ = 12;
        pos__ = 1;
        current_statement__ = 12;
        for (int sym1__ = 1; sym1__ <= dev; ++sym1__) {
          current_statement__ = 12;
          assign(z, cons_list(index_uni(sym1__), nil_index_list()),
            z_flat__[(pos__ - 1)], "assigning variable z");
          current_statement__ = 12;
          pos__ = (pos__ + 1);}
      }
      Eigen::Matrix<double, -1, 1> log_lambda;
      log_lambda = Eigen::Matrix<double, -1, 1>(log_lambda_1dim__);
      stan::math::fill(log_lambda, std::numeric_limits<double>::quiet_NaN());
      
      {
        std::vector<local_scalar_t__> log_lambda_flat__;
        current_statement__ = 13;
        assign(log_lambda_flat__, nil_index_list(),
          context__.vals_r("log_lambda"),
          "assigning variable log_lambda_flat__");
        current_statement__ = 13;
        pos__ = 1;
        current_statement__ = 13;
        for (int sym1__ = 1; sym1__ <= log_lambda_1dim__; ++sym1__) {
          current_statement__ = 13;
          assign(log_lambda, cons_list(index_uni(sym1__), nil_index_list()),
            log_lambda_flat__[(pos__ - 1)], "assigning variable log_lambda");
          current_statement__ = 13;
          pos__ = (pos__ + 1);}
      }
      std::vector<double> car_scale;
      car_scale = std::vector<double>(car_scale_1dim__, std::numeric_limits<double>::quiet_NaN());
      
      current_statement__ = 14;
      assign(car_scale, nil_index_list(), context__.vals_r("car_scale"),
        "assigning variable car_scale");
      std::vector<double> car_scale_free__;
      car_scale_free__ = std::vector<double>(car_scale_1dim__, std::numeric_limits<double>::quiet_NaN());
      
      current_statement__ = 14;
      for (int sym1__ = 1; sym1__ <= car_scale_1dim__; ++sym1__) {
        current_statement__ = 14;
        assign(car_scale_free__,
          cons_list(index_uni(sym1__), nil_index_list()),
          stan::math::lb_free(car_scale[(sym1__ - 1)], 0),
          "assigning variable car_scale_free__");}
      std::vector<double> car_rho;
      car_rho = std::vector<double>(car_rho_1dim__, std::numeric_limits<double>::quiet_NaN());
      
      current_statement__ = 15;
      assign(car_rho, nil_index_list(), context__.vals_r("car_rho"),
        "assigning variable car_rho");
      std::vector<double> car_rho_free__;
      car_rho_free__ = std::vector<double>(car_rho_1dim__, std::numeric_limits<double>::quiet_NaN());
      
      current_statement__ = 15;
      for (int sym1__ = 1; sym1__ <= car_rho_1dim__; ++sym1__) {
        current_statement__ = 15;
        assign(car_rho_free__,
          cons_list(index_uni(sym1__), nil_index_list()),
          stan::math::lub_free(car_rho[(sym1__ - 1)], car_rho_lims[(1 - 1)],
            car_rho_lims[(2 - 1)]), "assigning variable car_rho_free__");}
      std::vector<double> sar_scale;
      sar_scale = std::vector<double>(sar_scale_1dim__, std::numeric_limits<double>::quiet_NaN());
      
      current_statement__ = 16;
      assign(sar_scale, nil_index_list(), context__.vals_r("sar_scale"),
        "assigning variable sar_scale");
      std::vector<double> sar_scale_free__;
      sar_scale_free__ = std::vector<double>(sar_scale_1dim__, std::numeric_limits<double>::quiet_NaN());
      
      current_statement__ = 16;
      for (int sym1__ = 1; sym1__ <= sar_scale_1dim__; ++sym1__) {
        current_statement__ = 16;
        assign(sar_scale_free__,
          cons_list(index_uni(sym1__), nil_index_list()),
          stan::math::lb_free(sar_scale[(sym1__ - 1)], 0),
          "assigning variable sar_scale_free__");}
      std::vector<double> sar_rho;
      sar_rho = std::vector<double>(sar_rho_1dim__, std::numeric_limits<double>::quiet_NaN());
      
      current_statement__ = 17;
      assign(sar_rho, nil_index_list(), context__.vals_r("sar_rho"),
        "assigning variable sar_rho");
      std::vector<double> sar_rho_free__;
      sar_rho_free__ = std::vector<double>(sar_rho_1dim__, std::numeric_limits<double>::quiet_NaN());
      
      current_statement__ = 17;
      for (int sym1__ = 1; sym1__ <= sar_rho_1dim__; ++sym1__) {
        current_statement__ = 17;
        assign(sar_rho_free__,
          cons_list(index_uni(sym1__), nil_index_list()),
          stan::math::lub_free(sar_rho[(sym1__ - 1)], sar_rho_lims[(1 - 1)],
            sar_rho_lims[(2 - 1)]), "assigning variable sar_rho_free__");}
      double intercept;
      intercept = std::numeric_limits<double>::quiet_NaN();
      
      current_statement__ = 18;
      intercept = context__.vals_r("intercept")[(1 - 1)];
      Eigen::Matrix<double, -1, 1> gamma;
      gamma = Eigen::Matrix<double, -1, 1>(dwx);
      stan::math::fill(gamma, std::numeric_limits<double>::quiet_NaN());
      
      {
        std::vector<local_scalar_t__> gamma_flat__;
        current_statement__ = 19;
        assign(gamma_flat__, nil_index_list(), context__.vals_r("gamma"),
          "assigning variable gamma_flat__");
        current_statement__ = 19;
        pos__ = 1;
        current_statement__ = 19;
        for (int sym1__ = 1; sym1__ <= dwx; ++sym1__) {
          current_statement__ = 19;
          assign(gamma, cons_list(index_uni(sym1__), nil_index_list()),
            gamma_flat__[(pos__ - 1)], "assigning variable gamma");
          current_statement__ = 19;
          pos__ = (pos__ + 1);}
      }
      Eigen::Matrix<double, -1, 1> beta;
      beta = Eigen::Matrix<double, -1, 1>(dx_all);
      stan::math::fill(beta, std::numeric_limits<double>::quiet_NaN());
      
      {
        std::vector<local_scalar_t__> beta_flat__;
        current_statement__ = 20;
        assign(beta_flat__, nil_index_list(), context__.vals_r("beta"),
          "assigning variable beta_flat__");
        current_statement__ = 20;
        pos__ = 1;
        current_statement__ = 20;
        for (int sym1__ = 1; sym1__ <= dx_all; ++sym1__) {
          current_statement__ = 20;
          assign(beta, cons_list(index_uni(sym1__), nil_index_list()),
            beta_flat__[(pos__ - 1)], "assigning variable beta");
          current_statement__ = 20;
          pos__ = (pos__ + 1);}
      }
      std::vector<double> nu;
      nu = std::vector<double>(is_student, std::numeric_limits<double>::quiet_NaN());
      
      current_statement__ = 21;
      assign(nu, nil_index_list(), context__.vals_r("nu"),
        "assigning variable nu");
      std::vector<double> nu_free__;
      nu_free__ = std::vector<double>(is_student, std::numeric_limits<double>::quiet_NaN());
      
      current_statement__ = 21;
      for (int sym1__ = 1; sym1__ <= is_student; ++sym1__) {
        current_statement__ = 21;
        assign(nu_free__, cons_list(index_uni(sym1__), nil_index_list()),
          stan::math::lb_free(nu[(sym1__ - 1)], 0),
          "assigning variable nu_free__");}
      std::vector<double> sigma;
      sigma = std::vector<double>(has_sigma, std::numeric_limits<double>::quiet_NaN());
      
      current_statement__ = 22;
      assign(sigma, nil_index_list(), context__.vals_r("sigma"),
        "assigning variable sigma");
      std::vector<double> sigma_free__;
      sigma_free__ = std::vector<double>(has_sigma, std::numeric_limits<double>::quiet_NaN());
      
      current_statement__ = 22;
      for (int sym1__ = 1; sym1__ <= has_sigma; ++sym1__) {
        current_statement__ = 22;
        assign(sigma_free__, cons_list(index_uni(sym1__), nil_index_list()),
          stan::math::lb_free(sigma[(sym1__ - 1)], 0),
          "assigning variable sigma_free__");}
      Eigen::Matrix<double, -1, 1> alpha_re;
      alpha_re = Eigen::Matrix<double, -1, 1>(n_ids);
      stan::math::fill(alpha_re, std::numeric_limits<double>::quiet_NaN());
      
      {
        std::vector<local_scalar_t__> alpha_re_flat__;
        current_statement__ = 23;
        assign(alpha_re_flat__, nil_index_list(),
          context__.vals_r("alpha_re"), "assigning variable alpha_re_flat__");
        current_statement__ = 23;
        pos__ = 1;
        current_statement__ = 23;
        for (int sym1__ = 1; sym1__ <= n_ids; ++sym1__) {
          current_statement__ = 23;
          assign(alpha_re, cons_list(index_uni(sym1__), nil_index_list()),
            alpha_re_flat__[(pos__ - 1)], "assigning variable alpha_re");
          current_statement__ = 23;
          pos__ = (pos__ + 1);}
      }
      std::vector<double> alpha_tau;
      alpha_tau = std::vector<double>(has_re, std::numeric_limits<double>::quiet_NaN());
      
      current_statement__ = 24;
      assign(alpha_tau, nil_index_list(), context__.vals_r("alpha_tau"),
        "assigning variable alpha_tau");
      std::vector<double> alpha_tau_free__;
      alpha_tau_free__ = std::vector<double>(has_re, std::numeric_limits<double>::quiet_NaN());
      
      current_statement__ = 24;
      for (int sym1__ = 1; sym1__ <= has_re; ++sym1__) {
        current_statement__ = 24;
        assign(alpha_tau_free__,
          cons_list(index_uni(sym1__), nil_index_list()),
          stan::math::lb_free(alpha_tau[(sym1__ - 1)], 0),
          "assigning variable alpha_tau_free__");}
      std::vector<Eigen::Matrix<double, -1, 1>> x_true;
      x_true = std::vector<Eigen::Matrix<double, -1, 1>>(dx_me, Eigen::Matrix<double, -1, 1>(n));
      stan::math::fill(x_true, std::numeric_limits<double>::quiet_NaN());
      
      {
        std::vector<local_scalar_t__> x_true_flat__;
        current_statement__ = 25;
        assign(x_true_flat__, nil_index_list(), context__.vals_r("x_true"),
          "assigning variable x_true_flat__");
        current_statement__ = 25;
        pos__ = 1;
        current_statement__ = 25;
        for (int sym1__ = 1; sym1__ <= n; ++sym1__) {
          current_statement__ = 25;
          for (int sym2__ = 1; sym2__ <= dx_me; ++sym2__) {
            current_statement__ = 25;
            assign(x_true,
              cons_list(index_uni(sym2__),
                cons_list(index_uni(sym1__), nil_index_list())),
              x_true_flat__[(pos__ - 1)], "assigning variable x_true");
            current_statement__ = 25;
            pos__ = (pos__ + 1);}}
      }
      std::vector<Eigen::Matrix<double, -1, 1>> x_true_free__;
      x_true_free__ = std::vector<Eigen::Matrix<double, -1, 1>>(dx_me, Eigen::Matrix<double, -1, 1>(n));
      stan::math::fill(x_true_free__, std::numeric_limits<double>::quiet_NaN());
      
      current_statement__ = 25;
      for (int sym1__ = 1; sym1__ <= dx_me; ++sym1__) {
        current_statement__ = 25;
        for (int sym2__ = 1; sym2__ <= n; ++sym2__) {
          current_statement__ = 25;
          assign(x_true_free__,
            cons_list(index_uni(sym1__),
              cons_list(index_uni(sym2__), nil_index_list())),
            stan::math::lub_free(x_true[(sym1__ - 1)][(sym2__ - 1)],
              bounds[(1 - 1)], bounds[(2 - 1)]),
            "assigning variable x_true_free__");}}
      Eigen::Matrix<double, -1, 1> mu_x_true;
      mu_x_true = Eigen::Matrix<double, -1, 1>(dx_me);
      stan::math::fill(mu_x_true, std::numeric_limits<double>::quiet_NaN());
      
      {
        std::vector<local_scalar_t__> mu_x_true_flat__;
        current_statement__ = 26;
        assign(mu_x_true_flat__, nil_index_list(),
          context__.vals_r("mu_x_true"),
          "assigning variable mu_x_true_flat__");
        current_statement__ = 26;
        pos__ = 1;
        current_statement__ = 26;
        for (int sym1__ = 1; sym1__ <= dx_me; ++sym1__) {
          current_statement__ = 26;
          assign(mu_x_true, cons_list(index_uni(sym1__), nil_index_list()),
            mu_x_true_flat__[(pos__ - 1)], "assigning variable mu_x_true");
          current_statement__ = 26;
          pos__ = (pos__ + 1);}
      }
      Eigen::Matrix<double, -1, 1> sigma_x_true;
      sigma_x_true = Eigen::Matrix<double, -1, 1>(dx_me);
      stan::math::fill(sigma_x_true, std::numeric_limits<double>::quiet_NaN());
      
      {
        std::vector<local_scalar_t__> sigma_x_true_flat__;
        current_statement__ = 27;
        assign(sigma_x_true_flat__, nil_index_list(),
          context__.vals_r("sigma_x_true"),
          "assigning variable sigma_x_true_flat__");
        current_statement__ = 27;
        pos__ = 1;
        current_statement__ = 27;
        for (int sym1__ = 1; sym1__ <= dx_me; ++sym1__) {
          current_statement__ = 27;
          assign(sigma_x_true,
            cons_list(index_uni(sym1__), nil_index_list()),
            sigma_x_true_flat__[(pos__ - 1)],
            "assigning variable sigma_x_true");
          current_statement__ = 27;
          pos__ = (pos__ + 1);}
      }
      Eigen::Matrix<double, -1, 1> sigma_x_true_free__;
      sigma_x_true_free__ = Eigen::Matrix<double, -1, 1>(dx_me);
      stan::math::fill(sigma_x_true_free__, std::numeric_limits<double>::quiet_NaN());
      
      current_statement__ = 27;
      for (int sym1__ = 1; sym1__ <= dx_me; ++sym1__) {
        current_statement__ = 27;
        assign(sigma_x_true_free__,
          cons_list(index_uni(sym1__), nil_index_list()),
          stan::math::lb_free(sigma_x_true[(sym1__ - 1)], 0),
          "assigning variable sigma_x_true_free__");}
      Eigen::Matrix<double, -1, 1> car_rho_x_true;
      car_rho_x_true = Eigen::Matrix<double, -1, 1>(car_rho_x_true_1dim__);
      stan::math::fill(car_rho_x_true, std::numeric_limits<double>::quiet_NaN());
      
      {
        std::vector<local_scalar_t__> car_rho_x_true_flat__;
        current_statement__ = 28;
        assign(car_rho_x_true_flat__, nil_index_list(),
          context__.vals_r("car_rho_x_true"),
          "assigning variable car_rho_x_true_flat__");
        current_statement__ = 28;
        pos__ = 1;
        current_statement__ = 28;
        for (int sym1__ = 1; sym1__ <= car_rho_x_true_1dim__; ++sym1__) {
          current_statement__ = 28;
          assign(car_rho_x_true,
            cons_list(index_uni(sym1__), nil_index_list()),
            car_rho_x_true_flat__[(pos__ - 1)],
            "assigning variable car_rho_x_true");
          current_statement__ = 28;
          pos__ = (pos__ + 1);}
      }
      Eigen::Matrix<double, -1, 1> car_rho_x_true_free__;
      car_rho_x_true_free__ = Eigen::Matrix<double, -1, 1>(car_rho_x_true_1dim__);
      stan::math::fill(car_rho_x_true_free__, std::numeric_limits<double>::quiet_NaN());
      
      current_statement__ = 28;
      for (int sym1__ = 1; sym1__ <= car_rho_x_true_1dim__; ++sym1__) {
        current_statement__ = 28;
        assign(car_rho_x_true_free__,
          cons_list(index_uni(sym1__), nil_index_list()),
          stan::math::lub_free(car_rho_x_true[(sym1__ - 1)],
            prior_rhox_true[(1 - 1)], prior_rhox_true[(2 - 1)]),
          "assigning variable car_rho_x_true_free__");}
      Eigen::Matrix<double, -1, 1> nu_x_true;
      nu_x_true = Eigen::Matrix<double, -1, 1>(nu_x_true_1dim__);
      stan::math::fill(nu_x_true, std::numeric_limits<double>::quiet_NaN());
      
      {
        std::vector<local_scalar_t__> nu_x_true_flat__;
        current_statement__ = 29;
        assign(nu_x_true_flat__, nil_index_list(),
          context__.vals_r("nu_x_true"),
          "assigning variable nu_x_true_flat__");
        current_statement__ = 29;
        pos__ = 1;
        current_statement__ = 29;
        for (int sym1__ = 1; sym1__ <= nu_x_true_1dim__; ++sym1__) {
          current_statement__ = 29;
          assign(nu_x_true, cons_list(index_uni(sym1__), nil_index_list()),
            nu_x_true_flat__[(pos__ - 1)], "assigning variable nu_x_true");
          current_statement__ = 29;
          pos__ = (pos__ + 1);}
      }
      Eigen::Matrix<double, -1, 1> nu_x_true_free__;
      nu_x_true_free__ = Eigen::Matrix<double, -1, 1>(nu_x_true_1dim__);
      stan::math::fill(nu_x_true_free__, std::numeric_limits<double>::quiet_NaN());
      
      current_statement__ = 29;
      for (int sym1__ = 1; sym1__ <= nu_x_true_1dim__; ++sym1__) {
        current_statement__ = 29;
        assign(nu_x_true_free__,
          cons_list(index_uni(sym1__), nil_index_list()),
          stan::math::lb_free(nu_x_true[(sym1__ - 1)], 0),
          "assigning variable nu_x_true_free__");}
      for (int sym1__ = 1; sym1__ <= m; ++sym1__) {
        vars__.emplace_back(alpha_phi[(sym1__ - 1)]);}
      for (int sym1__ = 1; sym1__ <= phi_tilde_1dim__; ++sym1__) {
        vars__.emplace_back(phi_tilde[(sym1__ - 1)]);}
      for (int sym1__ = 1; sym1__ <= spatial_scale_1dim__; ++sym1__) {
        vars__.emplace_back(spatial_scale_free__[(sym1__ - 1)]);}
      for (int sym1__ = 1; sym1__ <= theta_tilde_1dim__; ++sym1__) {
        vars__.emplace_back(theta_tilde[(sym1__ - 1)]);}
      for (int sym1__ = 1; sym1__ <= theta_scale_1dim__; ++sym1__) {
        vars__.emplace_back(theta_scale_free__[(sym1__ - 1)]);}
      for (int sym1__ = 1; sym1__ <= rho_1dim__; ++sym1__) {
        vars__.emplace_back(rho_free__[(sym1__ - 1)]);}
      for (int sym1__ = 1; sym1__ <= aux1_global_1dim__; ++sym1__) {
        vars__.emplace_back(aux1_global_free__[(sym1__ - 1)]);}
      for (int sym1__ = 1; sym1__ <= aux2_global_1dim__; ++sym1__) {
        vars__.emplace_back(aux2_global_free__[(sym1__ - 1)]);}
      for (int sym1__ = 1; sym1__ <= dev; ++sym1__) {
        vars__.emplace_back(aux1_local_free__[(sym1__ - 1)]);}
      for (int sym1__ = 1; sym1__ <= dev; ++sym1__) {
        vars__.emplace_back(aux2_local_free__[(sym1__ - 1)]);}
      for (int sym1__ = 1; sym1__ <= caux_1dim__; ++sym1__) {
        vars__.emplace_back(caux_free__[(sym1__ - 1)]);}
      for (int sym1__ = 1; sym1__ <= dev; ++sym1__) {
        vars__.emplace_back(z[(sym1__ - 1)]);}
      for (int sym1__ = 1; sym1__ <= log_lambda_1dim__; ++sym1__) {
        vars__.emplace_back(log_lambda[(sym1__ - 1)]);}
      for (int sym1__ = 1; sym1__ <= car_scale_1dim__; ++sym1__) {
        vars__.emplace_back(car_scale_free__[(sym1__ - 1)]);}
      for (int sym1__ = 1; sym1__ <= car_rho_1dim__; ++sym1__) {
        vars__.emplace_back(car_rho_free__[(sym1__ - 1)]);}
      for (int sym1__ = 1; sym1__ <= sar_scale_1dim__; ++sym1__) {
        vars__.emplace_back(sar_scale_free__[(sym1__ - 1)]);}
      for (int sym1__ = 1; sym1__ <= sar_rho_1dim__; ++sym1__) {
        vars__.emplace_back(sar_rho_free__[(sym1__ - 1)]);}
      vars__.emplace_back(intercept);
      for (int sym1__ = 1; sym1__ <= dwx; ++sym1__) {
        vars__.emplace_back(gamma[(sym1__ - 1)]);}
      for (int sym1__ = 1; sym1__ <= dx_all; ++sym1__) {
        vars__.emplace_back(beta[(sym1__ - 1)]);}
      for (int sym1__ = 1; sym1__ <= is_student; ++sym1__) {
        vars__.emplace_back(nu_free__[(sym1__ - 1)]);}
      for (int sym1__ = 1; sym1__ <= has_sigma; ++sym1__) {
        vars__.emplace_back(sigma_free__[(sym1__ - 1)]);}
      for (int sym1__ = 1; sym1__ <= n_ids; ++sym1__) {
        vars__.emplace_back(alpha_re[(sym1__ - 1)]);}
      for (int sym1__ = 1; sym1__ <= has_re; ++sym1__) {
        vars__.emplace_back(alpha_tau_free__[(sym1__ - 1)]);}
      for (int sym1__ = 1; sym1__ <= dx_me; ++sym1__) {
        for (int sym2__ = 1; sym2__ <= n; ++sym2__) {
          vars__.emplace_back(x_true_free__[(sym1__ - 1)][(sym2__ - 1)]);}}
      for (int sym1__ = 1; sym1__ <= dx_me; ++sym1__) {
        vars__.emplace_back(mu_x_true[(sym1__ - 1)]);}
      for (int sym1__ = 1; sym1__ <= dx_me; ++sym1__) {
        vars__.emplace_back(sigma_x_true_free__[(sym1__ - 1)]);}
      for (int sym1__ = 1; sym1__ <= car_rho_x_true_1dim__; ++sym1__) {
        vars__.emplace_back(car_rho_x_true_free__[(sym1__ - 1)]);}
      for (int sym1__ = 1; sym1__ <= nu_x_true_1dim__; ++sym1__) {
        vars__.emplace_back(nu_x_true_free__[(sym1__ - 1)]);}
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
    }
    } // transform_inits_impl() 
    
  inline void get_param_names(std::vector<std::string>& names__) const {
    
    names__.clear();
    names__.emplace_back("alpha_phi");
    names__.emplace_back("phi_tilde");
    names__.emplace_back("spatial_scale");
    names__.emplace_back("theta_tilde");
    names__.emplace_back("theta_scale");
    names__.emplace_back("rho");
    names__.emplace_back("aux1_global");
    names__.emplace_back("aux2_global");
    names__.emplace_back("aux1_local");
    names__.emplace_back("aux2_local");
    names__.emplace_back("caux");
    names__.emplace_back("z");
    names__.emplace_back("log_lambda");
    names__.emplace_back("car_scale");
    names__.emplace_back("car_rho");
    names__.emplace_back("sar_scale");
    names__.emplace_back("sar_rho");
    names__.emplace_back("intercept");
    names__.emplace_back("gamma");
    names__.emplace_back("beta");
    names__.emplace_back("nu");
    names__.emplace_back("sigma");
    names__.emplace_back("alpha_re");
    names__.emplace_back("alpha_tau");
    names__.emplace_back("x_true");
    names__.emplace_back("mu_x_true");
    names__.emplace_back("sigma_x_true");
    names__.emplace_back("car_rho_x_true");
    names__.emplace_back("nu_x_true");
    names__.emplace_back("beta_ev");
    names__.emplace_back("esf");
    names__.emplace_back("error_scale");
    names__.emplace_back("phi");
    names__.emplace_back("theta");
    names__.emplace_back("log_lambda_mu");
    names__.emplace_back("x_all");
    names__.emplace_back("fitted");
    names__.emplace_back("log_lik");
    } // get_param_names() 
    
  inline void get_dims(std::vector<std::vector<size_t>>& dimss__) const {
    dimss__.clear();
    dimss__.emplace_back(std::vector<size_t>{static_cast<size_t>(m)});
    
    dimss__.emplace_back(std::vector<size_t>{
                                             static_cast<size_t>(phi_tilde_1dim__)
                                             });
    
    dimss__.emplace_back(std::vector<size_t>{
                                             static_cast<size_t>(spatial_scale_1dim__)
                                             });
    
    dimss__.emplace_back(std::vector<size_t>{
                                             static_cast<size_t>(theta_tilde_1dim__)
                                             });
    
    dimss__.emplace_back(std::vector<size_t>{
                                             static_cast<size_t>(theta_scale_1dim__)
                                             });
    
    dimss__.emplace_back(std::vector<size_t>{static_cast<size_t>(rho_1dim__)});
    
    dimss__.emplace_back(std::vector<size_t>{
                                             static_cast<size_t>(aux1_global_1dim__)
                                             });
    
    dimss__.emplace_back(std::vector<size_t>{
                                             static_cast<size_t>(aux2_global_1dim__)
                                             });
    
    dimss__.emplace_back(std::vector<size_t>{static_cast<size_t>(dev)});
    
    dimss__.emplace_back(std::vector<size_t>{static_cast<size_t>(dev)});
    
    dimss__.emplace_back(std::vector<size_t>{static_cast<size_t>(caux_1dim__)});
    
    dimss__.emplace_back(std::vector<size_t>{static_cast<size_t>(dev)});
    
    dimss__.emplace_back(std::vector<size_t>{
                                             static_cast<size_t>(log_lambda_1dim__)
                                             });
    
    dimss__.emplace_back(std::vector<size_t>{
                                             static_cast<size_t>(car_scale_1dim__)
                                             });
    
    dimss__.emplace_back(std::vector<size_t>{
                                             static_cast<size_t>(car_rho_1dim__)
                                             });
    
    dimss__.emplace_back(std::vector<size_t>{
                                             static_cast<size_t>(sar_scale_1dim__)
                                             });
    
    dimss__.emplace_back(std::vector<size_t>{
                                             static_cast<size_t>(sar_rho_1dim__)
                                             });
    
    dimss__.emplace_back(std::vector<size_t>{});
    
    dimss__.emplace_back(std::vector<size_t>{static_cast<size_t>(dwx)});
    
    dimss__.emplace_back(std::vector<size_t>{static_cast<size_t>(dx_all)});
    
    dimss__.emplace_back(std::vector<size_t>{static_cast<size_t>(is_student)});
    
    dimss__.emplace_back(std::vector<size_t>{static_cast<size_t>(has_sigma)});
    
    dimss__.emplace_back(std::vector<size_t>{static_cast<size_t>(n_ids)});
    
    dimss__.emplace_back(std::vector<size_t>{static_cast<size_t>(has_re)});
    
    dimss__.emplace_back(std::vector<size_t>{static_cast<size_t>(dx_me),
                                             static_cast<size_t>(n)});
    
    dimss__.emplace_back(std::vector<size_t>{static_cast<size_t>(dx_me)});
    
    dimss__.emplace_back(std::vector<size_t>{static_cast<size_t>(dx_me)});
    
    dimss__.emplace_back(std::vector<size_t>{
                                             static_cast<size_t>(car_rho_x_true_1dim__)
                                             });
    
    dimss__.emplace_back(std::vector<size_t>{
                                             static_cast<size_t>(nu_x_true_1dim__)
                                             });
    
    dimss__.emplace_back(std::vector<size_t>{static_cast<size_t>(dev)});
    
    dimss__.emplace_back(std::vector<size_t>{static_cast<size_t>(esf_1dim__)});
    
    dimss__.emplace_back(std::vector<size_t>{
                                             static_cast<size_t>(error_scale_1dim__)
                                             });
    
    dimss__.emplace_back(std::vector<size_t>{static_cast<size_t>(phi_1dim__)});
    
    dimss__.emplace_back(std::vector<size_t>{
                                             static_cast<size_t>(theta_1dim__)});
    
    dimss__.emplace_back(std::vector<size_t>{
                                             static_cast<size_t>(log_lambda_mu_1dim__)
                                             });
    
    dimss__.emplace_back(std::vector<size_t>{static_cast<size_t>(n),
                                             static_cast<size_t>(dx_all)});
    
    dimss__.emplace_back(std::vector<size_t>{static_cast<size_t>(n)});
    
    dimss__.emplace_back(std::vector<size_t>{
                                             static_cast<size_t>(log_lik_1dim__)
                                             });
    
    } // get_dims() 
    
  inline void constrained_param_names(
                                      std::vector<std::string>& param_names__,
                                      bool emit_transformed_parameters__ = true,
                                      bool emit_generated_quantities__ = true) const
    final {
    
    for (int sym1__ = 1; sym1__ <= m; ++sym1__) {
      {
        param_names__.emplace_back(std::string() + "alpha_phi" + '.' + std::to_string(sym1__));
      }}
    for (int sym1__ = 1; sym1__ <= phi_tilde_1dim__; ++sym1__) {
      {
        param_names__.emplace_back(std::string() + "phi_tilde" + '.' + std::to_string(sym1__));
      }}
    for (int sym1__ = 1; sym1__ <= spatial_scale_1dim__; ++sym1__) {
      {
        param_names__.emplace_back(std::string() + "spatial_scale" + '.' + std::to_string(sym1__));
      }}
    for (int sym1__ = 1; sym1__ <= theta_tilde_1dim__; ++sym1__) {
      {
        param_names__.emplace_back(std::string() + "theta_tilde" + '.' + std::to_string(sym1__));
      }}
    for (int sym1__ = 1; sym1__ <= theta_scale_1dim__; ++sym1__) {
      {
        param_names__.emplace_back(std::string() + "theta_scale" + '.' + std::to_string(sym1__));
      }}
    for (int sym1__ = 1; sym1__ <= rho_1dim__; ++sym1__) {
      {
        param_names__.emplace_back(std::string() + "rho" + '.' + std::to_string(sym1__));
      }}
    for (int sym1__ = 1; sym1__ <= aux1_global_1dim__; ++sym1__) {
      {
        param_names__.emplace_back(std::string() + "aux1_global" + '.' + std::to_string(sym1__));
      }}
    for (int sym1__ = 1; sym1__ <= aux2_global_1dim__; ++sym1__) {
      {
        param_names__.emplace_back(std::string() + "aux2_global" + '.' + std::to_string(sym1__));
      }}
    for (int sym1__ = 1; sym1__ <= dev; ++sym1__) {
      {
        param_names__.emplace_back(std::string() + "aux1_local" + '.' + std::to_string(sym1__));
      }}
    for (int sym1__ = 1; sym1__ <= dev; ++sym1__) {
      {
        param_names__.emplace_back(std::string() + "aux2_local" + '.' + std::to_string(sym1__));
      }}
    for (int sym1__ = 1; sym1__ <= caux_1dim__; ++sym1__) {
      {
        param_names__.emplace_back(std::string() + "caux" + '.' + std::to_string(sym1__));
      }}
    for (int sym1__ = 1; sym1__ <= dev; ++sym1__) {
      {
        param_names__.emplace_back(std::string() + "z" + '.' + std::to_string(sym1__));
      }}
    for (int sym1__ = 1; sym1__ <= log_lambda_1dim__; ++sym1__) {
      {
        param_names__.emplace_back(std::string() + "log_lambda" + '.' + std::to_string(sym1__));
      }}
    for (int sym1__ = 1; sym1__ <= car_scale_1dim__; ++sym1__) {
      {
        param_names__.emplace_back(std::string() + "car_scale" + '.' + std::to_string(sym1__));
      }}
    for (int sym1__ = 1; sym1__ <= car_rho_1dim__; ++sym1__) {
      {
        param_names__.emplace_back(std::string() + "car_rho" + '.' + std::to_string(sym1__));
      }}
    for (int sym1__ = 1; sym1__ <= sar_scale_1dim__; ++sym1__) {
      {
        param_names__.emplace_back(std::string() + "sar_scale" + '.' + std::to_string(sym1__));
      }}
    for (int sym1__ = 1; sym1__ <= sar_rho_1dim__; ++sym1__) {
      {
        param_names__.emplace_back(std::string() + "sar_rho" + '.' + std::to_string(sym1__));
      }}
    param_names__.emplace_back(std::string() + "intercept");
    for (int sym1__ = 1; sym1__ <= dwx; ++sym1__) {
      {
        param_names__.emplace_back(std::string() + "gamma" + '.' + std::to_string(sym1__));
      }}
    for (int sym1__ = 1; sym1__ <= dx_all; ++sym1__) {
      {
        param_names__.emplace_back(std::string() + "beta" + '.' + std::to_string(sym1__));
      }}
    for (int sym1__ = 1; sym1__ <= is_student; ++sym1__) {
      {
        param_names__.emplace_back(std::string() + "nu" + '.' + std::to_string(sym1__));
      }}
    for (int sym1__ = 1; sym1__ <= has_sigma; ++sym1__) {
      {
        param_names__.emplace_back(std::string() + "sigma" + '.' + std::to_string(sym1__));
      }}
    for (int sym1__ = 1; sym1__ <= n_ids; ++sym1__) {
      {
        param_names__.emplace_back(std::string() + "alpha_re" + '.' + std::to_string(sym1__));
      }}
    for (int sym1__ = 1; sym1__ <= has_re; ++sym1__) {
      {
        param_names__.emplace_back(std::string() + "alpha_tau" + '.' + std::to_string(sym1__));
      }}
    for (int sym1__ = 1; sym1__ <= n; ++sym1__) {
      {
        for (int sym2__ = 1; sym2__ <= dx_me; ++sym2__) {
          {
            param_names__.emplace_back(std::string() + "x_true" + '.' + std::to_string(sym2__) + '.' + std::to_string(sym1__));
          }}
      }}
    for (int sym1__ = 1; sym1__ <= dx_me; ++sym1__) {
      {
        param_names__.emplace_back(std::string() + "mu_x_true" + '.' + std::to_string(sym1__));
      }}
    for (int sym1__ = 1; sym1__ <= dx_me; ++sym1__) {
      {
        param_names__.emplace_back(std::string() + "sigma_x_true" + '.' + std::to_string(sym1__));
      }}
    for (int sym1__ = 1; sym1__ <= car_rho_x_true_1dim__; ++sym1__) {
      {
        param_names__.emplace_back(std::string() + "car_rho_x_true" + '.' + std::to_string(sym1__));
      }}
    for (int sym1__ = 1; sym1__ <= nu_x_true_1dim__; ++sym1__) {
      {
        param_names__.emplace_back(std::string() + "nu_x_true" + '.' + std::to_string(sym1__));
      }}
    if (emit_transformed_parameters__) {
      for (int sym1__ = 1; sym1__ <= dev; ++sym1__) {
        {
          param_names__.emplace_back(std::string() + "beta_ev" + '.' + std::to_string(sym1__));
        }}
      for (int sym1__ = 1; sym1__ <= esf_1dim__; ++sym1__) {
        {
          param_names__.emplace_back(std::string() + "esf" + '.' + std::to_string(sym1__));
        }}
      for (int sym1__ = 1; sym1__ <= error_scale_1dim__; ++sym1__) {
        {
          param_names__.emplace_back(std::string() + "error_scale" + '.' + std::to_string(sym1__));
        }}
      for (int sym1__ = 1; sym1__ <= phi_1dim__; ++sym1__) {
        {
          param_names__.emplace_back(std::string() + "phi" + '.' + std::to_string(sym1__));
        }}
      for (int sym1__ = 1; sym1__ <= theta_1dim__; ++sym1__) {
        {
          param_names__.emplace_back(std::string() + "theta" + '.' + std::to_string(sym1__));
        }}
      for (int sym1__ = 1; sym1__ <= log_lambda_mu_1dim__; ++sym1__) {
        {
          param_names__.emplace_back(std::string() + "log_lambda_mu" + '.' + std::to_string(sym1__));
        }}
      for (int sym1__ = 1; sym1__ <= dx_all; ++sym1__) {
        {
          for (int sym2__ = 1; sym2__ <= n; ++sym2__) {
            {
              param_names__.emplace_back(std::string() + "x_all" + '.' + std::to_string(sym2__) + '.' + std::to_string(sym1__));
            }}
        }}
      for (int sym1__ = 1; sym1__ <= n; ++sym1__) {
        {
          param_names__.emplace_back(std::string() + "fitted" + '.' + std::to_string(sym1__));
        }}
    }
    
    if (emit_generated_quantities__) {
      for (int sym1__ = 1; sym1__ <= log_lik_1dim__; ++sym1__) {
        {
          param_names__.emplace_back(std::string() + "log_lik" + '.' + std::to_string(sym1__));
        }}
    }
    
    } // constrained_param_names() 
    
  inline void unconstrained_param_names(
                                        std::vector<std::string>& param_names__,
                                        bool emit_transformed_parameters__ = true,
                                        bool emit_generated_quantities__ = true) const
    final {
    
    for (int sym1__ = 1; sym1__ <= m; ++sym1__) {
      {
        param_names__.emplace_back(std::string() + "alpha_phi" + '.' + std::to_string(sym1__));
      }}
    for (int sym1__ = 1; sym1__ <= phi_tilde_1dim__; ++sym1__) {
      {
        param_names__.emplace_back(std::string() + "phi_tilde" + '.' + std::to_string(sym1__));
      }}
    for (int sym1__ = 1; sym1__ <= spatial_scale_1dim__; ++sym1__) {
      {
        param_names__.emplace_back(std::string() + "spatial_scale" + '.' + std::to_string(sym1__));
      }}
    for (int sym1__ = 1; sym1__ <= theta_tilde_1dim__; ++sym1__) {
      {
        param_names__.emplace_back(std::string() + "theta_tilde" + '.' + std::to_string(sym1__));
      }}
    for (int sym1__ = 1; sym1__ <= theta_scale_1dim__; ++sym1__) {
      {
        param_names__.emplace_back(std::string() + "theta_scale" + '.' + std::to_string(sym1__));
      }}
    for (int sym1__ = 1; sym1__ <= rho_1dim__; ++sym1__) {
      {
        param_names__.emplace_back(std::string() + "rho" + '.' + std::to_string(sym1__));
      }}
    for (int sym1__ = 1; sym1__ <= aux1_global_1dim__; ++sym1__) {
      {
        param_names__.emplace_back(std::string() + "aux1_global" + '.' + std::to_string(sym1__));
      }}
    for (int sym1__ = 1; sym1__ <= aux2_global_1dim__; ++sym1__) {
      {
        param_names__.emplace_back(std::string() + "aux2_global" + '.' + std::to_string(sym1__));
      }}
    for (int sym1__ = 1; sym1__ <= dev; ++sym1__) {
      {
        param_names__.emplace_back(std::string() + "aux1_local" + '.' + std::to_string(sym1__));
      }}
    for (int sym1__ = 1; sym1__ <= dev; ++sym1__) {
      {
        param_names__.emplace_back(std::string() + "aux2_local" + '.' + std::to_string(sym1__));
      }}
    for (int sym1__ = 1; sym1__ <= caux_1dim__; ++sym1__) {
      {
        param_names__.emplace_back(std::string() + "caux" + '.' + std::to_string(sym1__));
      }}
    for (int sym1__ = 1; sym1__ <= dev; ++sym1__) {
      {
        param_names__.emplace_back(std::string() + "z" + '.' + std::to_string(sym1__));
      }}
    for (int sym1__ = 1; sym1__ <= log_lambda_1dim__; ++sym1__) {
      {
        param_names__.emplace_back(std::string() + "log_lambda" + '.' + std::to_string(sym1__));
      }}
    for (int sym1__ = 1; sym1__ <= car_scale_1dim__; ++sym1__) {
      {
        param_names__.emplace_back(std::string() + "car_scale" + '.' + std::to_string(sym1__));
      }}
    for (int sym1__ = 1; sym1__ <= car_rho_1dim__; ++sym1__) {
      {
        param_names__.emplace_back(std::string() + "car_rho" + '.' + std::to_string(sym1__));
      }}
    for (int sym1__ = 1; sym1__ <= sar_scale_1dim__; ++sym1__) {
      {
        param_names__.emplace_back(std::string() + "sar_scale" + '.' + std::to_string(sym1__));
      }}
    for (int sym1__ = 1; sym1__ <= sar_rho_1dim__; ++sym1__) {
      {
        param_names__.emplace_back(std::string() + "sar_rho" + '.' + std::to_string(sym1__));
      }}
    param_names__.emplace_back(std::string() + "intercept");
    for (int sym1__ = 1; sym1__ <= dwx; ++sym1__) {
      {
        param_names__.emplace_back(std::string() + "gamma" + '.' + std::to_string(sym1__));
      }}
    for (int sym1__ = 1; sym1__ <= dx_all; ++sym1__) {
      {
        param_names__.emplace_back(std::string() + "beta" + '.' + std::to_string(sym1__));
      }}
    for (int sym1__ = 1; sym1__ <= is_student; ++sym1__) {
      {
        param_names__.emplace_back(std::string() + "nu" + '.' + std::to_string(sym1__));
      }}
    for (int sym1__ = 1; sym1__ <= has_sigma; ++sym1__) {
      {
        param_names__.emplace_back(std::string() + "sigma" + '.' + std::to_string(sym1__));
      }}
    for (int sym1__ = 1; sym1__ <= n_ids; ++sym1__) {
      {
        param_names__.emplace_back(std::string() + "alpha_re" + '.' + std::to_string(sym1__));
      }}
    for (int sym1__ = 1; sym1__ <= has_re; ++sym1__) {
      {
        param_names__.emplace_back(std::string() + "alpha_tau" + '.' + std::to_string(sym1__));
      }}
    for (int sym1__ = 1; sym1__ <= n; ++sym1__) {
      {
        for (int sym2__ = 1; sym2__ <= dx_me; ++sym2__) {
          {
            param_names__.emplace_back(std::string() + "x_true" + '.' + std::to_string(sym2__) + '.' + std::to_string(sym1__));
          }}
      }}
    for (int sym1__ = 1; sym1__ <= dx_me; ++sym1__) {
      {
        param_names__.emplace_back(std::string() + "mu_x_true" + '.' + std::to_string(sym1__));
      }}
    for (int sym1__ = 1; sym1__ <= dx_me; ++sym1__) {
      {
        param_names__.emplace_back(std::string() + "sigma_x_true" + '.' + std::to_string(sym1__));
      }}
    for (int sym1__ = 1; sym1__ <= car_rho_x_true_1dim__; ++sym1__) {
      {
        param_names__.emplace_back(std::string() + "car_rho_x_true" + '.' + std::to_string(sym1__));
      }}
    for (int sym1__ = 1; sym1__ <= nu_x_true_1dim__; ++sym1__) {
      {
        param_names__.emplace_back(std::string() + "nu_x_true" + '.' + std::to_string(sym1__));
      }}
    if (emit_transformed_parameters__) {
      for (int sym1__ = 1; sym1__ <= dev; ++sym1__) {
        {
          param_names__.emplace_back(std::string() + "beta_ev" + '.' + std::to_string(sym1__));
        }}
      for (int sym1__ = 1; sym1__ <= esf_1dim__; ++sym1__) {
        {
          param_names__.emplace_back(std::string() + "esf" + '.' + std::to_string(sym1__));
        }}
      for (int sym1__ = 1; sym1__ <= error_scale_1dim__; ++sym1__) {
        {
          param_names__.emplace_back(std::string() + "error_scale" + '.' + std::to_string(sym1__));
        }}
      for (int sym1__ = 1; sym1__ <= phi_1dim__; ++sym1__) {
        {
          param_names__.emplace_back(std::string() + "phi" + '.' + std::to_string(sym1__));
        }}
      for (int sym1__ = 1; sym1__ <= theta_1dim__; ++sym1__) {
        {
          param_names__.emplace_back(std::string() + "theta" + '.' + std::to_string(sym1__));
        }}
      for (int sym1__ = 1; sym1__ <= log_lambda_mu_1dim__; ++sym1__) {
        {
          param_names__.emplace_back(std::string() + "log_lambda_mu" + '.' + std::to_string(sym1__));
        }}
      for (int sym1__ = 1; sym1__ <= dx_all; ++sym1__) {
        {
          for (int sym2__ = 1; sym2__ <= n; ++sym2__) {
            {
              param_names__.emplace_back(std::string() + "x_all" + '.' + std::to_string(sym2__) + '.' + std::to_string(sym1__));
            }}
        }}
      for (int sym1__ = 1; sym1__ <= n; ++sym1__) {
        {
          param_names__.emplace_back(std::string() + "fitted" + '.' + std::to_string(sym1__));
        }}
    }
    
    if (emit_generated_quantities__) {
      for (int sym1__ = 1; sym1__ <= log_lik_1dim__; ++sym1__) {
        {
          param_names__.emplace_back(std::string() + "log_lik" + '.' + std::to_string(sym1__));
        }}
    }
    
    } // unconstrained_param_names() 
    
  inline std::string get_constrained_sizedtypes() const {
    stringstream s__;
    s__ << "[{\"name\":\"alpha_phi\",\"type\":{\"name\":\"vector\",\"length\":" << m << "},\"block\":\"parameters\"},{\"name\":\"phi_tilde\",\"type\":{\"name\":\"vector\",\"length\":" << phi_tilde_1dim__ << "},\"block\":\"parameters\"},{\"name\":\"spatial_scale\",\"type\":{\"name\":\"array\",\"length\":" << spatial_scale_1dim__ << ",\"element_type\":{\"name\":\"real\"}},\"block\":\"parameters\"},{\"name\":\"theta_tilde\",\"type\":{\"name\":\"vector\",\"length\":" << theta_tilde_1dim__ << "},\"block\":\"parameters\"},{\"name\":\"theta_scale\",\"type\":{\"name\":\"array\",\"length\":" << theta_scale_1dim__ << ",\"element_type\":{\"name\":\"real\"}},\"block\":\"parameters\"},{\"name\":\"rho\",\"type\":{\"name\":\"array\",\"length\":" << rho_1dim__ << ",\"element_type\":{\"name\":\"real\"}},\"block\":\"parameters\"},{\"name\":\"aux1_global\",\"type\":{\"name\":\"array\",\"length\":" << aux1_global_1dim__ << ",\"element_type\":{\"name\":\"real\"}},\"block\":\"parameters\"},{\"name\":\"aux2_global\",\"type\":{\"name\":\"array\",\"length\":" << aux2_global_1dim__ << ",\"element_type\":{\"name\":\"real\"}},\"block\":\"parameters\"},{\"name\":\"aux1_local\",\"type\":{\"name\":\"vector\",\"length\":" << dev << "},\"block\":\"parameters\"},{\"name\":\"aux2_local\",\"type\":{\"name\":\"vector\",\"length\":" << dev << "},\"block\":\"parameters\"},{\"name\":\"caux\",\"type\":{\"name\":\"array\",\"length\":" << caux_1dim__ << ",\"element_type\":{\"name\":\"real\"}},\"block\":\"parameters\"},{\"name\":\"z\",\"type\":{\"name\":\"vector\",\"length\":" << dev << "},\"block\":\"parameters\"},{\"name\":\"log_lambda\",\"type\":{\"name\":\"vector\",\"length\":" << log_lambda_1dim__ << "},\"block\":\"parameters\"},{\"name\":\"car_scale\",\"type\":{\"name\":\"array\",\"length\":" << car_scale_1dim__ << ",\"element_type\":{\"name\":\"real\"}},\"block\":\"parameters\"},{\"name\":\"car_rho\",\"type\":{\"name\":\"array\",\"length\":" << car_rho_1dim__ << ",\"element_type\":{\"name\":\"real\"}},\"block\":\"parameters\"},{\"name\":\"sar_scale\",\"type\":{\"name\":\"array\",\"length\":" << sar_scale_1dim__ << ",\"element_type\":{\"name\":\"real\"}},\"block\":\"parameters\"},{\"name\":\"sar_rho\",\"type\":{\"name\":\"array\",\"length\":" << sar_rho_1dim__ << ",\"element_type\":{\"name\":\"real\"}},\"block\":\"parameters\"},{\"name\":\"intercept\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"gamma\",\"type\":{\"name\":\"vector\",\"length\":" << dwx << "},\"block\":\"parameters\"},{\"name\":\"beta\",\"type\":{\"name\":\"vector\",\"length\":" << dx_all << "},\"block\":\"parameters\"},{\"name\":\"nu\",\"type\":{\"name\":\"array\",\"length\":" << is_student << ",\"element_type\":{\"name\":\"real\"}},\"block\":\"parameters\"},{\"name\":\"sigma\",\"type\":{\"name\":\"array\",\"length\":" << has_sigma << ",\"element_type\":{\"name\":\"real\"}},\"block\":\"parameters\"},{\"name\":\"alpha_re\",\"type\":{\"name\":\"vector\",\"length\":" << n_ids << "},\"block\":\"parameters\"},{\"name\":\"alpha_tau\",\"type\":{\"name\":\"array\",\"length\":" << has_re << ",\"element_type\":{\"name\":\"real\"}},\"block\":\"parameters\"},{\"name\":\"x_true\",\"type\":{\"name\":\"array\",\"length\":" << dx_me << ",\"element_type\":{\"name\":\"vector\",\"length\":" << n << "}},\"block\":\"parameters\"},{\"name\":\"mu_x_true\",\"type\":{\"name\":\"vector\",\"length\":" << dx_me << "},\"block\":\"parameters\"},{\"name\":\"sigma_x_true\",\"type\":{\"name\":\"vector\",\"length\":" << dx_me << "},\"block\":\"parameters\"},{\"name\":\"car_rho_x_true\",\"type\":{\"name\":\"vector\",\"length\":" << car_rho_x_true_1dim__ << "},\"block\":\"parameters\"},{\"name\":\"nu_x_true\",\"type\":{\"name\":\"vector\",\"length\":" << nu_x_true_1dim__ << "},\"block\":\"parameters\"},{\"name\":\"beta_ev\",\"type\":{\"name\":\"vector\",\"length\":" << dev << "},\"block\":\"transformed_parameters\"},{\"name\":\"esf\",\"type\":{\"name\":\"vector\",\"length\":" << esf_1dim__ << "},\"block\":\"transformed_parameters\"},{\"name\":\"error_scale\",\"type\":{\"name\":\"array\",\"length\":" << error_scale_1dim__ << ",\"element_type\":{\"name\":\"real\"}},\"block\":\"transformed_parameters\"},{\"name\":\"phi\",\"type\":{\"name\":\"vector\",\"length\":" << phi_1dim__ << "},\"block\":\"transformed_parameters\"},{\"name\":\"theta\",\"type\":{\"name\":\"vector\",\"length\":" << theta_1dim__ << "},\"block\":\"transformed_parameters\"},{\"name\":\"log_lambda_mu\",\"type\":{\"name\":\"vector\",\"length\":" << log_lambda_mu_1dim__ << "},\"block\":\"transformed_parameters\"},{\"name\":\"x_all\",\"type\":{\"name\":\"matrix\",\"rows\":" << n << ",\"cols\":" << dx_all << "},\"block\":\"transformed_parameters\"},{\"name\":\"fitted\",\"type\":{\"name\":\"vector\",\"length\":" << n << "},\"block\":\"transformed_parameters\"},{\"name\":\"log_lik\",\"type\":{\"name\":\"vector\",\"length\":" << log_lik_1dim__ << "},\"block\":\"generated_quantities\"}]";
    return s__.str();
    } // get_constrained_sizedtypes() 
    
  inline std::string get_unconstrained_sizedtypes() const {
    stringstream s__;
    s__ << "[{\"name\":\"alpha_phi\",\"type\":{\"name\":\"vector\",\"length\":" << m << "},\"block\":\"parameters\"},{\"name\":\"phi_tilde\",\"type\":{\"name\":\"vector\",\"length\":" << phi_tilde_1dim__ << "},\"block\":\"parameters\"},{\"name\":\"spatial_scale\",\"type\":{\"name\":\"array\",\"length\":" << spatial_scale_1dim__ << ",\"element_type\":{\"name\":\"real\"}},\"block\":\"parameters\"},{\"name\":\"theta_tilde\",\"type\":{\"name\":\"vector\",\"length\":" << theta_tilde_1dim__ << "},\"block\":\"parameters\"},{\"name\":\"theta_scale\",\"type\":{\"name\":\"array\",\"length\":" << theta_scale_1dim__ << ",\"element_type\":{\"name\":\"real\"}},\"block\":\"parameters\"},{\"name\":\"rho\",\"type\":{\"name\":\"array\",\"length\":" << rho_1dim__ << ",\"element_type\":{\"name\":\"real\"}},\"block\":\"parameters\"},{\"name\":\"aux1_global\",\"type\":{\"name\":\"array\",\"length\":" << aux1_global_1dim__ << ",\"element_type\":{\"name\":\"real\"}},\"block\":\"parameters\"},{\"name\":\"aux2_global\",\"type\":{\"name\":\"array\",\"length\":" << aux2_global_1dim__ << ",\"element_type\":{\"name\":\"real\"}},\"block\":\"parameters\"},{\"name\":\"aux1_local\",\"type\":{\"name\":\"vector\",\"length\":" << dev << "},\"block\":\"parameters\"},{\"name\":\"aux2_local\",\"type\":{\"name\":\"vector\",\"length\":" << dev << "},\"block\":\"parameters\"},{\"name\":\"caux\",\"type\":{\"name\":\"array\",\"length\":" << caux_1dim__ << ",\"element_type\":{\"name\":\"real\"}},\"block\":\"parameters\"},{\"name\":\"z\",\"type\":{\"name\":\"vector\",\"length\":" << dev << "},\"block\":\"parameters\"},{\"name\":\"log_lambda\",\"type\":{\"name\":\"vector\",\"length\":" << log_lambda_1dim__ << "},\"block\":\"parameters\"},{\"name\":\"car_scale\",\"type\":{\"name\":\"array\",\"length\":" << car_scale_1dim__ << ",\"element_type\":{\"name\":\"real\"}},\"block\":\"parameters\"},{\"name\":\"car_rho\",\"type\":{\"name\":\"array\",\"length\":" << car_rho_1dim__ << ",\"element_type\":{\"name\":\"real\"}},\"block\":\"parameters\"},{\"name\":\"sar_scale\",\"type\":{\"name\":\"array\",\"length\":" << sar_scale_1dim__ << ",\"element_type\":{\"name\":\"real\"}},\"block\":\"parameters\"},{\"name\":\"sar_rho\",\"type\":{\"name\":\"array\",\"length\":" << sar_rho_1dim__ << ",\"element_type\":{\"name\":\"real\"}},\"block\":\"parameters\"},{\"name\":\"intercept\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"gamma\",\"type\":{\"name\":\"vector\",\"length\":" << dwx << "},\"block\":\"parameters\"},{\"name\":\"beta\",\"type\":{\"name\":\"vector\",\"length\":" << dx_all << "},\"block\":\"parameters\"},{\"name\":\"nu\",\"type\":{\"name\":\"array\",\"length\":" << is_student << ",\"element_type\":{\"name\":\"real\"}},\"block\":\"parameters\"},{\"name\":\"sigma\",\"type\":{\"name\":\"array\",\"length\":" << has_sigma << ",\"element_type\":{\"name\":\"real\"}},\"block\":\"parameters\"},{\"name\":\"alpha_re\",\"type\":{\"name\":\"vector\",\"length\":" << n_ids << "},\"block\":\"parameters\"},{\"name\":\"alpha_tau\",\"type\":{\"name\":\"array\",\"length\":" << has_re << ",\"element_type\":{\"name\":\"real\"}},\"block\":\"parameters\"},{\"name\":\"x_true\",\"type\":{\"name\":\"array\",\"length\":" << dx_me << ",\"element_type\":{\"name\":\"vector\",\"length\":" << n << "}},\"block\":\"parameters\"},{\"name\":\"mu_x_true\",\"type\":{\"name\":\"vector\",\"length\":" << dx_me << "},\"block\":\"parameters\"},{\"name\":\"sigma_x_true\",\"type\":{\"name\":\"vector\",\"length\":" << dx_me << "},\"block\":\"parameters\"},{\"name\":\"car_rho_x_true\",\"type\":{\"name\":\"vector\",\"length\":" << car_rho_x_true_1dim__ << "},\"block\":\"parameters\"},{\"name\":\"nu_x_true\",\"type\":{\"name\":\"vector\",\"length\":" << nu_x_true_1dim__ << "},\"block\":\"parameters\"},{\"name\":\"beta_ev\",\"type\":{\"name\":\"vector\",\"length\":" << dev << "},\"block\":\"transformed_parameters\"},{\"name\":\"esf\",\"type\":{\"name\":\"vector\",\"length\":" << esf_1dim__ << "},\"block\":\"transformed_parameters\"},{\"name\":\"error_scale\",\"type\":{\"name\":\"array\",\"length\":" << error_scale_1dim__ << ",\"element_type\":{\"name\":\"real\"}},\"block\":\"transformed_parameters\"},{\"name\":\"phi\",\"type\":{\"name\":\"vector\",\"length\":" << phi_1dim__ << "},\"block\":\"transformed_parameters\"},{\"name\":\"theta\",\"type\":{\"name\":\"vector\",\"length\":" << theta_1dim__ << "},\"block\":\"transformed_parameters\"},{\"name\":\"log_lambda_mu\",\"type\":{\"name\":\"vector\",\"length\":" << log_lambda_mu_1dim__ << "},\"block\":\"transformed_parameters\"},{\"name\":\"x_all\",\"type\":{\"name\":\"matrix\",\"rows\":" << n << ",\"cols\":" << dx_all << "},\"block\":\"transformed_parameters\"},{\"name\":\"fitted\",\"type\":{\"name\":\"vector\",\"length\":" << n << "},\"block\":\"transformed_parameters\"},{\"name\":\"log_lik\",\"type\":{\"name\":\"vector\",\"length\":" << log_lik_1dim__ << "},\"block\":\"generated_quantities\"}]";
    return s__.str();
    } // get_unconstrained_sizedtypes() 
    
  
    // Begin method overload boilerplate
    template <typename RNG>
    inline void write_array(RNG& base_rng,
                            Eigen::Matrix<double,Eigen::Dynamic,1>& params_r,
                            Eigen::Matrix<double,Eigen::Dynamic,1>& vars,
                            const bool emit_transformed_parameters = true,
                            const bool emit_generated_quantities = true,
                            std::ostream* pstream = nullptr) const {
      std::vector<double> vars_vec(vars.size());
      std::vector<int> params_i;
      write_array_impl(base_rng, params_r, params_i, vars_vec,
          emit_transformed_parameters, emit_generated_quantities, pstream);
      vars.resize(vars_vec.size());
      for (int i = 0; i < vars.size(); ++i) {
        vars.coeffRef(i) = vars_vec[i];
      }
    }
    template <typename RNG>
    inline void write_array(RNG& base_rng, std::vector<double>& params_r,
                            std::vector<int>& params_i,
                            std::vector<double>& vars,
                            bool emit_transformed_parameters = true,
                            bool emit_generated_quantities = true,
                            std::ostream* pstream = nullptr) const {
      write_array_impl(base_rng, params_r, params_i, vars, emit_transformed_parameters, emit_generated_quantities, pstream);
    }
    template <bool propto__, bool jacobian__, typename T_>
    inline T_ log_prob(Eigen::Matrix<T_,Eigen::Dynamic,1>& params_r,
                       std::ostream* pstream = nullptr) const {
      Eigen::Matrix<int, -1, 1> params_i;
      return log_prob_impl<propto__, jacobian__>(params_r, params_i, pstream);
    }
    template <bool propto__, bool jacobian__, typename T__>
    inline T__ log_prob(std::vector<T__>& params_r,
                        std::vector<int>& params_i,
                        std::ostream* pstream = nullptr) const {
      return log_prob_impl<propto__, jacobian__>(params_r, params_i, pstream);
    }
  
    inline void transform_inits(const stan::io::var_context& context,
                         Eigen::Matrix<double, Eigen::Dynamic, 1>& params_r,
                         std::ostream* pstream = nullptr) const final {
      std::vector<double> params_r_vec(params_r.size());
      std::vector<int> params_i;
      transform_inits_impl(context, params_i, params_r_vec, pstream);
      params_r.resize(params_r_vec.size());
      for (int i = 0; i < params_r.size(); ++i) {
        params_r.coeffRef(i) = params_r_vec[i];
      }
    }
    inline void transform_inits(const stan::io::var_context& context,
                                std::vector<int>& params_i,
                                std::vector<double>& vars,
                                std::ostream* pstream = nullptr) const final {
      transform_inits_impl(context, params_i, vars, pstream);
    }        
};
}
using stan_model = model_foundation_namespace::model_foundation;
#ifndef USING_R
// Boilerplate
stan::model::model_base& new_model(
        stan::io::var_context& data_context,
        unsigned int seed,
        std::ostream* msg_stream) {
  stan_model* m = new stan_model(data_context, seed, msg_stream);
  return *m;
}
stan::math::profile_map& get_stan_profile_data() {
  return model_foundation_namespace::profiles__;
}
#endif
#endif
