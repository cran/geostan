<!DOCTYPE html>

<html>

<head>

<meta charset="utf-8" />
<meta name="generator" content="pandoc" />
<meta http-equiv="X-UA-Compatible" content="IE=EDGE" />

<meta name="viewport" content="width=device-width, initial-scale=1" />

<meta name="author" content="Connor Donegan" />

<meta name="date" content="2023-10-02" />

<title>Custom spatial models with RStan and geostan</title>

<script>// Pandoc 2.9 adds attributes on both header and div. We remove the former (to
// be compatible with the behavior of Pandoc < 2.8).
document.addEventListener('DOMContentLoaded', function(e) {
  var hs = document.querySelectorAll("div.section[class*='level'] > :first-child");
  var i, h, a;
  for (i = 0; i < hs.length; i++) {
    h = hs[i];
    if (!/^h[1-6]$/i.test(h.tagName)) continue;  // it should be a header h1-h6
    a = h.attributes;
    while (a.length > 0) h.removeAttribute(a[0].name);
  }
});
</script>
<script>// Hide empty <a> tag within highlighted CodeBlock for screen reader accessibility (see https://github.com/jgm/pandoc/issues/6352#issuecomment-626106786) -->
// v0.0.1
// Written by JooYoung Seo (jooyoung@psu.edu) and Atsushi Yasumoto on June 1st, 2020.

document.addEventListener('DOMContentLoaded', function() {
  const codeList = document.getElementsByClassName("sourceCode");
  for (var i = 0; i < codeList.length; i++) {
    var linkList = codeList[i].getElementsByTagName('a');
    for (var j = 0; j < linkList.length; j++) {
      if (linkList[j].innerHTML === "") {
        linkList[j].setAttribute('aria-hidden', 'true');
      }
    }
  }
});
</script>

<style type="text/css">
  code{white-space: pre-wrap;}
  span.smallcaps{font-variant: small-caps;}
  span.underline{text-decoration: underline;}
  div.column{display: inline-block; vertical-align: top; width: 50%;}
  div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
  ul.task-list{list-style: none;}
    </style>



<style type="text/css">
  code {
    white-space: pre;
  }
  .sourceCode {
    overflow: visible;
  }
</style>
<style type="text/css" data-origin="pandoc">
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } /* Alert */
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #7d9029; } /* Attribute */
code span.bn { color: #40a070; } /* BaseN */
code span.bu { } /* BuiltIn */
code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code span.ch { color: #4070a0; } /* Char */
code span.cn { color: #880000; } /* Constant */
code span.co { color: #60a0b0; font-style: italic; } /* Comment */
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #ba2121; font-style: italic; } /* Documentation */
code span.dt { color: #902000; } /* DataType */
code span.dv { color: #40a070; } /* DecVal */
code span.er { color: #ff0000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #40a070; } /* Float */
code span.fu { color: #06287e; } /* Function */
code span.im { } /* Import */
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #007020; font-weight: bold; } /* Keyword */
code span.op { color: #666666; } /* Operator */
code span.ot { color: #007020; } /* Other */
code span.pp { color: #bc7a00; } /* Preprocessor */
code span.sc { color: #4070a0; } /* SpecialChar */
code span.ss { color: #bb6688; } /* SpecialString */
code span.st { color: #4070a0; } /* String */
code span.va { color: #19177c; } /* Variable */
code span.vs { color: #4070a0; } /* VerbatimString */
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */

</style>
<script>
// apply pandoc div.sourceCode style to pre.sourceCode instead
(function() {
  var sheets = document.styleSheets;
  for (var i = 0; i < sheets.length; i++) {
    if (sheets[i].ownerNode.dataset["origin"] !== "pandoc") continue;
    try { var rules = sheets[i].cssRules; } catch (e) { continue; }
    var j = 0;
    while (j < rules.length) {
      var rule = rules[j];
      // check if there is a div.sourceCode rule
      if (rule.type !== rule.STYLE_RULE || rule.selectorText !== "div.sourceCode") {
        j++;
        continue;
      }
      var style = rule.style.cssText;
      // check if color or background-color is set
      if (rule.style.color === '' && rule.style.backgroundColor === '') {
        j++;
        continue;
      }
      // replace div.sourceCode by a pre.sourceCode rule
      sheets[i].deleteRule(j);
      sheets[i].insertRule('pre.sourceCode{' + style + '}', j);
    }
  }
})();
</script>




<style type="text/css">body {
background-color: #fff;
margin: 1em auto;
max-width: 700px;
overflow: visible;
padding-left: 2em;
padding-right: 2em;
font-family: "Open Sans", "Helvetica Neue", Helvetica, Arial, sans-serif;
font-size: 14px;
line-height: 1.35;
}
#TOC {
clear: both;
margin: 0 0 10px 10px;
padding: 4px;
width: 400px;
border: 1px solid #CCCCCC;
border-radius: 5px;
background-color: #f6f6f6;
font-size: 13px;
line-height: 1.3;
}
#TOC .toctitle {
font-weight: bold;
font-size: 15px;
margin-left: 5px;
}
#TOC ul {
padding-left: 40px;
margin-left: -1.5em;
margin-top: 5px;
margin-bottom: 5px;
}
#TOC ul ul {
margin-left: -2em;
}
#TOC li {
line-height: 16px;
}
table {
margin: 1em auto;
border-width: 1px;
border-color: #DDDDDD;
border-style: outset;
border-collapse: collapse;
}
table th {
border-width: 2px;
padding: 5px;
border-style: inset;
}
table td {
border-width: 1px;
border-style: inset;
line-height: 18px;
padding: 5px 5px;
}
table, table th, table td {
border-left-style: none;
border-right-style: none;
}
table thead, table tr.even {
background-color: #f7f7f7;
}
p {
margin: 0.5em 0;
}
blockquote {
background-color: #f6f6f6;
padding: 0.25em 0.75em;
}
hr {
border-style: solid;
border: none;
border-top: 1px solid #777;
margin: 28px 0;
}
dl {
margin-left: 0;
}
dl dd {
margin-bottom: 13px;
margin-left: 13px;
}
dl dt {
font-weight: bold;
}
ul {
margin-top: 0;
}
ul li {
list-style: circle outside;
}
ul ul {
margin-bottom: 0;
}
pre, code {
background-color: #f7f7f7;
border-radius: 3px;
color: #333;
white-space: pre-wrap; 
}
pre {
border-radius: 3px;
margin: 5px 0px 10px 0px;
padding: 10px;
}
pre:not([class]) {
background-color: #f7f7f7;
}
code {
font-family: Consolas, Monaco, 'Courier New', monospace;
font-size: 85%;
}
p > code, li > code {
padding: 2px 0px;
}
div.figure {
text-align: center;
}
img {
background-color: #FFFFFF;
padding: 2px;
border: 1px solid #DDDDDD;
border-radius: 3px;
border: 1px solid #CCCCCC;
margin: 0 5px;
}
h1 {
margin-top: 0;
font-size: 35px;
line-height: 40px;
}
h2 {
border-bottom: 4px solid #f7f7f7;
padding-top: 10px;
padding-bottom: 2px;
font-size: 145%;
}
h3 {
border-bottom: 2px solid #f7f7f7;
padding-top: 10px;
font-size: 120%;
}
h4 {
border-bottom: 1px solid #f7f7f7;
margin-left: 8px;
font-size: 105%;
}
h5, h6 {
border-bottom: 1px solid #ccc;
font-size: 105%;
}
a {
color: #0033dd;
text-decoration: none;
}
a:hover {
color: #6666ff; }
a:visited {
color: #800080; }
a:visited:hover {
color: #BB00BB; }
a[href^="http:"] {
text-decoration: underline; }
a[href^="https:"] {
text-decoration: underline; }

code > span.kw { color: #555; font-weight: bold; } 
code > span.dt { color: #902000; } 
code > span.dv { color: #40a070; } 
code > span.bn { color: #d14; } 
code > span.fl { color: #d14; } 
code > span.ch { color: #d14; } 
code > span.st { color: #d14; } 
code > span.co { color: #888888; font-style: italic; } 
code > span.ot { color: #007020; } 
code > span.al { color: #ff0000; font-weight: bold; } 
code > span.fu { color: #900; font-weight: bold; } 
code > span.er { color: #a61717; background-color: #e3d2d2; } 
</style>




</head>

<body>




<h1 class="title toc-ignore">Custom spatial models with RStan and geostan</h1>
<h4 class="author">Connor Donegan</h4>
<h4 class="date">October 2, 2023</h4>


<div id="TOC">
<ul>
<li><a href="#car-models"><span class="toc-section-number">1</span> CAR models</a>
<ul>
<li><a href="#autonormal-model"><span class="toc-section-number">1.1</span> Autonormal model</a></li>
<li><a href="#poisson-models"><span class="toc-section-number">1.2</span> Poisson models</a></li>
</ul></li>
<li><a href="#sar-models"><span class="toc-section-number">2</span> SAR models</a></li>
<li><a href="#references">References</a></li>
</ul>
</div>

<p>The spatial models in geostan use custom Stan functions that are far more efficient than using built-in functions, including the conditional (CAR) and simultaneous spatial autoregressive (SAR) models (both are particular specifications of the multivariate normal distribution). This vignette shows how you can use those functions together with some R functions in geostan to start building custom spatial models.</p>
<p>This tutorial is written with the assumption that the reader is already familiar with <a href="https://mc-stan.org/users/documentation/">RStan</a>. Users are expected to make adjustments to the code as needed, including to prior distributions. For more details and an explanation of the computational approach, see <span class="citation">Donegan (<a href="#ref-donegan_2022" role="doc-biblioref">2022</a>)</span>. For more background on spatial modeling see <span class="citation">Haining and Li (<a href="#ref-haining_2020" role="doc-biblioref">2020</a>)</span>.</p>
<div id="car-models" class="section level1" number="1">
<h1 number="1"><span class="header-section-number">1</span> CAR models</h1>
<p>The CAR model is a multivariate normal distribution with covariance matrix <span class="math display">\[\Sigma = (I - \rho \cdot C)^{-1} M,\]</span> where <span class="math inline">\(I\)</span> is the identity matrix, <span class="math inline">\(\rho\)</span> a spatial autocorrelation parameter which may be positive or negative, <span class="math inline">\(C\)</span> is a sparse connectivity matrix, and <span class="math inline">\(M\)</span> is a diagonal matrix with scale parameters <span class="math inline">\(\tau_i^2\)</span>. There is typically a single scale parameter <span class="math inline">\(\tau\)</span> multiplied by weights <span class="math inline">\(\delta_i\)</span>. The term <span class="math inline">\(\tau^2 \cdot \delta_i\)</span> is the conditional variance pertaining to <span class="math inline">\(y_i | y_{n(i)}\)</span> where <span class="math inline">\(n(i)\)</span> lists the areas that neighbor the <span class="math inline">\(i^{th}\)</span> one.</p>
<p>The defining feature of the CAR model is that, similar to time-series autoregression, the expectation for the value at the <span class="math inline">\(i^{th}\)</span> site given any or all other values of <span class="math inline">\(y\)</span> besides <span class="math inline">\(i\)</span> (<span class="math inline">\(y_{-i}\)</span>) are known, is a function of the neighboring values: <span class="math display">\[\mathbb{E}[y_i | y_{-i}] = \mu_j + \sum_{j \in n(i)} \rho \cdot c_{ij} (y_j - \mu_j).\]</span></p>
<p>The CAR function presented here is valid for what is sometimes called the WCAR specification. This is the most commonly employed CAR specification (see <span class="citation">Donegan (<a href="#ref-donegan_2022" role="doc-biblioref">2022</a>)</span> for CAR models without this restriction). The connectivity matrix is row-standardized. Let <span class="math inline">\(A\)</span> be a symmetric binary connectivity matrix where <span class="math inline">\(a_{ij}= 1\)</span> only if the <span class="math inline">\(i^{th}\)</span> and <span class="math inline">\(j^{th}\)</span> sites are neighbors, all other entries are zero (including the diagonal entries <span class="math inline">\(i=j\)</span>). The elements of <span class="math inline">\(C\)</span> are <span class="math display">\[c_{ij} = \frac{a_{ij}}{\sum_j^n a_{ij}} = \frac{a_{ij}}{|n(i)|}.\]</span></p>
<p>The diagonal of matrix <span class="math inline">\(M\)</span> then is specified by the n-length vector of weights <span class="math inline">\(\delta_i = \tau^2 \cdot \frac{1}{|n(i)|}\)</span>.</p>
<p>The <code>geostan::prep_car_data</code> function will complete all of this for you. The user passes in a binary connectivity matrix <span class="math inline">\(A\)</span> and and specifies <code>style = &quot;WCAR&quot;</code>, then the function returns a list of data inputs for the Stan model.</p>
<div id="autonormal-model" class="section level2" number="1.1">
<h2 number="1.1"><span class="header-section-number">1.1</span> Autonormal model</h2>
<p>This first example is an autonormal model: <span class="math display">\[y \sim Normal(\alpha + x \beta, \Sigma).\]</span> Here you have <span class="math inline">\(n\)</span> observations of a continuously measured outcome <span class="math inline">\(y\)</span>, possibly <span class="math inline">\(k=1\)</span> or more covariates <span class="math inline">\(x\)</span>, and you’re accounting for spatial autocorrelation in <span class="math inline">\(y\)</span> using the covariance matrix of an <span class="math inline">\(n\)</span>-dimensional multivariate normal distribution.</p>
<p>The following Stan code implements the above model; if you’re following along, copy the Stan code and save it in a file inside your working directory; I’ll name it “autonormal.stan” and I’ll save the name as an R variable:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true"></a>autonormal_file &lt;-<span class="st"> &quot;autonormal.stan&quot;</span></span></code></pre></div>
<p>Here’s the Stan code:</p>
<pre class="stan"><code>functions {
#include wcar-lpdf.stan
}

data {
  // data
  int&lt;lower=1&gt; n;
  int&lt;lower=1&gt; k;
  vector[n] y;
  matrix[n, k] x;

    // CAR parts
  int nAx_w;
  int nC;
  vector[nAx_w] Ax_w;
  array[nAx_w] int Ax_v;
  array[n + 1] int Ax_u;
  array[nC] int Cidx;
  vector[n] Delta_inv;
  real log_det_Delta_inv;
  vector[n] lambda;
}

parameters {
  // spatial autocorrelation (SA) parameter
  real&lt;lower=1/min(lambda), upper=1/max(lambda)&gt; rho;
  
  // scale parameter
  real&lt;lower=0&gt; tau;
  
  // intercept
  real alpha;
  
  // coefficients
  vector[k] beta;  
}

model {
  vector[n] mu = alpha + x * beta;

  // Likelihood: y ~ Normal(Mu, Sigma)
  target += wcar_normal_lpdf(y |
                 mu, tau, rho, // mean, scale, SA
                 Ax_w, Ax_v, Ax_u, // stuff from prep_car_data
                 Delta_inv, 
                 log_det_Delta_inv,
                 lambda, 
                 n);    
  
  // prior for scale parameter
  target += student_t_lpdf(tau | 10, 0, 5);

  // prior for beta
  target += normal_lpdf(beta | 0, 5);

  // prior for intercept
  target += normal_lpdf(alpha | 0, 5);
}
</code></pre>
<p>The input file “wcar-lpdf.stan” contains the following code (save this code inside your working directory and name it “wcar-lpdf.stan”):</p>
<pre class="stan"><code>/**
 * Log probability density of the conditional autoregressive (CAR) model: WCAR specifications only
 *
 * @param y Process to model
 * @param mu Mean vector
 * @param tau Scale parameter
 * @param rho Spatial dependence parameter
 * @param A_w Sparse representation of the symmetric connectivity matrix, A
 * @param A_v Column indices for values in A_w
 * @param A_u Row starting indices for values in A_u
 * @param D_inv The row sums of A; i.e., the diagonal elements from the inverse of Delta, where M = Delta * tau^2 is a diagonal matrix containing the conditional variances.
 * @param log_det_D_inv Log determinant of Delta inverse.
 * @param lambda Eigenvalues of C (or of the symmetric, scaled matrix Delta^{-1/2}*C*Delta^{1/2}); for the WCAR specification, C is the row-standardized version of W.
 * @param n Length of y
 *
 * @return Log probability density of CAR prior up to additive constant
 */
real wcar_normal_lpdf(vector y, vector mu,
              real tau, real rho,
              vector A_w, array[] int A_v, array[] int A_u,
              vector D_inv, real log_det_D_inv,
              vector lambda,
              int n) {
  vector[n] z = y - mu;
  real ztDz; 
  real ztAz; 
  vector[n] ldet_ImrhoC;
  ztDz = (z .* D_inv)&#39; * z;
  ztAz = z&#39; * csr_matrix_times_vector(n, n, A_w, A_v, A_u, z);
  for (i in 1:n) ldet_ImrhoC[i] = log1m(rho * lambda[i]);
  return 0.5 * (
        -n * log( 2 * pi() )
        -2 * n * log(tau)
        + log_det_D_inv
        + sum(ldet_ImrhoC)
        - (1 / tau^2) * (ztDz - rho * ztAz));
}</code></pre>
<p>From R, you can use the following code to prepare the input data (<span class="math inline">\(y\)</span>, <span class="math inline">\(x\)</span>, etc.). I use <code>prep_car_data</code> to get a list of parts for the CAR model, then I append the outcome data to the same list and pass it all to a Stan model to draw samples.</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true"></a><span class="kw">library</span>(rstan)</span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true"></a><span class="kw">library</span>(geostan)</span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true"></a><span class="kw">data</span>(georgia)</span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true"></a></span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true"></a>A &lt;-<span class="st"> </span><span class="kw">shape2mat</span>(georgia, <span class="st">&quot;B&quot;</span>)</span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true"></a>car_list &lt;-<span class="st"> </span><span class="kw">prep_car_data</span>(A, <span class="dt">style =</span> <span class="st">&quot;WCAR&quot;</span>)</span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true"></a></span>
<span id="cb4-8"><a href="#cb4-8" aria-hidden="true"></a><span class="co"># add data</span></span>
<span id="cb4-9"><a href="#cb4-9" aria-hidden="true"></a>car_list<span class="op">$</span>y &lt;-<span class="st"> </span><span class="kw">log</span>(georgia<span class="op">$</span>income <span class="op">/</span><span class="st"> </span><span class="fl">10e3</span>)</span>
<span id="cb4-10"><a href="#cb4-10" aria-hidden="true"></a>car_list<span class="op">$</span>x &lt;-<span class="st"> </span><span class="kw">matrix</span>(<span class="kw">log</span>(georgia<span class="op">$</span>population <span class="op">/</span><span class="st"> </span><span class="fl">10e3</span>), <span class="dt">ncol =</span> <span class="dv">1</span>)</span>
<span id="cb4-11"><a href="#cb4-11" aria-hidden="true"></a>car_list<span class="op">$</span>k &lt;-<span class="st"> </span><span class="kw">ncol</span>(car_list<span class="op">$</span>x)</span>
<span id="cb4-12"><a href="#cb4-12" aria-hidden="true"></a></span>
<span id="cb4-13"><a href="#cb4-13" aria-hidden="true"></a><span class="co"># compile Stan model from file</span></span>
<span id="cb4-14"><a href="#cb4-14" aria-hidden="true"></a>car_model &lt;-<span class="st"> </span><span class="kw">stan_model</span>(autonormal_file)</span>
<span id="cb4-15"><a href="#cb4-15" aria-hidden="true"></a></span>
<span id="cb4-16"><a href="#cb4-16" aria-hidden="true"></a><span class="co"># sample from model</span></span>
<span id="cb4-17"><a href="#cb4-17" aria-hidden="true"></a>samples &lt;-<span class="st"> </span><span class="kw">sampling</span>(car_model, <span class="dt">data =</span> car_list, <span class="dt">iter =</span> <span class="fl">1e3</span>)</span></code></pre></div>
<p>The same results can be obtained using <code>geostan::stan_car</code>:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true"></a>fit &lt;-<span class="st"> </span><span class="kw">stan_car</span>(<span class="kw">log</span>(income <span class="op">/</span><span class="st"> </span><span class="fl">10e3</span>) <span class="op">~</span><span class="st"> </span><span class="kw">log</span>(population <span class="op">/</span><span class="st"> </span><span class="fl">10e3</span>),</span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true"></a>    <span class="dt">data =</span> georgia, <span class="dt">car =</span> car_list, <span class="dt">iter =</span> <span class="fl">1e3</span>)</span></code></pre></div>
</div>
<div id="poisson-models" class="section level2" number="1.2">
<h2 number="1.2"><span class="header-section-number">1.2</span> Poisson models</h2>
<p>Disease mapping is a common use for CAR models, though these models have many applications. In this class of models, the CAR model is assigned as the prior distribution to a parameter vector <span class="math inline">\(\phi\)</span>, which is used to model disease incidence rates across small areas like counties. The disease data consist of counts <span class="math inline">\(y\)</span> together with the size of population at risk <span class="math inline">\(p\)</span>, or possibly a different denominator such as the expected number of cases <span class="math inline">\(E\)</span> (which occurs when using indirect age-standardization). These models have the form <span class="math display">\[\begin{equation}
\begin{aligned}
    &amp;y \sim Poisson(e^\phi) \\
    &amp;\phi \sim Normal(\mu, \Sigma) \\
    &amp;\mu = log(p) + \alpha + x \beta.
\end{aligned}
\end{equation}\]</span></p>
<p>Here you see that the linear predictor <span class="math inline">\(\mu\)</span> is embedded with the CAR model.</p>
<p>Here is another way of writing down the very same model: <span class="math display">\[\begin{equation}
\begin{aligned}
    &amp;y \sim Poisson(e^\eta) \\
    &amp;\eta = log(p) + \alpha + x \beta + \phi \\
    &amp;\phi \sim Normal(0, \Sigma) \\
\end{aligned}
\end{equation}\]</span></p>
<p>It is possible to build a Stan modeling using either one of these two formulations. They are substantively equivalent, <em>but</em> you may find that one is far more amenable to Stan’s MCMC algorithm. The former specification (<span class="math inline">\(\mu\)</span> inside the CAR model) is less commonly presented in papers, but in this author’s experience it is often far more stable computationally than forcing the CAR model to have zero mean. (You may very well encounter a case where the opposite is true.)</p>
<p>The purpose of the offset term is sometimes unclear in introductory texts. The offset term <span class="math inline">\(p\)</span> is from the denominator of the rates <span class="math inline">\(\frac{y}{p}\)</span>. The expectation or mean of the model is <span class="math display">\[\begin{equation}
\begin{aligned}
    &amp;\mathbb{E}[y] = e^{log(p) + \mu} = e^{log(p)} \cdot e^{\mu} = p \cdot e^\mu \\
    &amp;\mathbb{E}\Bigl[ \frac{y}{p} \Bigr] = e^\mu
\end{aligned}
\end{equation}\]</span> The smaller is the denominator, the less informative is the rate with respect to the characteristic level of risk bearing upon the population of the given period and place. With small denominators, chance renders the rates uninformative (and unstable over time and space), and the Poisson model accounts for this.</p>
<p>The following Stan code provides a template for a simple disease mapping model using the CAR model as a prior for <span class="math inline">\(\phi\)</span>. As before, you can save the code in your working directory and give it a name like “car_poisson.stan”. I’ll store the file name in my R environment:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true"></a>car_poisson_file &lt;-<span class="st"> &quot;car_poisson.stan&quot;</span></span></code></pre></div>
<pre class="stan"><code>functions {
#include wcar-lpdf.stan
}

data {
  // data
  int&lt;lower=1&gt; n;
  int&lt;lower=1&gt; k;
  array[n] int&lt;lower=0&gt; y;
  matrix[n, k] x;
  vector[n] const_offset;

    // CAR parts
  int nAx_w;
  int nC;
  vector[nAx_w] Ax_w;
  array[nAx_w] int Ax_v;
  array[n + 1] int Ax_u;
  array[nC] int Cidx;
  vector[n] Delta_inv;
  real log_det_Delta_inv;
  vector[n] lambda;
}

parameters {
  // spatial autocorrelation (SA) parameter
  real&lt;lower=1/min(lambda), upper=1/max(lambda)&gt; rho;
  
  // scale parameter
  real&lt;lower=0&gt; tau;
  
  // intercept
  real alpha;
  
  // coefficients
  vector[k] beta;
  
  // SA trend component
  vector[n] phi;
}


model {
  vector[n] mu = const_offset + alpha + x * beta;
  
  // Likelihood: y ~ Poisson(e^[phi])
  target += poisson_lpmf(y | exp(phi));
    
  // phi ~ Normal(Mu, Sigma)
  target += wcar_normal_lpdf(phi |
                 mu, tau, rho, // mean, scale, SA
                 Ax_w, Ax_v, Ax_u, // stuff from prep_car_data
                 Delta_inv, 
                 log_det_Delta_inv,
                 lambda, 
                 n);

  // prior for scale parameter
  target += student_t_lpdf(tau | 10, 0, 1);

  // prior for beta
  target += normal_lpdf(beta | 0, 5);

  // prior for intercept
  target += normal_lpdf(alpha | 0, 5);
}
</code></pre>
<p>Again, you can use <code>geostan::prep_car_data</code> to easily convert the spatial weights matrix into the list of required inputs for the CAR model:</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true"></a><span class="kw">library</span>(rstan)</span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true"></a><span class="kw">library</span>(geostan)</span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true"></a><span class="kw">data</span>(georgia)</span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true"></a></span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true"></a>A &lt;-<span class="st"> </span><span class="kw">shape2mat</span>(georgia, <span class="st">&quot;B&quot;</span>)</span>
<span id="cb8-6"><a href="#cb8-6" aria-hidden="true"></a>car_list &lt;-<span class="st"> </span><span class="kw">prep_car_data</span>(A, <span class="dt">style =</span> <span class="st">&quot;WCAR&quot;</span>)</span>
<span id="cb8-7"><a href="#cb8-7" aria-hidden="true"></a></span>
<span id="cb8-8"><a href="#cb8-8" aria-hidden="true"></a><span class="co"># add data</span></span>
<span id="cb8-9"><a href="#cb8-9" aria-hidden="true"></a>car_list<span class="op">$</span>y &lt;-<span class="st"> </span>georgia<span class="op">$</span>deaths.male</span>
<span id="cb8-10"><a href="#cb8-10" aria-hidden="true"></a>car_list<span class="op">$</span>const_offset &lt;-<span class="st"> </span><span class="kw">log</span>(georgia<span class="op">$</span>pop.at.risk.male)</span>
<span id="cb8-11"><a href="#cb8-11" aria-hidden="true"></a>car_list<span class="op">$</span>x &lt;-<span class="st"> </span><span class="kw">matrix</span>(<span class="kw">log</span>(georgia<span class="op">$</span>income <span class="op">/</span><span class="st"> </span><span class="fl">10e3</span>), <span class="dt">ncol =</span> <span class="dv">1</span>)</span>
<span id="cb8-12"><a href="#cb8-12" aria-hidden="true"></a>car_list<span class="op">$</span>k &lt;-<span class="st"> </span><span class="kw">ncol</span>(car_list<span class="op">$</span>x)</span>
<span id="cb8-13"><a href="#cb8-13" aria-hidden="true"></a></span>
<span id="cb8-14"><a href="#cb8-14" aria-hidden="true"></a><span class="co"># compile Stan model from file</span></span>
<span id="cb8-15"><a href="#cb8-15" aria-hidden="true"></a>car_poisson &lt;-<span class="st"> </span><span class="kw">stan_model</span>(car_poisson_file)</span>
<span id="cb8-16"><a href="#cb8-16" aria-hidden="true"></a></span>
<span id="cb8-17"><a href="#cb8-17" aria-hidden="true"></a><span class="co"># sample from model</span></span>
<span id="cb8-18"><a href="#cb8-18" aria-hidden="true"></a>samples &lt;-<span class="st"> </span><span class="kw">sampling</span>(car_poisson,</span>
<span id="cb8-19"><a href="#cb8-19" aria-hidden="true"></a>    <span class="dt">data =</span> car_list,</span>
<span id="cb8-20"><a href="#cb8-20" aria-hidden="true"></a>    <span class="dt">iter =</span> <span class="fl">1e3</span>)</span></code></pre></div>
<p>The same results can be obtained using <code>geostan::stan_car</code>:</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true"></a>fit &lt;-<span class="st"> </span><span class="kw">stan_car</span>(deaths.male <span class="op">~</span><span class="st"> </span><span class="kw">offset</span>(<span class="kw">log</span>(pop.at.risk.male)) <span class="op">+</span><span class="st"> </span><span class="kw">log</span>(income <span class="op">/</span><span class="st"> </span><span class="fl">10e3</span>),</span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true"></a>    <span class="dt">data =</span> georgia, <span class="dt">car =</span> car_list, <span class="dt">family =</span> <span class="kw">poisson</span>(), <span class="dt">iter =</span> <span class="fl">1e3</span>)</span></code></pre></div>
</div>
</div>
<div id="sar-models" class="section level1" number="2">
<h1 number="2"><span class="header-section-number">2</span> SAR models</h1>
<p>The simultaneously-specified spatial autoregression (SAR) is written as <span class="math display">\[\begin{equation}
  \begin{aligned}
    y = \mu + (I - \rho \cdot W)^{-1} \epsilon \\
    \epsilon \sim Normal(0, \sigma^2 \cdot I)
    \end{aligned}
\end{equation}\]</span><br />
where <span class="math inline">\(W\)</span> is a row-standardized spatial weights matrix, <span class="math inline">\(I\)</span> is the n-by-n identity matrix, and <span class="math inline">\(\rho\)</span> is a spatial autocorrelation parameter. This is also a multivariate normal distribution but with a different covariance matrix than the CAR model: <span class="math display">\[\begin{equation}
  \Sigma = \sigma^2 \cdot (I - \rho \cdot W)^{-1} (I - \rho \cdot W^T)^{-1},
\end{equation}\]</span> where <span class="math inline">\(T\)</span> is the matrix transpose operator. The SA parameter <span class="math inline">\(\rho\)</span> for the SAR model has a more intuitive connection to the degree of SA than the CAR model (which is usually above .95 for moderately high SA).</p>
<p>The Stan function that is used by <code>geostan::stan_sar</code> is as follows (the R code below will assume that you have saved this as “sar-lpdf.stan”):</p>
<pre class="stan"><code>/**
 * Log probability density of the simultaneous autoregressive (SAR) model (spatial error model)
 *
 * @param y Process to model
 * @param mu Mean vector
 * @param sigma Scale parameter
 * @param rho Spatial dependence parameter
 * @param ImW Sparse representation of (I - W): non-zero values only
 * @param ImW_v Column indices for values in ImW
 * @param ImW_u Row starting indices for values in ImW
 * @param Widx Indices for the off-diagonal elements in ImC
 * @param lambda Eigenvalues of W
 * @param n Length of y
 *
 * @return Log probability density of SAR model up to additive constant
*/
  real  sar_normal_lpdf(vector y,
              vector mu,
              real sigma,
              real rho,
              vector ImW,
              array[] int ImW_v,
              array[] int ImW_u,
              array[] int Widx,
              vector lambda,
              int n) {
  vector[n] z = y - mu;
  real tau = 1 / sigma^2;
  vector[num_elements(ImW)] ImrhoW = ImW;  // (I - rho W)
  vector[n] ImrhoWz;                       // (I - rho * W) * z
  real zVz;
  real ldet_V = 2 * sum(log1m(rho * lambda)) - 2 * n * log(sigma);
  ImrhoW[Widx] = rho * ImW[Widx];
  ImrhoWz = csr_matrix_times_vector(n, n, ImrhoW, ImW_v , ImW_u , z);
  zVz = tau * dot_self(ImrhoWz);
  return  0.5 * (-n * log(2 * pi()) + ldet_V - zVz);         
 }    
</code></pre>
<p>The following Stan model provides an example of how to use this function to build a SAR model. Again, its an autonormal model for continuous outcome variable with <span class="math inline">\(k\)</span> covariates.</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true"></a>sar_model_file &lt;-<span class="st"> &quot;sar_model.stan&quot;</span></span></code></pre></div>
<pre class="stan"><code>functions {
#include sar-lpdf.stan
}

data {
  // data
  int&lt;lower=1&gt; n;
  int&lt;lower=1&gt; k;
  vector[n] y;
  matrix[n, k] x;


// SAR
  int nImW_w;
  int nW;
  vector[nImW_w] ImW_w;
  array[nImW_w] int ImW_v;
  array[n + 1] int ImW_u;
  array[nW] int Widx;
  vector[n] eigenvalues_w;
}

parameters {
  // SA parameter
  real&lt;lower=1/min(eigenvalues_w), upper=1/max(eigenvalues_w)&gt; rho;     

  // scale parameter
  real&lt;lower=0&gt; sigma;

  // intercept
  real alpha;

  // coefficients
  vector[k] beta;
}

model{
  vector[n] mu = alpha + x * beta;

  // Likelihood: Y ~ Normal(Mu, Sigma)
  target += sar_normal_lpdf(y |
                  mu, sigma, rho,
                  ImW_w,
                  ImW_v,
                  ImW_u,
                  Widx,
                  eigenvalues_w,
                  n);

  // prior for scale parameter
  target += student_t_lpdf(sigma | 10, 0, 5);

  // prior for beta
  target += normal_lpdf(beta | 0, 5);

  // prior for intercept
  target += normal_lpdf(alpha | 0, 5);
}
</code></pre>
<div class="sourceCode" id="cb13"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true"></a><span class="kw">library</span>(geostan)</span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true"></a><span class="kw">library</span>(rstan)</span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true"></a><span class="kw">data</span>(georgia)</span>
<span id="cb13-4"><a href="#cb13-4" aria-hidden="true"></a></span>
<span id="cb13-5"><a href="#cb13-5" aria-hidden="true"></a>W &lt;-<span class="st"> </span><span class="kw">shape2mat</span>(georgia, <span class="st">&quot;W&quot;</span>)</span>
<span id="cb13-6"><a href="#cb13-6" aria-hidden="true"></a>sar_list &lt;-<span class="st"> </span><span class="kw">prep_sar_data</span>(W)</span>
<span id="cb13-7"><a href="#cb13-7" aria-hidden="true"></a></span>
<span id="cb13-8"><a href="#cb13-8" aria-hidden="true"></a><span class="co"># add data</span></span>
<span id="cb13-9"><a href="#cb13-9" aria-hidden="true"></a>sar_list<span class="op">$</span>y &lt;-<span class="st"> </span><span class="kw">log</span>(georgia<span class="op">$</span>income <span class="op">/</span><span class="st"> </span><span class="fl">10e3</span>)</span>
<span id="cb13-10"><a href="#cb13-10" aria-hidden="true"></a>sar_list<span class="op">$</span>x &lt;-<span class="st"> </span><span class="kw">matrix</span>(<span class="kw">log</span>(georgia<span class="op">$</span>population <span class="op">/</span><span class="st"> </span><span class="fl">10e3</span>), <span class="dt">ncol =</span> <span class="dv">1</span>)</span>
<span id="cb13-11"><a href="#cb13-11" aria-hidden="true"></a>sar_list<span class="op">$</span>k &lt;-<span class="st"> </span><span class="kw">ncol</span>(sar_list<span class="op">$</span>x)</span>
<span id="cb13-12"><a href="#cb13-12" aria-hidden="true"></a></span>
<span id="cb13-13"><a href="#cb13-13" aria-hidden="true"></a><span class="co"># compile Stan model from file</span></span>
<span id="cb13-14"><a href="#cb13-14" aria-hidden="true"></a>sar_model &lt;-<span class="st"> </span><span class="kw">stan_model</span>(sar_model_file)</span>
<span id="cb13-15"><a href="#cb13-15" aria-hidden="true"></a></span>
<span id="cb13-16"><a href="#cb13-16" aria-hidden="true"></a><span class="co"># sample from model</span></span>
<span id="cb13-17"><a href="#cb13-17" aria-hidden="true"></a>samples &lt;-<span class="st"> </span><span class="kw">sampling</span>(sar_model, <span class="dt">data =</span> sar_list, <span class="dt">iter =</span> <span class="fl">1e3</span>)</span></code></pre></div>
<p>We can draw samples from the same model using <code>geostan::stan_sar</code>:</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true"></a>sar_dl &lt;-<span class="st"> </span><span class="kw">prep_sar_data</span>(W)</span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true"></a>fit &lt;-<span class="st"> </span><span class="kw">stan_sar</span>(<span class="kw">log</span>(income <span class="op">/</span><span class="st"> </span><span class="fl">10e3</span>) <span class="op">~</span><span class="st"> </span><span class="kw">log</span>(population <span class="op">/</span><span class="st"> </span><span class="fl">10e3</span>), <span class="dt">data =</span> georgia,</span>
<span id="cb14-3"><a href="#cb14-3" aria-hidden="true"></a>    <span class="dt">sar_parts =</span> sar_dl, <span class="dt">iter =</span> <span class="fl">1e3</span>)</span></code></pre></div>
<p>One can also use the SAR model as a prior distribution for a parameter vector, just as was done above with the CAR model.</p>
</div>
<div id="references" class="section level1 unnumbered" number>
<h1 class="unnumbered" number>References</h1>
<div id="refs" class="references hanging-indent">
<div id="ref-donegan_2022">
<p>Donegan, Connor. 2022. “Building Spatial Conditional Autoregressive Models in the Stan Programming Language.” <em>OSF Preprints</em>. <a href="https://doi.org/10.31219/osf.io/3ey65">https://doi.org/10.31219/osf.io/3ey65</a>.</p>
</div>
<div id="ref-haining_2020">
<p>Haining, Robert P., and Guangquan Li. 2020. <em>Modelling Spatial and Spatio-Temporal Data: A Bayesian Approach</em>. CRC Press.</p>
</div>
</div>
</div>



<!-- code folding -->


<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    script.src  = "https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML";
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>

</body>
</html>
